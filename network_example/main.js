import {csvParseRows, csvFormatRows} from 'd3-dsv';
import Graph from 'graphology';
import forceAtlas2 from 'graphology-layout-forceatlas2';
import Sigma from 'sigma';

const network_source = 'transports';

const default_color = "#bbbbbb"//"#ec5148";
const node_color_by_city = {
  'Genève': "#b74d86",
  'Lausanne': "#50b47b",
  'Zürich': "#8650a6",
  'Luzern': "#86a542",
  'Moudon': "#6881d8",
  'Gallen': "#c08438",
  'Fribourg': "#43c9b0",
}

function get_node_color(label) {
  // Pick color if key exists in label
  for (const key in node_color_by_city) {
    if (label.includes(key)) {
      return node_color_by_city[key];
    }
  }
  return default_color;
}

/**
 * This function loads the data generated by the python script, it has no x and y coordinates
 */
async function load_data() {
  const response = await fetch('/data/networks/' + network_source + '/network_edges.csv');
  //const response = await fetch('/data/networks/transports/network_edges.csv');
  const data = await response.text();

  // Create a new graph instance
  const graph = new Graph();

  csvParseRows(data, (row, index) => {
    // Skip the header row
    if (index === 0) return null;

    const source = row[0];
    const source_name = row[1];
    const target = row[2];
    const target_name = row[3];
    const weight = row[4];

    // Add source if it doesn't exist, with random position
    if (!graph.hasNode(source)) {
      graph.addNode(source, {
        label: source_name, 
        x: Math.random() * 200, 
        y: Math.random() * 200});
    }

    // Add target if it doesn't exist
    if (!graph.hasNode(target)) {
      graph.addNode(target, {
        label: target_name, 
        x: Math.random() * 200, 
        y: Math.random() * 200});
    }

    // Add edge if it doesn't exist
    if (!graph.hasEdge(source, target)) {
      graph.addEdgeWithKey(source + '-' + target, source, target, {weight: weight});
    }

    return null;
  });

  return graph;
}

/**
 * This function is only used to get the x and y coordinates of the nodes after the layout
 */
function run_layout_and_save() {
  load_data().then(graph => {
    // Apply the ForceAtlas2 layout
    forceAtlas2.assign(graph, 100);

    // Get the nodes and edges and print them as csv
    const nodes = graph.nodes();
    const edges = graph.edges();

    const nodes_data = nodes.map(node => {
      const data = graph.getNodeAttributes(node);
      return [node, data.label, data.x, data.y];
    });

    const edges_data = edges.map(edge => {
      const split = edge.split('-');
      const source = split[0];
      const target = split[1];
      const data = graph.getEdgeAttributes(edge);
      return [edge, source, target, data.weight];
    });

    const nodes_csv = csvFormatRows(nodes_data);
    const edges_csv = csvFormatRows(edges_data);

    alert('Copy the nodes data, do not forget the header <id,label,x,y>');
    console.log(nodes_csv);
    alert('Copy the edges data do not forget the header <id,source,target,weight>');
    console.log(edges_csv);


  }).catch(error => {
    console.error('Error loading data:', error);
  });
}

/**
 * This function loads the data generated by the functions above, it has x and y coordinates
 */
async function load_web_data() {
  const node_response = await fetch('/data/networks/' + network_source + '/web_data/network_nodes.csv');
  //const node_response = await fetch('/data/networks/transports/web_data/network_edges.csv');
  const node_data = await node_response.text();

  const edge_response = await fetch('/data/networks/' + network_source + '/web_data/network_edges.csv');
  //const edge_response = await fetch('/data/networks/transports/web_data/network_nodes.csv');
  const edge_data = await edge_response.text();

  // Create a new graph instance
  const graph = new Graph();

  csvParseRows(node_data, (row, index) => {
    // Skip the header row
    if (index === 0) return null;

    const id = row[0];
    const label = row[1];
    const x = row[2];
    const y = row[3];

    // Add source if it doesn't exist, with random position
    if (!graph.hasNode(id)) {
      graph.addNode(id, {
        label: label, 
        x: parseInt(x), 
        y: parseInt(y),
        color: get_node_color(label),
      });
    }

    return null;
  });

  csvParseRows(edge_data, (row, index) => {
    // Skip the header row
    if (index === 0) return null;

    const id = row[0];
    const source = row[1];
    const target = row[2];
    const weight = row[3];

    // Add edge if it doesn't exist
    if (!graph.hasEdge(id)) {
      graph.addEdgeWithKey(id, source, target, {
        weight: weight,
        color: `rgba(150, 150, 150, 0.5)`,
        size: parseFloat(weight) / 50000,
      });
    }

    return null;
  });

  return graph;
}

function nodeReducer(node, data) {
  return {
    ...data,
    color: '#ec5148', // Default node color
  };
}

function edgeReducer(edge, data) {
  const weight = data.weight;
  const opacity = 0.6;
  const thickness = weight;

  return {
    ...data,
    color: `rgba(204, 204, 204, ${opacity})`,
    size: thickness,
  };
}

load_web_data().then(graph => {
  // Create a Sigma instance and render the graph
  const renderer = new Sigma(
    graph,
    document.getElementById('container')
  );

  renderer.refresh();
}).catch(error => {
  console.error('Error loading data:', error);
});