import {csvParseRows, csvFormatRows} from 'd3-dsv';
import Graph from 'graphology';
import forceAtlas2 from 'graphology-layout-forceatlas2';
import Sigma from 'sigma';

const network_source = 'transports';

// State variables
let layout = 'random';
const layout_transition_duration = 2000;

// Graph and renderer
let graph;
let renderer;

function get_layout_coordinates_arg() {
  if (layout === 'random') return ['x_rdm', 'y_rdm'];
  if (layout === 'forceatlas2') return ['x_fa2', 'y_fa2'];
  if (layout === 'geographical') return ['x_geo', 'y_geo'];

  console.error('Unknown layout: ' + layout);
  return ['x_rdm', 'y_rdm'];
}

// Colors
const default_color = "#aaaaaa"
const node_color_by_city = {
  'Genève': "#b74d86",
  'Lausanne': "#50b47b",
  'Zürich': "#8650a6",
  'Luzern': "#86a542",
  'Moudon': "#6881d8",
  'Gallen': "#c08438",
  'Fribourg': "#43c9b0",
}

function get_node_color(label) {
  // Pick color if key exists in label
  for (const key in node_color_by_city) {
    if (label.includes(key)) {
      return node_color_by_city[key];
    }
  }
  return default_color;
}

/**
 * This function loads the data generated by the functions above, it has x and y coordinates
 */
async function load_web_data() {
  const node_response = await fetch('/data/networks/' + network_source + '/web_data/network_nodes.csv');
  //const node_response = await fetch('/data/networks/transports/web_data/network_edges.csv');
  const node_data = await node_response.text();

  const edge_response = await fetch('/data/networks/' + network_source + '/web_data/network_edges.csv');
  //const edge_response = await fetch('/data/networks/transports/web_data/network_nodes.csv');
  const edge_data = await edge_response.text();

  // Create a new graph instance
  graph = new Graph();

  csvParseRows(node_data, (row, index) => {
    // Skip the header row
    if (index === 0) return null;

    const id = row[0];

    // Add source if it doesn't exist, with random position
    if (!graph.hasNode(id)) {
      const label = row[1];
      const x_rdm = Math.random() * 10000;
      const y_rdm = Math.random() * 10000;
      const x_fa2 = parseInt(row[2]);
      const y_fa2 = parseInt(row[3]);
      const x_geo = parseInt(row[4]);
      const y_geo = parseInt(row[5]);

      graph.addNode(id, {
        label: label, 
        color: get_node_color(label),
        x_rdm: x_rdm,
        y_rdm: y_rdm,
        x_fa2: x_fa2, 
        y_fa2: y_fa2,
        x_geo: x_geo,
        y_geo: y_geo,
        x: x_rdm,
        y: y_rdm,
      });
    }

    return null;
  });

  csvParseRows(edge_data, (row, index) => {
    // Skip the header row
    if (index === 0) return null;

    const id = row[0];
    const source = row[1];
    const target = row[2];
    const weight = row[3];

    // Add edge if it doesn't exist
    if (!graph.hasEdge(id)) {
      graph.addEdgeWithKey(id, source, target, {
        weight: weight,
        color: `rgba(150, 150, 150, 0.5)`,
        size: parseFloat(weight) / 50000,
      });
    }

    return null;
  });

  return graph;
}



function load_network() {
  load_web_data().then(graph => {
    // Create a Sigma instance and render the graph
    renderer = new Sigma(
      graph,
      document.getElementById('container')
    );

    renderer.refresh();
  }).catch(error => {
    console.error('Error loading data:', error);
  });
}

function lerp(a, b, t) {
  return a + (b - a) * t;
}

function updateNodePositions(graph, old_x_arg, old_y_arg, new_x_arg, new_y_arg, progress) {
  // Iterate through the nodes and update their positions
  graph.nodes().forEach(node => {
    const node_obj = graph.getNodeAttributes(node);
    node_obj.x = lerp(node_obj[old_x_arg], node_obj[new_x_arg], progress);
    node_obj.y = lerp(node_obj[old_y_arg], node_obj[new_y_arg], progress);
  });
}

function easeInOutQuad(t) {
  return t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
}

function animateNodeTransition(graph, renderer, old_x_arg, old_y_arg, new_x_arg, new_y_arg, duration) {
  const startTime = performance.now();

  function step(timestamp) {
    const progress = Math.min((timestamp - startTime) / duration, 1);
    const easedProgress = easeInOutQuad(progress);

    updateNodePositions(graph, old_x_arg, old_y_arg, new_x_arg, new_y_arg, easedProgress);

    // Refresh the renderer to display the updated positions
    renderer.refresh();

    if (progress < 1) {
      requestAnimationFrame(step);
    }
  }

  requestAnimationFrame(step);
}

function set_rdm_layout(graph, renderer) {
  if (layout === 'random') return;

  const coordinates_arg = get_layout_coordinates_arg();
  const old_x_arg = coordinates_arg[0];
  const old_y_arg = coordinates_arg[1];
  animateNodeTransition(graph, renderer, old_x_arg, old_y_arg, 'x_rdm', 'y_rdm', layout_transition_duration);
  layout = 'random';
}

function set_fa2_layout(graph, renderer) {
  if (layout === 'forceatlas2') return;

  const coordinates_arg = get_layout_coordinates_arg();
  const old_x_arg = coordinates_arg[0];
  const old_y_arg = coordinates_arg[1];
  animateNodeTransition(graph, renderer, old_x_arg, old_y_arg, 'x_fa2', 'y_fa2', layout_transition_duration);
  layout = 'forceatlas2';
}

function set_geo_layout(graph, renderer) {
  if (layout === 'geographical') return;

  const coordinates_arg = get_layout_coordinates_arg();
  const old_x_arg = coordinates_arg[0];
  const old_y_arg = coordinates_arg[1];
  animateNodeTransition(graph, renderer, old_x_arg, old_y_arg, 'x_geo', 'y_geo', layout_transition_duration);
  layout = 'geographical';
}

function handleSelectChange(event) {
  const selectedOption = event.target.value;

  if (selectedOption === 'rdm') {
    set_rdm_layout(graph, renderer);
  } else if (selectedOption === 'fa2') {
    set_fa2_layout(graph, renderer);
  } else if (selectedOption === 'geo') {
    set_geo_layout(graph, renderer);
  }
}

// Wait for the DOM to be loaded
document.addEventListener('DOMContentLoaded', () => {
  load_network();

  // Add event listeners
  const selectElement = document.getElementById('select');
  selectElement.addEventListener('change', handleSelectChange);
});

/**
 * This function loads the data generated by the python script, it has no x and y coordinates
 */
/*
async function load_data() {
  const response = await fetch('/data/networks/' + network_source + '/network_edges.csv');
  //const response = await fetch('/data/networks/transports/network_edges.csv');
  const data = await response.text();

  // Create a new graph instance
  const graph = new Graph();

  csvParseRows(data, (row, index) => {
    // Skip the header row
    if (index === 0) return null;

    const source = row[0];
    const source_name = row[1];
    const target = row[2];
    const target_name = row[3];
    const weight = row[4];

    // Add source if it doesn't exist, with random position
    if (!graph.hasNode(source)) {
      graph.addNode(source, {
        label: source_name, 
        x: Math.random() * 200, 
        y: Math.random() * 200});
    }

    // Add target if it doesn't exist
    if (!graph.hasNode(target)) {
      graph.addNode(target, {
        label: target_name, 
        x: Math.random() * 200, 
        y: Math.random() * 200});
    }

    // Add edge if it doesn't exist
    if (!graph.hasEdge(source, target)) {
      graph.addEdgeWithKey(source + '-' + target, source, target, {weight: weight});
    }

    return null;
  });

  return graph;
}
*/
/**
 * This function is only used to get the x and y coordinates of the nodes after the layout
 */
/*
function run_layout_and_save() {
  load_data().then(graph => {
    // Apply the ForceAtlas2 layout
    forceAtlas2.assign(graph, 100);

    // Get the nodes and edges and print them as csv
    const nodes = graph.nodes();
    const edges = graph.edges();

    const nodes_data = nodes.map(node => {
      const data = graph.getNodeAttributes(node);
      return [node, data.label, data.x, data.y];
    });

    const edges_data = edges.map(edge => {
      const split = edge.split('-');
      const source = split[0];
      const target = split[1];
      const data = graph.getEdgeAttributes(edge);
      return [edge, source, target, data.weight];
    });

    const nodes_csv = csvFormatRows(nodes_data);
    const edges_csv = csvFormatRows(edges_data);

    alert('Copy the nodes data, do not forget the header <id,label,x,y>');
    console.log(nodes_csv);
    alert('Copy the edges data do not forget the header <id,source,target,weight>');
    console.log(edges_csv);


  }).catch(error => {
    console.error('Error loading data:', error);
  });
}
*/