{
  "version": 3,
  "sources": ["../../obliterator/iterator.js", "../../obliterator/support.js", "../../obliterator/iter.js", "../../obliterator/take.js", "../../obliterator/chain.js", "../../graphology/src/utils.js", "../../graphology/src/errors.js", "../../graphology/src/data.js", "../../graphology/src/attributes/nodes.js", "../../graphology/src/attributes/edges.js", "../../graphology/src/iteration/edges.js", "../../graphology/src/iteration/neighbors.js", "../../graphology/src/iteration/adjacency.js", "../../graphology/src/serialization.js", "../../graphology/src/graph.js", "../../graphology/src/classes.js", "../../graphology/src/endpoint.esm.js"],
  "sourcesContent": ["/**\r\n * Obliterator Iterator Class\r\n * ===========================\r\n *\r\n * Simple class representing the library's iterators.\r\n */\r\n\r\n/**\r\n * Iterator class.\r\n *\r\n * @constructor\r\n * @param {function} next - Next function.\r\n */\r\nfunction Iterator(next) {\r\n  if (typeof next !== 'function')\r\n    throw new Error('obliterator/iterator: expecting a function!');\r\n\r\n  this.next = next;\r\n}\r\n\r\n/**\r\n * If symbols are supported, we add `next` to `Symbol.iterator`.\r\n */\r\nif (typeof Symbol !== 'undefined')\r\n  Iterator.prototype[Symbol.iterator] = function () {\r\n    return this;\r\n  };\r\n\r\n/**\r\n * Returning an iterator of the given values.\r\n *\r\n * @param  {any...} values - Values.\r\n * @return {Iterator}\r\n */\r\nIterator.of = function () {\r\n  var args = arguments,\r\n    l = args.length,\r\n    i = 0;\r\n\r\n  return new Iterator(function () {\r\n    if (i >= l) return {done: true};\r\n\r\n    return {done: false, value: args[i++]};\r\n  });\r\n};\r\n\r\n/**\r\n * Returning an empty iterator.\r\n *\r\n * @return {Iterator}\r\n */\r\nIterator.empty = function () {\r\n  var iterator = new Iterator(function () {\r\n    return {done: true};\r\n  });\r\n\r\n  return iterator;\r\n};\r\n\r\n/**\r\n * Returning an iterator over the given indexed sequence.\r\n *\r\n * @param  {string|Array} sequence - Target sequence.\r\n * @return {Iterator}\r\n */\r\nIterator.fromSequence = function (sequence) {\r\n  var i = 0,\r\n    l = sequence.length;\r\n\r\n  return new Iterator(function () {\r\n    if (i >= l) return {done: true};\r\n\r\n    return {done: false, value: sequence[i++]};\r\n  });\r\n};\r\n\r\n/**\r\n * Returning whether the given value is an iterator.\r\n *\r\n * @param  {any} value - Value.\r\n * @return {boolean}\r\n */\r\nIterator.is = function (value) {\r\n  if (value instanceof Iterator) return true;\r\n\r\n  return (\r\n    typeof value === 'object' &&\r\n    value !== null &&\r\n    typeof value.next === 'function'\r\n  );\r\n};\r\n\r\n/**\r\n * Exporting.\r\n */\r\nmodule.exports = Iterator;\r\n", "exports.ARRAY_BUFFER_SUPPORT = typeof ArrayBuffer !== 'undefined';\r\nexports.SYMBOL_SUPPORT = typeof Symbol !== 'undefined';\r\n", "/**\r\n * Obliterator Iter Function\r\n * ==========================\r\n *\r\n * Function coercing values to an iterator. It can be quite useful when needing\r\n * to handle iterables and iterators the same way.\r\n */\r\nvar Iterator = require('./iterator.js');\r\nvar support = require('./support.js');\r\n\r\nvar ARRAY_BUFFER_SUPPORT = support.ARRAY_BUFFER_SUPPORT;\r\nvar SYMBOL_SUPPORT = support.SYMBOL_SUPPORT;\r\n\r\nfunction iterOrNull(target) {\r\n  // Indexed sequence\r\n  if (\r\n    typeof target === 'string' ||\r\n    Array.isArray(target) ||\r\n    (ARRAY_BUFFER_SUPPORT && ArrayBuffer.isView(target))\r\n  )\r\n    return Iterator.fromSequence(target);\r\n\r\n  // Invalid value\r\n  if (typeof target !== 'object' || target === null) return null;\r\n\r\n  // Iterable\r\n  if (SYMBOL_SUPPORT && typeof target[Symbol.iterator] === 'function')\r\n    return target[Symbol.iterator]();\r\n\r\n  // Iterator duck-typing\r\n  if (typeof target.next === 'function') return target;\r\n\r\n  // Invalid object\r\n  return null;\r\n}\r\n\r\nmodule.exports = function iter(target) {\r\n  var iterator = iterOrNull(target);\r\n\r\n  if (!iterator)\r\n    throw new Error(\r\n      'obliterator: target is not iterable nor a valid iterator.'\r\n    );\r\n\r\n  return iterator;\r\n};\r\n", "/* eslint no-constant-condition: 0 */\r\n/**\r\n * Obliterator Take Function\r\n * ==========================\r\n *\r\n * Function taking n or every value of the given iterator and returns them\r\n * into an array.\r\n */\r\nvar iter = require('./iter.js');\r\n\r\n/**\r\n * Take.\r\n *\r\n * @param  {Iterable} iterable - Target iterable.\r\n * @param  {number}   [n]      - Optional number of items to take.\r\n * @return {array}\r\n */\r\nmodule.exports = function take(iterable, n) {\r\n  var l = arguments.length > 1 ? n : Infinity,\r\n    array = l !== Infinity ? new Array(l) : [],\r\n    step,\r\n    i = 0;\r\n\r\n  var iterator = iter(iterable);\r\n\r\n  while (true) {\r\n    if (i === l) return array;\r\n\r\n    step = iterator.next();\r\n\r\n    if (step.done) {\r\n      if (i !== n) array.length = i;\r\n\r\n      return array;\r\n    }\r\n\r\n    array[i++] = step.value;\r\n  }\r\n};\r\n", "/**\r\n * Obliterator Chain Function\r\n * ===========================\r\n *\r\n * Variadic function combining the given iterables.\r\n */\r\nvar Iterator = require('./iterator.js');\r\nvar iter = require('./iter.js');\r\n\r\n/**\r\n * Chain.\r\n *\r\n * @param  {...Iterator} iterables - Target iterables.\r\n * @return {Iterator}\r\n */\r\nmodule.exports = function chain() {\r\n  var iterables = arguments;\r\n  var current = null;\r\n  var i = -1;\r\n\r\n  /* eslint-disable no-constant-condition */\r\n  return new Iterator(function next() {\r\n    var step = null;\r\n\r\n    do {\r\n      if (current === null) {\r\n        i++;\r\n\r\n        if (i >= iterables.length) return {done: true};\r\n\r\n        current = iter(iterables[i]);\r\n      }\r\n\r\n      step = current.next();\r\n\r\n      if (step.done === true) {\r\n        current = null;\r\n        continue;\r\n      }\r\n\r\n      break;\r\n    } while (true);\r\n\r\n    return step;\r\n  });\r\n};\r\n", "/**\n * Graphology Utilities\n * =====================\n *\n * Collection of helpful functions used by the implementation.\n */\n\n/**\n * Object.assign-like polyfill.\n *\n * @param  {object} target       - First object.\n * @param  {object} [...objects] - Objects to merge.\n * @return {object}\n */\nfunction assignPolyfill() {\n  const target = arguments[0];\n\n  for (let i = 1, l = arguments.length; i < l; i++) {\n    if (!arguments[i]) continue;\n\n    for (const k in arguments[i]) target[k] = arguments[i][k];\n  }\n\n  return target;\n}\n\nlet assign = assignPolyfill;\n\nif (typeof Object.assign === 'function') assign = Object.assign;\n\nexport {assign};\n\n/**\n * Function returning the first matching edge for given path.\n * Note: this function does not check the existence of source & target. This\n * must be performed by the caller.\n *\n * @param  {Graph}  graph  - Target graph.\n * @param  {any}    source - Source node.\n * @param  {any}    target - Target node.\n * @param  {string} type   - Type of the edge (mixed, directed or undirected).\n * @return {string|null}\n */\nexport function getMatchingEdge(graph, source, target, type) {\n  const sourceData = graph._nodes.get(source);\n\n  let edge = null;\n\n  if (!sourceData) return edge;\n\n  if (type === 'mixed') {\n    edge =\n      (sourceData.out && sourceData.out[target]) ||\n      (sourceData.undirected && sourceData.undirected[target]);\n  } else if (type === 'directed') {\n    edge = sourceData.out && sourceData.out[target];\n  } else {\n    edge = sourceData.undirected && sourceData.undirected[target];\n  }\n\n  return edge;\n}\n\n/**\n * Checks whether the given value is a plain object.\n *\n * @param  {mixed}   value - Target value.\n * @return {boolean}\n */\nexport function isPlainObject(value) {\n  return (\n    typeof value === 'object' && value !== null && value.constructor === Object\n  );\n}\n\n/**\n * Checks whether the given object is empty.\n *\n * @param  {object}  o - Target Object.\n * @return {boolean}\n */\nexport function isEmpty(o) {\n  let k;\n\n  for (k in o) return false;\n\n  return true;\n}\n\n/**\n * Creates a \"private\" property for the given member name by concealing it\n * using the `enumerable` option.\n *\n * @param {object} target - Target object.\n * @param {string} name   - Member name.\n */\nexport function privateProperty(target, name, value) {\n  Object.defineProperty(target, name, {\n    enumerable: false,\n    configurable: false,\n    writable: true,\n    value\n  });\n}\n\n/**\n * Creates a read-only property for the given member name & the given getter.\n *\n * @param {object}   target - Target object.\n * @param {string}   name   - Member name.\n * @param {mixed}    value  - The attached getter or fixed value.\n */\nexport function readOnlyProperty(target, name, value) {\n  const descriptor = {\n    enumerable: true,\n    configurable: true\n  };\n\n  if (typeof value === 'function') {\n    descriptor.get = value;\n  } else {\n    descriptor.value = value;\n    descriptor.writable = false;\n  }\n\n  Object.defineProperty(target, name, descriptor);\n}\n\n/**\n * Returns whether the given object constitute valid hints.\n *\n * @param {object} hints - Target object.\n */\nexport function validateHints(hints) {\n  if (!isPlainObject(hints)) return false;\n\n  if (hints.attributes && !Array.isArray(hints.attributes)) return false;\n\n  return true;\n}\n\n/**\n * Creates a function generating incremental ids for edges.\n *\n * @return {function}\n */\nexport function incrementalIdStartingFromRandomByte() {\n  let i = Math.floor(Math.random() * 256) & 0xff;\n\n  return () => {\n    return i++;\n  };\n}\n", "/**\n * Graphology Custom Errors\n * =========================\n *\n * Defining custom errors for ease of use & easy unit tests across\n * implementations (normalized typology rather than relying on error\n * messages to check whether the correct error was found).\n */\nexport class GraphError extends Error {\n  constructor(message) {\n    super();\n    this.name = 'GraphError';\n    this.message = message;\n  }\n}\n\nexport class InvalidArgumentsGraphError extends GraphError {\n  constructor(message) {\n    super(message);\n    this.name = 'InvalidArgumentsGraphError';\n\n    // This is V8 specific to enhance stack readability\n    if (typeof Error.captureStackTrace === 'function')\n      Error.captureStackTrace(\n        this,\n        InvalidArgumentsGraphError.prototype.constructor\n      );\n  }\n}\n\nexport class NotFoundGraphError extends GraphError {\n  constructor(message) {\n    super(message);\n    this.name = 'NotFoundGraphError';\n\n    // This is V8 specific to enhance stack readability\n    if (typeof Error.captureStackTrace === 'function')\n      Error.captureStackTrace(this, NotFoundGraphError.prototype.constructor);\n  }\n}\n\nexport class UsageGraphError extends GraphError {\n  constructor(message) {\n    super(message);\n    this.name = 'UsageGraphError';\n\n    // This is V8 specific to enhance stack readability\n    if (typeof Error.captureStackTrace === 'function')\n      Error.captureStackTrace(this, UsageGraphError.prototype.constructor);\n  }\n}\n", "/**\n * Graphology Internal Data Classes\n * =================================\n *\n * Internal classes hopefully reduced to structs by engines & storing\n * necessary information for nodes & edges.\n *\n * Note that those classes don't rely on the `class` keyword to avoid some\n * cruft introduced by most of ES2015 transpilers.\n */\n\n/**\n * MixedNodeData class.\n *\n * @constructor\n * @param {string} string     - The node's key.\n * @param {object} attributes - Node's attributes.\n */\nexport function MixedNodeData(key, attributes) {\n  // Attributes\n  this.key = key;\n  this.attributes = attributes;\n\n  this.clear();\n}\n\nMixedNodeData.prototype.clear = function () {\n  // Degrees\n  this.inDegree = 0;\n  this.outDegree = 0;\n  this.undirectedDegree = 0;\n  this.undirectedLoops = 0;\n  this.directedLoops = 0;\n\n  // Indices\n  this.in = {};\n  this.out = {};\n  this.undirected = {};\n};\n\n/**\n * DirectedNodeData class.\n *\n * @constructor\n * @param {string} string     - The node's key.\n * @param {object} attributes - Node's attributes.\n */\nexport function DirectedNodeData(key, attributes) {\n  // Attributes\n  this.key = key;\n  this.attributes = attributes;\n\n  this.clear();\n}\n\nDirectedNodeData.prototype.clear = function () {\n  // Degrees\n  this.inDegree = 0;\n  this.outDegree = 0;\n  this.directedLoops = 0;\n\n  // Indices\n  this.in = {};\n  this.out = {};\n};\n\n/**\n * UndirectedNodeData class.\n *\n * @constructor\n * @param {string} string     - The node's key.\n * @param {object} attributes - Node's attributes.\n */\nexport function UndirectedNodeData(key, attributes) {\n  // Attributes\n  this.key = key;\n  this.attributes = attributes;\n\n  this.clear();\n}\n\nUndirectedNodeData.prototype.clear = function () {\n  // Degrees\n  this.undirectedDegree = 0;\n  this.undirectedLoops = 0;\n\n  // Indices\n  this.undirected = {};\n};\n\n/**\n * EdgeData class.\n *\n * @constructor\n * @param {boolean} undirected   - Whether the edge is undirected.\n * @param {string}  string       - The edge's key.\n * @param {string}  source       - Source of the edge.\n * @param {string}  target       - Target of the edge.\n * @param {object}  attributes   - Edge's attributes.\n */\nexport function EdgeData(undirected, key, source, target, attributes) {\n  // Attributes\n  this.key = key;\n  this.attributes = attributes;\n  this.undirected = undirected;\n\n  // Extremities\n  this.source = source;\n  this.target = target;\n}\n\nEdgeData.prototype.attach = function () {\n  let outKey = 'out';\n  let inKey = 'in';\n\n  if (this.undirected) outKey = inKey = 'undirected';\n\n  const source = this.source.key;\n  const target = this.target.key;\n\n  // Handling source\n  this.source[outKey][target] = this;\n\n  if (this.undirected && source === target) return;\n\n  // Handling target\n  this.target[inKey][source] = this;\n};\n\nEdgeData.prototype.attachMulti = function () {\n  let outKey = 'out';\n  let inKey = 'in';\n\n  const source = this.source.key;\n  const target = this.target.key;\n\n  if (this.undirected) outKey = inKey = 'undirected';\n\n  // Handling source\n  const adj = this.source[outKey];\n  const head = adj[target];\n\n  if (typeof head === 'undefined') {\n    adj[target] = this;\n\n    // Self-loop optimization\n    if (!(this.undirected && source === target)) {\n      // Handling target\n      this.target[inKey][source] = this;\n    }\n\n    return;\n  }\n\n  // Prepending to doubly-linked list\n  head.previous = this;\n  this.next = head;\n\n  // Pointing to new head\n  // NOTE: use mutating swap later to avoid lookup?\n  adj[target] = this;\n  this.target[inKey][source] = this;\n};\n\nEdgeData.prototype.detach = function () {\n  const source = this.source.key;\n  const target = this.target.key;\n\n  let outKey = 'out';\n  let inKey = 'in';\n\n  if (this.undirected) outKey = inKey = 'undirected';\n\n  delete this.source[outKey][target];\n\n  // No-op delete in case of undirected self-loop\n  delete this.target[inKey][source];\n};\n\nEdgeData.prototype.detachMulti = function () {\n  const source = this.source.key;\n  const target = this.target.key;\n\n  let outKey = 'out';\n  let inKey = 'in';\n\n  if (this.undirected) outKey = inKey = 'undirected';\n\n  // Deleting from doubly-linked list\n  if (this.previous === undefined) {\n    // We are dealing with the head\n\n    // Should we delete the adjacency entry because it is now empty?\n    if (this.next === undefined) {\n      delete this.source[outKey][target];\n\n      // No-op delete in case of undirected self-loop\n      delete this.target[inKey][source];\n    } else {\n      // Detaching\n      this.next.previous = undefined;\n\n      // NOTE: could avoid the lookups by creating a #.become mutating method\n      this.source[outKey][target] = this.next;\n\n      // No-op delete in case of undirected self-loop\n      this.target[inKey][source] = this.next;\n    }\n  } else {\n    // We are dealing with another list node\n    this.previous.next = this.next;\n\n    // If not last\n    if (this.next !== undefined) {\n      this.next.previous = this.previous;\n    }\n  }\n};\n", "/**\n * Graphology Node Attributes methods\n * ===================================\n */\nimport {assign, isPlainObject} from '../utils';\n\nimport {InvalidArgumentsGraphError, NotFoundGraphError} from '../errors';\n\nconst NODE = 0;\nconst SOURCE = 1;\nconst TARGET = 2;\nconst OPPOSITE = 3;\n\nfunction findRelevantNodeData(\n  graph,\n  method,\n  mode,\n  nodeOrEdge,\n  nameOrEdge,\n  add1,\n  add2\n) {\n  let nodeData, edgeData, arg1, arg2;\n\n  nodeOrEdge = '' + nodeOrEdge;\n\n  if (mode === NODE) {\n    nodeData = graph._nodes.get(nodeOrEdge);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.${method}: could not find the \"${nodeOrEdge}\" node in the graph.`\n      );\n\n    arg1 = nameOrEdge;\n    arg2 = add1;\n  } else if (mode === OPPOSITE) {\n    nameOrEdge = '' + nameOrEdge;\n\n    edgeData = graph._edges.get(nameOrEdge);\n\n    if (!edgeData)\n      throw new NotFoundGraphError(\n        `Graph.${method}: could not find the \"${nameOrEdge}\" edge in the graph.`\n      );\n\n    const source = edgeData.source.key;\n    const target = edgeData.target.key;\n\n    if (nodeOrEdge === source) {\n      nodeData = edgeData.target;\n    } else if (nodeOrEdge === target) {\n      nodeData = edgeData.source;\n    } else {\n      throw new NotFoundGraphError(\n        `Graph.${method}: the \"${nodeOrEdge}\" node is not attached to the \"${nameOrEdge}\" edge (${source}, ${target}).`\n      );\n    }\n\n    arg1 = add1;\n    arg2 = add2;\n  } else {\n    edgeData = graph._edges.get(nodeOrEdge);\n\n    if (!edgeData)\n      throw new NotFoundGraphError(\n        `Graph.${method}: could not find the \"${nodeOrEdge}\" edge in the graph.`\n      );\n\n    if (mode === SOURCE) {\n      nodeData = edgeData.source;\n    } else {\n      nodeData = edgeData.target;\n    }\n\n    arg1 = nameOrEdge;\n    arg2 = add1;\n  }\n\n  return [nodeData, arg1, arg2];\n}\n\nfunction attachNodeAttributeGetter(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1) {\n    const [data, name] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge,\n      add1\n    );\n\n    return data.attributes[name];\n  };\n}\n\nfunction attachNodeAttributesGetter(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge) {\n    const [data] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge\n    );\n\n    return data.attributes;\n  };\n}\n\nfunction attachNodeAttributeChecker(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1) {\n    const [data, name] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge,\n      add1\n    );\n\n    return data.attributes.hasOwnProperty(name);\n  };\n}\n\nfunction attachNodeAttributeSetter(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1, add2) {\n    const [data, name, value] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge,\n      add1,\n      add2\n    );\n\n    data.attributes[name] = value;\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: data.key,\n      type: 'set',\n      attributes: data.attributes,\n      name\n    });\n\n    return this;\n  };\n}\n\nfunction attachNodeAttributeUpdater(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1, add2) {\n    const [data, name, updater] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge,\n      add1,\n      add2\n    );\n\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        `Graph.${method}: updater should be a function.`\n      );\n\n    const attributes = data.attributes;\n    const value = updater(attributes[name]);\n\n    attributes[name] = value;\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: data.key,\n      type: 'set',\n      attributes: data.attributes,\n      name\n    });\n\n    return this;\n  };\n}\n\nfunction attachNodeAttributeRemover(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1) {\n    const [data, name] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge,\n      add1\n    );\n\n    delete data.attributes[name];\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: data.key,\n      type: 'remove',\n      attributes: data.attributes,\n      name\n    });\n\n    return this;\n  };\n}\n\nfunction attachNodeAttributesReplacer(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1) {\n    const [data, attributes] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge,\n      add1\n    );\n\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(\n        `Graph.${method}: provided attributes are not a plain object.`\n      );\n\n    data.attributes = attributes;\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: data.key,\n      type: 'replace',\n      attributes: data.attributes\n    });\n\n    return this;\n  };\n}\n\nfunction attachNodeAttributesMerger(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1) {\n    const [data, attributes] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge,\n      add1\n    );\n\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(\n        `Graph.${method}: provided attributes are not a plain object.`\n      );\n\n    assign(data.attributes, attributes);\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: data.key,\n      type: 'merge',\n      attributes: data.attributes,\n      data: attributes\n    });\n\n    return this;\n  };\n}\n\nfunction attachNodeAttributesUpdater(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1) {\n    const [data, updater] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge,\n      add1\n    );\n\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        `Graph.${method}: provided updater is not a function.`\n      );\n\n    data.attributes = updater(data.attributes);\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: data.key,\n      type: 'update',\n      attributes: data.attributes\n    });\n\n    return this;\n  };\n}\n\n/**\n * List of methods to attach.\n */\nconst NODE_ATTRIBUTES_METHODS = [\n  {\n    name: element => `get${element}Attribute`,\n    attacher: attachNodeAttributeGetter\n  },\n  {\n    name: element => `get${element}Attributes`,\n    attacher: attachNodeAttributesGetter\n  },\n  {\n    name: element => `has${element}Attribute`,\n    attacher: attachNodeAttributeChecker\n  },\n  {\n    name: element => `set${element}Attribute`,\n    attacher: attachNodeAttributeSetter\n  },\n  {\n    name: element => `update${element}Attribute`,\n    attacher: attachNodeAttributeUpdater\n  },\n  {\n    name: element => `remove${element}Attribute`,\n    attacher: attachNodeAttributeRemover\n  },\n  {\n    name: element => `replace${element}Attributes`,\n    attacher: attachNodeAttributesReplacer\n  },\n  {\n    name: element => `merge${element}Attributes`,\n    attacher: attachNodeAttributesMerger\n  },\n  {\n    name: element => `update${element}Attributes`,\n    attacher: attachNodeAttributesUpdater\n  }\n];\n\n/**\n * Attach every attributes-related methods to a Graph class.\n *\n * @param {function} Graph - Target class.\n */\nexport default function attachNodeAttributesMethods(Graph) {\n  NODE_ATTRIBUTES_METHODS.forEach(function ({name, attacher}) {\n    // For nodes\n    attacher(Graph, name('Node'), NODE);\n\n    // For sources\n    attacher(Graph, name('Source'), SOURCE);\n\n    // For targets\n    attacher(Graph, name('Target'), TARGET);\n\n    // For opposites\n    attacher(Graph, name('Opposite'), OPPOSITE);\n  });\n}\n", "/**\n * Graphology Edge Attributes methods\n * ===================================\n */\nimport {assign, isPlainObject, getMatchingEdge} from '../utils';\n\nimport {\n  InvalidArgumentsGraphError,\n  NotFoundGraphError,\n  UsageGraphError\n} from '../errors';\n\n/**\n * Attach an attribute getter method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachEdgeAttributeGetter(Class, method, type) {\n  /**\n   * Get the desired attribute for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element - Target element.\n   * @param  {string} name    - Attribute's name.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source - Source element.\n   * @param  {any}     target - Target element.\n   * @param  {string}  name   - Attribute's name.\n   *\n   * @return {mixed}          - The attribute's value.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, name) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 2) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element;\n      const target = '' + name;\n\n      name = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      if (type !== 'mixed')\n        throw new UsageGraphError(\n          `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`\n        );\n\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    return data.attributes[name];\n  };\n}\n\n/**\n * Attach an attributes getter method onto the provided class.\n *\n * @param {function} Class       - Target class.\n * @param {string}   method      - Method name.\n * @param {string}   type        - Type of the edge to find.\n */\nfunction attachEdgeAttributesGetter(Class, method, type) {\n  /**\n   * Retrieves all the target element's attributes.\n   *\n   * Arity 2:\n   * @param  {any}    element - Target element.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source - Source element.\n   * @param  {any}     target - Target element.\n   *\n   * @return {object}          - The element's attributes.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 1) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element,\n        target = '' + arguments[1];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      if (type !== 'mixed')\n        throw new UsageGraphError(\n          `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`\n        );\n\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    return data.attributes;\n  };\n}\n\n/**\n * Attach an attribute checker method onto the provided class.\n *\n * @param {function} Class       - Target class.\n * @param {string}   method      - Method name.\n * @param {string}   type        - Type of the edge to find.\n */\nfunction attachEdgeAttributeChecker(Class, method, type) {\n  /**\n   * Checks whether the desired attribute is set for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element - Target element.\n   * @param  {string} name    - Attribute's name.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source - Source element.\n   * @param  {any}     target - Target element.\n   * @param  {string}  name   - Attribute's name.\n   *\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, name) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 2) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element;\n      const target = '' + name;\n\n      name = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      if (type !== 'mixed')\n        throw new UsageGraphError(\n          `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`\n        );\n\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    return data.attributes.hasOwnProperty(name);\n  };\n}\n\n/**\n * Attach an attribute setter method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachEdgeAttributeSetter(Class, method, type) {\n  /**\n   * Set the desired attribute for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element - Target element.\n   * @param  {string} name    - Attribute's name.\n   * @param  {mixed}  value   - New attribute value.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source - Source element.\n   * @param  {any}     target - Target element.\n   * @param  {string}  name   - Attribute's name.\n   * @param  {mixed}  value   - New attribute value.\n   *\n   * @return {Graph}          - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, name, value) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 3) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element;\n      const target = '' + name;\n\n      name = arguments[2];\n      value = arguments[3];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      if (type !== 'mixed')\n        throw new UsageGraphError(\n          `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`\n        );\n\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    data.attributes[name] = value;\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'set',\n      attributes: data.attributes,\n      name\n    });\n\n    return this;\n  };\n}\n\n/**\n * Attach an attribute updater method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachEdgeAttributeUpdater(Class, method, type) {\n  /**\n   * Update the desired attribute for the given element (node or edge) using\n   * the provided function.\n   *\n   * Arity 2:\n   * @param  {any}      element - Target element.\n   * @param  {string}   name    - Attribute's name.\n   * @param  {function} updater - Updater function.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}      source  - Source element.\n   * @param  {any}      target  - Target element.\n   * @param  {string}   name    - Attribute's name.\n   * @param  {function} updater - Updater function.\n   *\n   * @return {Graph}            - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, name, updater) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 3) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element;\n      const target = '' + name;\n\n      name = arguments[2];\n      updater = arguments[3];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      if (type !== 'mixed')\n        throw new UsageGraphError(\n          `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`\n        );\n\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        `Graph.${method}: updater should be a function.`\n      );\n\n    data.attributes[name] = updater(data.attributes[name]);\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'set',\n      attributes: data.attributes,\n      name\n    });\n\n    return this;\n  };\n}\n\n/**\n * Attach an attribute remover method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachEdgeAttributeRemover(Class, method, type) {\n  /**\n   * Remove the desired attribute for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element - Target element.\n   * @param  {string} name    - Attribute's name.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source - Source element.\n   * @param  {any}     target - Target element.\n   * @param  {string}  name   - Attribute's name.\n   *\n   * @return {Graph}          - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, name) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 2) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element;\n      const target = '' + name;\n\n      name = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      if (type !== 'mixed')\n        throw new UsageGraphError(\n          `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`\n        );\n\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    delete data.attributes[name];\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'remove',\n      attributes: data.attributes,\n      name\n    });\n\n    return this;\n  };\n}\n\n/**\n * Attach an attribute replacer method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachEdgeAttributesReplacer(Class, method, type) {\n  /**\n   * Replace the attributes for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element    - Target element.\n   * @param  {object} attributes - New attributes.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source     - Source element.\n   * @param  {any}     target     - Target element.\n   * @param  {object}  attributes - New attributes.\n   *\n   * @return {Graph}              - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, attributes) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 2) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element,\n        target = '' + attributes;\n\n      attributes = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      if (type !== 'mixed')\n        throw new UsageGraphError(\n          `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`\n        );\n\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(\n        `Graph.${method}: provided attributes are not a plain object.`\n      );\n\n    data.attributes = attributes;\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'replace',\n      attributes: data.attributes\n    });\n\n    return this;\n  };\n}\n\n/**\n * Attach an attribute merger method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachEdgeAttributesMerger(Class, method, type) {\n  /**\n   * Merge the attributes for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element    - Target element.\n   * @param  {object} attributes - Attributes to merge.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source     - Source element.\n   * @param  {any}     target     - Target element.\n   * @param  {object}  attributes - Attributes to merge.\n   *\n   * @return {Graph}              - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, attributes) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 2) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element,\n        target = '' + attributes;\n\n      attributes = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      if (type !== 'mixed')\n        throw new UsageGraphError(\n          `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`\n        );\n\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(\n        `Graph.${method}: provided attributes are not a plain object.`\n      );\n\n    assign(data.attributes, attributes);\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'merge',\n      attributes: data.attributes,\n      data: attributes\n    });\n\n    return this;\n  };\n}\n\n/**\n * Attach an attribute updater method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachEdgeAttributesUpdater(Class, method, type) {\n  /**\n   * Update the attributes of the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}      element - Target element.\n   * @param  {function} updater - Updater function.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}      source  - Source element.\n   * @param  {any}      target  - Target element.\n   * @param  {function} updater - Updater function.\n   *\n   * @return {Graph}            - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, updater) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 2) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element,\n        target = '' + updater;\n\n      updater = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      if (type !== 'mixed')\n        throw new UsageGraphError(\n          `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`\n        );\n\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        `Graph.${method}: provided updater is not a function.`\n      );\n\n    data.attributes = updater(data.attributes);\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'update',\n      attributes: data.attributes\n    });\n\n    return this;\n  };\n}\n\n/**\n * List of methods to attach.\n */\nconst EDGE_ATTRIBUTES_METHODS = [\n  {\n    name: element => `get${element}Attribute`,\n    attacher: attachEdgeAttributeGetter\n  },\n  {\n    name: element => `get${element}Attributes`,\n    attacher: attachEdgeAttributesGetter\n  },\n  {\n    name: element => `has${element}Attribute`,\n    attacher: attachEdgeAttributeChecker\n  },\n  {\n    name: element => `set${element}Attribute`,\n    attacher: attachEdgeAttributeSetter\n  },\n  {\n    name: element => `update${element}Attribute`,\n    attacher: attachEdgeAttributeUpdater\n  },\n  {\n    name: element => `remove${element}Attribute`,\n    attacher: attachEdgeAttributeRemover\n  },\n  {\n    name: element => `replace${element}Attributes`,\n    attacher: attachEdgeAttributesReplacer\n  },\n  {\n    name: element => `merge${element}Attributes`,\n    attacher: attachEdgeAttributesMerger\n  },\n  {\n    name: element => `update${element}Attributes`,\n    attacher: attachEdgeAttributesUpdater\n  }\n];\n\n/**\n * Attach every attributes-related methods to a Graph class.\n *\n * @param {function} Graph - Target class.\n */\nexport default function attachEdgeAttributesMethods(Graph) {\n  EDGE_ATTRIBUTES_METHODS.forEach(function ({name, attacher}) {\n    // For edges\n    attacher(Graph, name('Edge'), 'mixed');\n\n    // For directed edges\n    attacher(Graph, name('DirectedEdge'), 'directed');\n\n    // For undirected edges\n    attacher(Graph, name('UndirectedEdge'), 'undirected');\n  });\n}\n", "/**\n * Graphology Edge Iteration\n * ==========================\n *\n * Attaching some methods to the Graph class to be able to iterate over a\n * graph's edges.\n */\nimport Iterator from 'obliterator/iterator';\nimport chain from 'obliterator/chain';\nimport take from 'obliterator/take';\n\nimport {InvalidArgumentsGraphError, NotFoundGraphError} from '../errors';\n\n/**\n * Definitions.\n */\nconst EDGES_ITERATION = [\n  {\n    name: 'edges',\n    type: 'mixed'\n  },\n  {\n    name: 'inEdges',\n    type: 'directed',\n    direction: 'in'\n  },\n  {\n    name: 'outEdges',\n    type: 'directed',\n    direction: 'out'\n  },\n  {\n    name: 'inboundEdges',\n    type: 'mixed',\n    direction: 'in'\n  },\n  {\n    name: 'outboundEdges',\n    type: 'mixed',\n    direction: 'out'\n  },\n  {\n    name: 'directedEdges',\n    type: 'directed'\n  },\n  {\n    name: 'undirectedEdges',\n    type: 'undirected'\n  }\n];\n\n/**\n * Function iterating over edges from the given object to match one of them.\n *\n * @param {object}   object   - Target object.\n * @param {function} callback - Function to call.\n */\nfunction forEachSimple(breakable, object, callback, avoid) {\n  let shouldBreak = false;\n\n  for (const k in object) {\n    if (k === avoid) continue;\n\n    const edgeData = object[k];\n\n    shouldBreak = callback(\n      edgeData.key,\n      edgeData.attributes,\n      edgeData.source.key,\n      edgeData.target.key,\n      edgeData.source.attributes,\n      edgeData.target.attributes,\n      edgeData.undirected\n    );\n\n    if (breakable && shouldBreak) return edgeData.key;\n  }\n\n  return;\n}\n\nfunction forEachMulti(breakable, object, callback, avoid) {\n  let edgeData, source, target;\n\n  let shouldBreak = false;\n\n  for (const k in object) {\n    if (k === avoid) continue;\n\n    edgeData = object[k];\n\n    do {\n      source = edgeData.source;\n      target = edgeData.target;\n\n      shouldBreak = callback(\n        edgeData.key,\n        edgeData.attributes,\n        source.key,\n        target.key,\n        source.attributes,\n        target.attributes,\n        edgeData.undirected\n      );\n\n      if (breakable && shouldBreak) return edgeData.key;\n\n      edgeData = edgeData.next;\n    } while (edgeData !== undefined);\n  }\n\n  return;\n}\n\n/**\n * Function returning an iterator over edges from the given object.\n *\n * @param  {object}   object - Target object.\n * @return {Iterator}\n */\nfunction createIterator(object, avoid) {\n  const keys = Object.keys(object);\n  const l = keys.length;\n\n  let edgeData;\n  let i = 0;\n\n  return new Iterator(function next() {\n    do {\n      if (!edgeData) {\n        if (i >= l) return {done: true};\n\n        const k = keys[i++];\n\n        if (k === avoid) {\n          edgeData = undefined;\n          continue;\n        }\n\n        edgeData = object[k];\n      } else {\n        edgeData = edgeData.next;\n      }\n    } while (!edgeData);\n\n    return {\n      done: false,\n      value: {\n        edge: edgeData.key,\n        attributes: edgeData.attributes,\n        source: edgeData.source.key,\n        target: edgeData.target.key,\n        sourceAttributes: edgeData.source.attributes,\n        targetAttributes: edgeData.target.attributes,\n        undirected: edgeData.undirected\n      }\n    };\n  });\n}\n\n/**\n * Function iterating over the egdes from the object at given key to match\n * one of them.\n *\n * @param {object}   object   - Target object.\n * @param {mixed}    k        - Neighbor key.\n * @param {function} callback - Callback to use.\n */\nfunction forEachForKeySimple(breakable, object, k, callback) {\n  const edgeData = object[k];\n\n  if (!edgeData) return;\n\n  const sourceData = edgeData.source;\n  const targetData = edgeData.target;\n\n  if (\n    callback(\n      edgeData.key,\n      edgeData.attributes,\n      sourceData.key,\n      targetData.key,\n      sourceData.attributes,\n      targetData.attributes,\n      edgeData.undirected\n    ) &&\n    breakable\n  )\n    return edgeData.key;\n}\n\nfunction forEachForKeyMulti(breakable, object, k, callback) {\n  let edgeData = object[k];\n\n  if (!edgeData) return;\n\n  let shouldBreak = false;\n\n  do {\n    shouldBreak = callback(\n      edgeData.key,\n      edgeData.attributes,\n      edgeData.source.key,\n      edgeData.target.key,\n      edgeData.source.attributes,\n      edgeData.target.attributes,\n      edgeData.undirected\n    );\n\n    if (breakable && shouldBreak) return edgeData.key;\n\n    edgeData = edgeData.next;\n  } while (edgeData !== undefined);\n\n  return;\n}\n\n/**\n * Function returning an iterator over the egdes from the object at given key.\n *\n * @param  {object}   object   - Target object.\n * @param  {mixed}    k        - Neighbor key.\n * @return {Iterator}\n */\nfunction createIteratorForKey(object, k) {\n  let edgeData = object[k];\n\n  if (edgeData.next !== undefined) {\n    return new Iterator(function () {\n      if (!edgeData) return {done: true};\n\n      const value = {\n        edge: edgeData.key,\n        attributes: edgeData.attributes,\n        source: edgeData.source.key,\n        target: edgeData.target.key,\n        sourceAttributes: edgeData.source.attributes,\n        targetAttributes: edgeData.target.attributes,\n        undirected: edgeData.undirected\n      };\n\n      edgeData = edgeData.next;\n\n      return {\n        done: false,\n        value\n      };\n    });\n  }\n\n  return Iterator.of({\n    edge: edgeData.key,\n    attributes: edgeData.attributes,\n    source: edgeData.source.key,\n    target: edgeData.target.key,\n    sourceAttributes: edgeData.source.attributes,\n    targetAttributes: edgeData.target.attributes,\n    undirected: edgeData.undirected\n  });\n}\n\n/**\n * Function creating an array of edges for the given type.\n *\n * @param  {Graph}   graph - Target Graph instance.\n * @param  {string}  type  - Type of edges to retrieve.\n * @return {array}         - Array of edges.\n */\nfunction createEdgeArray(graph, type) {\n  if (graph.size === 0) return [];\n\n  if (type === 'mixed' || type === graph.type) {\n    if (typeof Array.from === 'function')\n      return Array.from(graph._edges.keys());\n\n    return take(graph._edges.keys(), graph._edges.size);\n  }\n\n  const size =\n    type === 'undirected' ? graph.undirectedSize : graph.directedSize;\n\n  const list = new Array(size),\n    mask = type === 'undirected';\n\n  const iterator = graph._edges.values();\n\n  let i = 0;\n  let step, data;\n\n  while (((step = iterator.next()), step.done !== true)) {\n    data = step.value;\n\n    if (data.undirected === mask) list[i++] = data.key;\n  }\n\n  return list;\n}\n\n/**\n * Function iterating over a graph's edges using a callback to match one of\n * them.\n *\n * @param  {Graph}    graph    - Target Graph instance.\n * @param  {string}   type     - Type of edges to retrieve.\n * @param  {function} callback - Function to call.\n */\nfunction forEachEdge(breakable, graph, type, callback) {\n  if (graph.size === 0) return;\n\n  const shouldFilter = type !== 'mixed' && type !== graph.type;\n  const mask = type === 'undirected';\n\n  let step, data;\n  let shouldBreak = false;\n  const iterator = graph._edges.values();\n\n  while (((step = iterator.next()), step.done !== true)) {\n    data = step.value;\n\n    if (shouldFilter && data.undirected !== mask) continue;\n\n    const {key, attributes, source, target} = data;\n\n    shouldBreak = callback(\n      key,\n      attributes,\n      source.key,\n      target.key,\n      source.attributes,\n      target.attributes,\n      data.undirected\n    );\n\n    if (breakable && shouldBreak) return key;\n  }\n\n  return;\n}\n\n/**\n * Function creating an iterator of edges for the given type.\n *\n * @param  {Graph}    graph - Target Graph instance.\n * @param  {string}   type  - Type of edges to retrieve.\n * @return {Iterator}\n */\nfunction createEdgeIterator(graph, type) {\n  if (graph.size === 0) return Iterator.empty();\n\n  const shouldFilter = type !== 'mixed' && type !== graph.type;\n  const mask = type === 'undirected';\n\n  const iterator = graph._edges.values();\n\n  return new Iterator(function next() {\n    let step, data;\n\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      step = iterator.next();\n\n      if (step.done) return step;\n\n      data = step.value;\n\n      if (shouldFilter && data.undirected !== mask) continue;\n\n      break;\n    }\n\n    const value = {\n      edge: data.key,\n      attributes: data.attributes,\n      source: data.source.key,\n      target: data.target.key,\n      sourceAttributes: data.source.attributes,\n      targetAttributes: data.target.attributes,\n      undirected: data.undirected\n    };\n\n    return {value, done: false};\n  });\n}\n\n/**\n * Function iterating over a node's edges using a callback to match one of them.\n *\n * @param  {boolean}  multi     - Whether the graph is multi or not.\n * @param  {string}   type      - Type of edges to retrieve.\n * @param  {string}   direction - In or out?\n * @param  {any}      nodeData  - Target node's data.\n * @param  {function} callback  - Function to call.\n */\nfunction forEachEdgeForNode(\n  breakable,\n  multi,\n  type,\n  direction,\n  nodeData,\n  callback\n) {\n  const fn = multi ? forEachMulti : forEachSimple;\n\n  let found;\n\n  if (type !== 'undirected') {\n    if (direction !== 'out') {\n      found = fn(breakable, nodeData.in, callback);\n\n      if (breakable && found) return found;\n    }\n    if (direction !== 'in') {\n      found = fn(\n        breakable,\n        nodeData.out,\n        callback,\n        !direction ? nodeData.key : undefined\n      );\n\n      if (breakable && found) return found;\n    }\n  }\n\n  if (type !== 'directed') {\n    found = fn(breakable, nodeData.undirected, callback);\n\n    if (breakable && found) return found;\n  }\n\n  return;\n}\n\n/**\n * Function creating an array of edges for the given type & the given node.\n *\n * @param  {boolean} multi     - Whether the graph is multi or not.\n * @param  {string}  type      - Type of edges to retrieve.\n * @param  {string}  direction - In or out?\n * @param  {any}     nodeData  - Target node's data.\n * @return {array}             - Array of edges.\n */\nfunction createEdgeArrayForNode(multi, type, direction, nodeData) {\n  const edges = []; // TODO: possibility to know size beforehand or factorize with map\n\n  forEachEdgeForNode(false, multi, type, direction, nodeData, function (key) {\n    edges.push(key);\n  });\n\n  return edges;\n}\n\n/**\n * Function iterating over a node's edges using a callback.\n *\n * @param  {string}   type      - Type of edges to retrieve.\n * @param  {string}   direction - In or out?\n * @param  {any}      nodeData  - Target node's data.\n * @return {Iterator}\n */\nfunction createEdgeIteratorForNode(type, direction, nodeData) {\n  let iterator = Iterator.empty();\n\n  if (type !== 'undirected') {\n    if (direction !== 'out' && typeof nodeData.in !== 'undefined')\n      iterator = chain(iterator, createIterator(nodeData.in));\n    if (direction !== 'in' && typeof nodeData.out !== 'undefined')\n      iterator = chain(\n        iterator,\n        createIterator(nodeData.out, !direction ? nodeData.key : undefined)\n      );\n  }\n\n  if (type !== 'directed' && typeof nodeData.undirected !== 'undefined') {\n    iterator = chain(iterator, createIterator(nodeData.undirected));\n  }\n\n  return iterator;\n}\n\n/**\n * Function iterating over edges for the given path using a callback to match\n * one of them.\n *\n * @param  {string}   type       - Type of edges to retrieve.\n * @param  {boolean}  multi      - Whether the graph is multi.\n * @param  {string}   direction  - In or out?\n * @param  {NodeData} sourceData - Source node's data.\n * @param  {string}   target     - Target node.\n * @param  {function} callback   - Function to call.\n */\nfunction forEachEdgeForPath(\n  breakable,\n  type,\n  multi,\n  direction,\n  sourceData,\n  target,\n  callback\n) {\n  const fn = multi ? forEachForKeyMulti : forEachForKeySimple;\n\n  let found;\n\n  if (type !== 'undirected') {\n    if (typeof sourceData.in !== 'undefined' && direction !== 'out') {\n      found = fn(breakable, sourceData.in, target, callback);\n\n      if (breakable && found) return found;\n    }\n\n    if (\n      typeof sourceData.out !== 'undefined' &&\n      direction !== 'in' &&\n      (direction || sourceData.key !== target)\n    ) {\n      found = fn(breakable, sourceData.out, target, callback);\n\n      if (breakable && found) return found;\n    }\n  }\n\n  if (type !== 'directed') {\n    if (typeof sourceData.undirected !== 'undefined') {\n      found = fn(breakable, sourceData.undirected, target, callback);\n\n      if (breakable && found) return found;\n    }\n  }\n\n  return;\n}\n\n/**\n * Function creating an array of edges for the given path.\n *\n * @param  {string}   type       - Type of edges to retrieve.\n * @param  {boolean}  multi      - Whether the graph is multi.\n * @param  {string}   direction  - In or out?\n * @param  {NodeData} sourceData - Source node's data.\n * @param  {any}      target     - Target node.\n * @return {array}               - Array of edges.\n */\nfunction createEdgeArrayForPath(type, multi, direction, sourceData, target) {\n  const edges = []; // TODO: possibility to know size beforehand or factorize with map\n\n  forEachEdgeForPath(\n    false,\n    type,\n    multi,\n    direction,\n    sourceData,\n    target,\n    function (key) {\n      edges.push(key);\n    }\n  );\n\n  return edges;\n}\n\n/**\n * Function returning an iterator over edges for the given path.\n *\n * @param  {string}   type       - Type of edges to retrieve.\n * @param  {string}   direction  - In or out?\n * @param  {NodeData} sourceData - Source node's data.\n * @param  {string}   target     - Target node.\n * @param  {function} callback   - Function to call.\n */\nfunction createEdgeIteratorForPath(type, direction, sourceData, target) {\n  let iterator = Iterator.empty();\n\n  if (type !== 'undirected') {\n    if (\n      typeof sourceData.in !== 'undefined' &&\n      direction !== 'out' &&\n      target in sourceData.in\n    )\n      iterator = chain(iterator, createIteratorForKey(sourceData.in, target));\n\n    if (\n      typeof sourceData.out !== 'undefined' &&\n      direction !== 'in' &&\n      target in sourceData.out &&\n      (direction || sourceData.key !== target)\n    )\n      iterator = chain(iterator, createIteratorForKey(sourceData.out, target));\n  }\n\n  if (type !== 'directed') {\n    if (\n      typeof sourceData.undirected !== 'undefined' &&\n      target in sourceData.undirected\n    )\n      iterator = chain(\n        iterator,\n        createIteratorForKey(sourceData.undirected, target)\n      );\n  }\n\n  return iterator;\n}\n\n/**\n * Function attaching an edge array creator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachEdgeArrayCreator(Class, description) {\n  const {name, type, direction} = description;\n\n  /**\n   * Function returning an array of certain edges.\n   *\n   * Arity 0: Return all the relevant edges.\n   *\n   * Arity 1: Return all of a node's relevant edges.\n   * @param  {any}   node   - Target node.\n   *\n   * Arity 2: Return the relevant edges across the given path.\n   * @param  {any}   source - Source node.\n   * @param  {any}   target - Target node.\n   *\n   * @return {array|number} - The edges or the number of edges.\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[name] = function (source, target) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return [];\n\n    if (!arguments.length) return createEdgeArray(this, type);\n\n    if (arguments.length === 1) {\n      source = '' + source;\n\n      const nodeData = this._nodes.get(source);\n\n      if (typeof nodeData === 'undefined')\n        throw new NotFoundGraphError(\n          `Graph.${name}: could not find the \"${source}\" node in the graph.`\n        );\n\n      // Iterating over a node's edges\n      return createEdgeArrayForNode(\n        this.multi,\n        type === 'mixed' ? this.type : type,\n        direction,\n        nodeData\n      );\n    }\n\n    if (arguments.length === 2) {\n      source = '' + source;\n      target = '' + target;\n\n      const sourceData = this._nodes.get(source);\n\n      if (!sourceData)\n        throw new NotFoundGraphError(\n          `Graph.${name}:  could not find the \"${source}\" source node in the graph.`\n        );\n\n      if (!this._nodes.has(target))\n        throw new NotFoundGraphError(\n          `Graph.${name}:  could not find the \"${target}\" target node in the graph.`\n        );\n\n      // Iterating over the edges between source & target\n      return createEdgeArrayForPath(\n        type,\n        this.multi,\n        direction,\n        sourceData,\n        target\n      );\n    }\n\n    throw new InvalidArgumentsGraphError(\n      `Graph.${name}: too many arguments (expecting 0, 1 or 2 and got ${arguments.length}).`\n    );\n  };\n}\n\n/**\n * Function attaching a edge callback iterator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachForEachEdge(Class, description) {\n  const {name, type, direction} = description;\n\n  const forEachName = 'forEach' + name[0].toUpperCase() + name.slice(1, -1);\n\n  /**\n   * Function iterating over the graph's relevant edges by applying the given\n   * callback.\n   *\n   * Arity 1: Iterate over all the relevant edges.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 2: Iterate over all of a node's relevant edges.\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 3: Iterate over the relevant edges across the given path.\n   * @param  {any}      source   - Source node.\n   * @param  {any}      target   - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[forEachName] = function (source, target, callback) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type) return;\n\n    if (arguments.length === 1) {\n      callback = source;\n      return forEachEdge(false, this, type, callback);\n    }\n\n    if (arguments.length === 2) {\n      source = '' + source;\n      callback = target;\n\n      const nodeData = this._nodes.get(source);\n\n      if (typeof nodeData === 'undefined')\n        throw new NotFoundGraphError(\n          `Graph.${forEachName}: could not find the \"${source}\" node in the graph.`\n        );\n\n      // Iterating over a node's edges\n      // TODO: maybe attach the sub method to the instance dynamically?\n      return forEachEdgeForNode(\n        false,\n        this.multi,\n        type === 'mixed' ? this.type : type,\n        direction,\n        nodeData,\n        callback\n      );\n    }\n\n    if (arguments.length === 3) {\n      source = '' + source;\n      target = '' + target;\n\n      const sourceData = this._nodes.get(source);\n\n      if (!sourceData)\n        throw new NotFoundGraphError(\n          `Graph.${forEachName}:  could not find the \"${source}\" source node in the graph.`\n        );\n\n      if (!this._nodes.has(target))\n        throw new NotFoundGraphError(\n          `Graph.${forEachName}:  could not find the \"${target}\" target node in the graph.`\n        );\n\n      // Iterating over the edges between source & target\n      return forEachEdgeForPath(\n        false,\n        type,\n        this.multi,\n        direction,\n        sourceData,\n        target,\n        callback\n      );\n    }\n\n    throw new InvalidArgumentsGraphError(\n      `Graph.${forEachName}: too many arguments (expecting 1, 2 or 3 and got ${arguments.length}).`\n    );\n  };\n\n  /**\n   * Function mapping the graph's relevant edges by applying the given\n   * callback.\n   *\n   * Arity 1: Map all the relevant edges.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 2: Map all of a node's relevant edges.\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 3: Map the relevant edges across the given path.\n   * @param  {any}      source   - Source node.\n   * @param  {any}      target   - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const mapName = 'map' + name[0].toUpperCase() + name.slice(1);\n\n  Class.prototype[mapName] = function () {\n    const args = Array.prototype.slice.call(arguments);\n    const callback = args.pop();\n\n    let result;\n\n    // We know the result length beforehand\n    if (args.length === 0) {\n      let length = 0;\n\n      if (type !== 'directed') length += this.undirectedSize;\n      if (type !== 'undirected') length += this.directedSize;\n\n      result = new Array(length);\n\n      let i = 0;\n\n      args.push((e, ea, s, t, sa, ta, u) => {\n        result[i++] = callback(e, ea, s, t, sa, ta, u);\n      });\n    }\n\n    // We don't know the result length beforehand\n    // TODO: we can in some instances of simple graphs, knowing degree\n    else {\n      result = [];\n\n      args.push((e, ea, s, t, sa, ta, u) => {\n        result.push(callback(e, ea, s, t, sa, ta, u));\n      });\n    }\n\n    this[forEachName].apply(this, args);\n\n    return result;\n  };\n\n  /**\n   * Function filtering the graph's relevant edges using the provided predicate\n   * function.\n   *\n   * Arity 1: Filter all the relevant edges.\n   * @param  {function} predicate - Predicate to use.\n   *\n   * Arity 2: Filter all of a node's relevant edges.\n   * @param  {any}      node      - Target node.\n   * @param  {function} predicate - Predicate to use.\n   *\n   * Arity 3: Filter the relevant edges across the given path.\n   * @param  {any}      source    - Source node.\n   * @param  {any}      target    - Target node.\n   * @param  {function} predicate - Predicate to use.\n   *\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const filterName = 'filter' + name[0].toUpperCase() + name.slice(1);\n\n  Class.prototype[filterName] = function () {\n    const args = Array.prototype.slice.call(arguments);\n    const callback = args.pop();\n\n    const result = [];\n\n    args.push((e, ea, s, t, sa, ta, u) => {\n      if (callback(e, ea, s, t, sa, ta, u)) result.push(e);\n    });\n\n    this[forEachName].apply(this, args);\n\n    return result;\n  };\n\n  /**\n   * Function reducing the graph's relevant edges using the provided accumulator\n   * function.\n   *\n   * Arity 1: Reduce all the relevant edges.\n   * @param  {function} accumulator  - Accumulator to use.\n   * @param  {any}      initialValue - Initial value.\n   *\n   * Arity 2: Reduce all of a node's relevant edges.\n   * @param  {any}      node         - Target node.\n   * @param  {function} accumulator  - Accumulator to use.\n   * @param  {any}      initialValue - Initial value.\n   *\n   * Arity 3: Reduce the relevant edges across the given path.\n   * @param  {any}      source       - Source node.\n   * @param  {any}      target       - Target node.\n   * @param  {function} accumulator  - Accumulator to use.\n   * @param  {any}      initialValue - Initial value.\n   *\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const reduceName = 'reduce' + name[0].toUpperCase() + name.slice(1);\n\n  Class.prototype[reduceName] = function () {\n    let args = Array.prototype.slice.call(arguments);\n\n    if (args.length < 2 || args.length > 4) {\n      throw new InvalidArgumentsGraphError(\n        `Graph.${reduceName}: invalid number of arguments (expecting 2, 3 or 4 and got ${args.length}).`\n      );\n    }\n\n    if (\n      typeof args[args.length - 1] === 'function' &&\n      typeof args[args.length - 2] !== 'function'\n    ) {\n      throw new InvalidArgumentsGraphError(\n        `Graph.${reduceName}: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.`\n      );\n    }\n\n    let callback;\n    let initialValue;\n\n    if (args.length === 2) {\n      callback = args[0];\n      initialValue = args[1];\n      args = [];\n    } else if (args.length === 3) {\n      callback = args[1];\n      initialValue = args[2];\n      args = [args[0]];\n    } else if (args.length === 4) {\n      callback = args[2];\n      initialValue = args[3];\n      args = [args[0], args[1]];\n    }\n\n    let accumulator = initialValue;\n\n    args.push((e, ea, s, t, sa, ta, u) => {\n      accumulator = callback(accumulator, e, ea, s, t, sa, ta, u);\n    });\n\n    this[forEachName].apply(this, args);\n\n    return accumulator;\n  };\n}\n\n/**\n * Function attaching a breakable edge callback iterator method to the Graph\n * prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachFindEdge(Class, description) {\n  const {name, type, direction} = description;\n\n  const findEdgeName = 'find' + name[0].toUpperCase() + name.slice(1, -1);\n\n  /**\n   * Function iterating over the graph's relevant edges in order to match\n   * one of them using the provided predicate function.\n   *\n   * Arity 1: Iterate over all the relevant edges.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 2: Iterate over all of a node's relevant edges.\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 3: Iterate over the relevant edges across the given path.\n   * @param  {any}      source   - Source node.\n   * @param  {any}      target   - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[findEdgeName] = function (source, target, callback) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return false;\n\n    if (arguments.length === 1) {\n      callback = source;\n      return forEachEdge(true, this, type, callback);\n    }\n\n    if (arguments.length === 2) {\n      source = '' + source;\n      callback = target;\n\n      const nodeData = this._nodes.get(source);\n\n      if (typeof nodeData === 'undefined')\n        throw new NotFoundGraphError(\n          `Graph.${findEdgeName}: could not find the \"${source}\" node in the graph.`\n        );\n\n      // Iterating over a node's edges\n      // TODO: maybe attach the sub method to the instance dynamically?\n      return forEachEdgeForNode(\n        true,\n        this.multi,\n        type === 'mixed' ? this.type : type,\n        direction,\n        nodeData,\n        callback\n      );\n    }\n\n    if (arguments.length === 3) {\n      source = '' + source;\n      target = '' + target;\n\n      const sourceData = this._nodes.get(source);\n\n      if (!sourceData)\n        throw new NotFoundGraphError(\n          `Graph.${findEdgeName}:  could not find the \"${source}\" source node in the graph.`\n        );\n\n      if (!this._nodes.has(target))\n        throw new NotFoundGraphError(\n          `Graph.${findEdgeName}:  could not find the \"${target}\" target node in the graph.`\n        );\n\n      // Iterating over the edges between source & target\n      return forEachEdgeForPath(\n        true,\n        type,\n        this.multi,\n        direction,\n        sourceData,\n        target,\n        callback\n      );\n    }\n\n    throw new InvalidArgumentsGraphError(\n      `Graph.${findEdgeName}: too many arguments (expecting 1, 2 or 3 and got ${arguments.length}).`\n    );\n  };\n\n  /**\n   * Function iterating over the graph's relevant edges in order to assert\n   * whether any one of them matches the provided predicate function.\n   *\n   * Arity 1: Iterate over all the relevant edges.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 2: Iterate over all of a node's relevant edges.\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 3: Iterate over the relevant edges across the given path.\n   * @param  {any}      source   - Source node.\n   * @param  {any}      target   - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const someName = 'some' + name[0].toUpperCase() + name.slice(1, -1);\n\n  Class.prototype[someName] = function () {\n    const args = Array.prototype.slice.call(arguments);\n    const callback = args.pop();\n\n    args.push((e, ea, s, t, sa, ta, u) => {\n      return callback(e, ea, s, t, sa, ta, u);\n    });\n\n    const found = this[findEdgeName].apply(this, args);\n\n    if (found) return true;\n\n    return false;\n  };\n\n  /**\n   * Function iterating over the graph's relevant edges in order to assert\n   * whether all of them matche the provided predicate function.\n   *\n   * Arity 1: Iterate over all the relevant edges.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 2: Iterate over all of a node's relevant edges.\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 3: Iterate over the relevant edges across the given path.\n   * @param  {any}      source   - Source node.\n   * @param  {any}      target   - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const everyName = 'every' + name[0].toUpperCase() + name.slice(1, -1);\n\n  Class.prototype[everyName] = function () {\n    const args = Array.prototype.slice.call(arguments);\n    const callback = args.pop();\n\n    args.push((e, ea, s, t, sa, ta, u) => {\n      return !callback(e, ea, s, t, sa, ta, u);\n    });\n\n    const found = this[findEdgeName].apply(this, args);\n\n    if (found) return false;\n\n    return true;\n  };\n}\n\n/**\n * Function attaching an edge iterator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachEdgeIteratorCreator(Class, description) {\n  const {name: originalName, type, direction} = description;\n\n  const name = originalName.slice(0, -1) + 'Entries';\n\n  /**\n   * Function returning an iterator over the graph's edges.\n   *\n   * Arity 0: Iterate over all the relevant edges.\n   *\n   * Arity 1: Iterate over all of a node's relevant edges.\n   * @param  {any}   node   - Target node.\n   *\n   * Arity 2: Iterate over the relevant edges across the given path.\n   * @param  {any}   source - Source node.\n   * @param  {any}   target - Target node.\n   *\n   * @return {array|number} - The edges or the number of edges.\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[name] = function (source, target) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return Iterator.empty();\n\n    if (!arguments.length) return createEdgeIterator(this, type);\n\n    if (arguments.length === 1) {\n      source = '' + source;\n\n      const sourceData = this._nodes.get(source);\n\n      if (!sourceData)\n        throw new NotFoundGraphError(\n          `Graph.${name}: could not find the \"${source}\" node in the graph.`\n        );\n\n      // Iterating over a node's edges\n      return createEdgeIteratorForNode(type, direction, sourceData);\n    }\n\n    if (arguments.length === 2) {\n      source = '' + source;\n      target = '' + target;\n\n      const sourceData = this._nodes.get(source);\n\n      if (!sourceData)\n        throw new NotFoundGraphError(\n          `Graph.${name}:  could not find the \"${source}\" source node in the graph.`\n        );\n\n      if (!this._nodes.has(target))\n        throw new NotFoundGraphError(\n          `Graph.${name}:  could not find the \"${target}\" target node in the graph.`\n        );\n\n      // Iterating over the edges between source & target\n      return createEdgeIteratorForPath(type, direction, sourceData, target);\n    }\n\n    throw new InvalidArgumentsGraphError(\n      `Graph.${name}: too many arguments (expecting 0, 1 or 2 and got ${arguments.length}).`\n    );\n  };\n}\n\n/**\n * Function attaching every edge iteration method to the Graph class.\n *\n * @param {function} Graph - Graph class.\n */\nexport default function attachEdgeIterationMethods(Graph) {\n  EDGES_ITERATION.forEach(description => {\n    attachEdgeArrayCreator(Graph, description);\n    attachForEachEdge(Graph, description);\n    attachFindEdge(Graph, description);\n    attachEdgeIteratorCreator(Graph, description);\n  });\n}\n", "/**\n * Graphology Neighbor Iteration\n * ==============================\n *\n * Attaching some methods to the Graph class to be able to iterate over\n * neighbors.\n */\nimport Iterator from 'obliterator/iterator';\nimport chain from 'obliterator/chain';\n\nimport {NotFoundGraphError, InvalidArgumentsGraphError} from '../errors';\n\n/**\n * Definitions.\n */\nconst NEIGHBORS_ITERATION = [\n  {\n    name: 'neighbors',\n    type: 'mixed'\n  },\n  {\n    name: 'inNeighbors',\n    type: 'directed',\n    direction: 'in'\n  },\n  {\n    name: 'outNeighbors',\n    type: 'directed',\n    direction: 'out'\n  },\n  {\n    name: 'inboundNeighbors',\n    type: 'mixed',\n    direction: 'in'\n  },\n  {\n    name: 'outboundNeighbors',\n    type: 'mixed',\n    direction: 'out'\n  },\n  {\n    name: 'directedNeighbors',\n    type: 'directed'\n  },\n  {\n    name: 'undirectedNeighbors',\n    type: 'undirected'\n  }\n];\n\n/**\n * Helpers.\n */\nfunction CompositeSetWrapper() {\n  this.A = null;\n  this.B = null;\n}\n\nCompositeSetWrapper.prototype.wrap = function (set) {\n  if (this.A === null) this.A = set;\n  else if (this.B === null) this.B = set;\n};\n\nCompositeSetWrapper.prototype.has = function (key) {\n  if (this.A !== null && key in this.A) return true;\n  if (this.B !== null && key in this.B) return true;\n  return false;\n};\n\n/**\n * Function iterating over the given node's relevant neighbors to match\n * one of them using a predicated function.\n *\n * @param  {string}   type      - Type of neighbors.\n * @param  {string}   direction - Direction.\n * @param  {any}      nodeData  - Target node's data.\n * @param  {function} callback  - Callback to use.\n */\nfunction forEachInObjectOnce(breakable, visited, nodeData, object, callback) {\n  for (const k in object) {\n    const edgeData = object[k];\n\n    const sourceData = edgeData.source;\n    const targetData = edgeData.target;\n\n    const neighborData = sourceData === nodeData ? targetData : sourceData;\n\n    if (visited && visited.has(neighborData.key)) continue;\n\n    const shouldBreak = callback(neighborData.key, neighborData.attributes);\n\n    if (breakable && shouldBreak) return neighborData.key;\n  }\n\n  return;\n}\n\nfunction forEachNeighbor(breakable, type, direction, nodeData, callback) {\n  // If we want only undirected or in or out, we can roll some optimizations\n  if (type !== 'mixed') {\n    if (type === 'undirected')\n      return forEachInObjectOnce(\n        breakable,\n        null,\n        nodeData,\n        nodeData.undirected,\n        callback\n      );\n\n    if (typeof direction === 'string')\n      return forEachInObjectOnce(\n        breakable,\n        null,\n        nodeData,\n        nodeData[direction],\n        callback\n      );\n  }\n\n  // Else we need to keep a set of neighbors not to return duplicates\n  // We cheat by querying the other adjacencies\n  const visited = new CompositeSetWrapper();\n\n  let found;\n\n  if (type !== 'undirected') {\n    if (direction !== 'out') {\n      found = forEachInObjectOnce(\n        breakable,\n        null,\n        nodeData,\n        nodeData.in,\n        callback\n      );\n\n      if (breakable && found) return found;\n\n      visited.wrap(nodeData.in);\n    }\n    if (direction !== 'in') {\n      found = forEachInObjectOnce(\n        breakable,\n        visited,\n        nodeData,\n        nodeData.out,\n        callback\n      );\n\n      if (breakable && found) return found;\n\n      visited.wrap(nodeData.out);\n    }\n  }\n\n  if (type !== 'directed') {\n    found = forEachInObjectOnce(\n      breakable,\n      visited,\n      nodeData,\n      nodeData.undirected,\n      callback\n    );\n\n    if (breakable && found) return found;\n  }\n\n  return;\n}\n\n/**\n * Function creating an array of relevant neighbors for the given node.\n *\n * @param  {string}       type      - Type of neighbors.\n * @param  {string}       direction - Direction.\n * @param  {any}          nodeData  - Target node's data.\n * @return {Array}                  - The list of neighbors.\n */\nfunction createNeighborArrayForNode(type, direction, nodeData) {\n  // If we want only undirected or in or out, we can roll some optimizations\n  if (type !== 'mixed') {\n    if (type === 'undirected') return Object.keys(nodeData.undirected);\n\n    if (typeof direction === 'string') return Object.keys(nodeData[direction]);\n  }\n\n  const neighbors = [];\n\n  forEachNeighbor(false, type, direction, nodeData, function (key) {\n    neighbors.push(key);\n  });\n\n  return neighbors;\n}\n\n/**\n * Function returning an iterator over the given node's relevant neighbors.\n *\n * @param  {string}   type      - Type of neighbors.\n * @param  {string}   direction - Direction.\n * @param  {any}      nodeData  - Target node's data.\n * @return {Iterator}\n */\nfunction createDedupedObjectIterator(visited, nodeData, object) {\n  const keys = Object.keys(object);\n  const l = keys.length;\n\n  let i = 0;\n\n  return new Iterator(function next() {\n    let neighborData = null;\n\n    do {\n      if (i >= l) {\n        if (visited) visited.wrap(object);\n        return {done: true};\n      }\n\n      const edgeData = object[keys[i++]];\n\n      const sourceData = edgeData.source;\n      const targetData = edgeData.target;\n\n      neighborData = sourceData === nodeData ? targetData : sourceData;\n\n      if (visited && visited.has(neighborData.key)) {\n        neighborData = null;\n        continue;\n      }\n    } while (neighborData === null);\n\n    return {\n      done: false,\n      value: {neighbor: neighborData.key, attributes: neighborData.attributes}\n    };\n  });\n}\n\nfunction createNeighborIterator(type, direction, nodeData) {\n  // If we want only undirected or in or out, we can roll some optimizations\n  if (type !== 'mixed') {\n    if (type === 'undirected')\n      return createDedupedObjectIterator(null, nodeData, nodeData.undirected);\n\n    if (typeof direction === 'string')\n      return createDedupedObjectIterator(null, nodeData, nodeData[direction]);\n  }\n\n  let iterator = Iterator.empty();\n\n  // Else we need to keep a set of neighbors not to return duplicates\n  // We cheat by querying the other adjacencies\n  const visited = new CompositeSetWrapper();\n\n  if (type !== 'undirected') {\n    if (direction !== 'out') {\n      iterator = chain(\n        iterator,\n        createDedupedObjectIterator(visited, nodeData, nodeData.in)\n      );\n    }\n    if (direction !== 'in') {\n      iterator = chain(\n        iterator,\n        createDedupedObjectIterator(visited, nodeData, nodeData.out)\n      );\n    }\n  }\n\n  if (type !== 'directed') {\n    iterator = chain(\n      iterator,\n      createDedupedObjectIterator(visited, nodeData, nodeData.undirected)\n    );\n  }\n\n  return iterator;\n}\n\n/**\n * Function attaching a neighbors array creator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachNeighborArrayCreator(Class, description) {\n  const {name, type, direction} = description;\n\n  /**\n   * Function returning an array of certain neighbors.\n   *\n   * @param  {any}   node   - Target node.\n   * @return {array} - The neighbors of neighbors.\n   *\n   * @throws {Error} - Will throw if node is not found in the graph.\n   */\n  Class.prototype[name] = function (node) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return [];\n\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (typeof nodeData === 'undefined')\n      throw new NotFoundGraphError(\n        `Graph.${name}: could not find the \"${node}\" node in the graph.`\n      );\n\n    // Here, we want to iterate over a node's relevant neighbors\n    return createNeighborArrayForNode(\n      type === 'mixed' ? this.type : type,\n      direction,\n      nodeData\n    );\n  };\n}\n\n/**\n * Function attaching a neighbors callback iterator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachForEachNeighbor(Class, description) {\n  const {name, type, direction} = description;\n\n  const forEachName = 'forEach' + name[0].toUpperCase() + name.slice(1, -1);\n\n  /**\n   * Function iterating over all the relevant neighbors using a callback.\n   *\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[forEachName] = function (node, callback) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type) return;\n\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (typeof nodeData === 'undefined')\n      throw new NotFoundGraphError(\n        `Graph.${forEachName}: could not find the \"${node}\" node in the graph.`\n      );\n\n    // Here, we want to iterate over a node's relevant neighbors\n    forEachNeighbor(\n      false,\n      type === 'mixed' ? this.type : type,\n      direction,\n      nodeData,\n      callback\n    );\n  };\n\n  /**\n   * Function mapping the relevant neighbors using a callback.\n   *\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const mapName = 'map' + name[0].toUpperCase() + name.slice(1);\n\n  Class.prototype[mapName] = function (node, callback) {\n    // TODO: optimize when size is known beforehand\n    const result = [];\n\n    this[forEachName](node, (n, a) => {\n      result.push(callback(n, a));\n    });\n\n    return result;\n  };\n\n  /**\n   * Function filtering the relevant neighbors using a callback.\n   *\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const filterName = 'filter' + name[0].toUpperCase() + name.slice(1);\n\n  Class.prototype[filterName] = function (node, callback) {\n    const result = [];\n\n    this[forEachName](node, (n, a) => {\n      if (callback(n, a)) result.push(n);\n    });\n\n    return result;\n  };\n\n  /**\n   * Function reducing the relevant neighbors using a callback.\n   *\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const reduceName = 'reduce' + name[0].toUpperCase() + name.slice(1);\n\n  Class.prototype[reduceName] = function (node, callback, initialValue) {\n    if (arguments.length < 3)\n      throw new InvalidArgumentsGraphError(\n        `Graph.${reduceName}: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.`\n      );\n\n    let accumulator = initialValue;\n\n    this[forEachName](node, (n, a) => {\n      accumulator = callback(accumulator, n, a);\n    });\n\n    return accumulator;\n  };\n}\n\n/**\n * Function attaching a breakable neighbors callback iterator method to the\n * Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachFindNeighbor(Class, description) {\n  const {name, type, direction} = description;\n\n  const capitalizedSingular = name[0].toUpperCase() + name.slice(1, -1);\n\n  const findName = 'find' + capitalizedSingular;\n\n  /**\n   * Function iterating over all the relevant neighbors using a callback.\n   *\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[findName] = function (node, callback) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type) return;\n\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (typeof nodeData === 'undefined')\n      throw new NotFoundGraphError(\n        `Graph.${findName}: could not find the \"${node}\" node in the graph.`\n      );\n\n    // Here, we want to iterate over a node's relevant neighbors\n    return forEachNeighbor(\n      true,\n      type === 'mixed' ? this.type : type,\n      direction,\n      nodeData,\n      callback\n    );\n  };\n\n  /**\n   * Function iterating over all the relevant neighbors to find if any of them\n   * matches the given predicate.\n   *\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const someName = 'some' + capitalizedSingular;\n\n  Class.prototype[someName] = function (node, callback) {\n    const found = this[findName](node, callback);\n\n    if (found) return true;\n\n    return false;\n  };\n\n  /**\n   * Function iterating over all the relevant neighbors to find if all of them\n   * matche the given predicate.\n   *\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const everyName = 'every' + capitalizedSingular;\n\n  Class.prototype[everyName] = function (node, callback) {\n    const found = this[findName](node, (n, a) => {\n      return !callback(n, a);\n    });\n\n    if (found) return false;\n\n    return true;\n  };\n}\n\n/**\n * Function attaching a neighbors callback iterator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachNeighborIteratorCreator(Class, description) {\n  const {name, type, direction} = description;\n\n  const iteratorName = name.slice(0, -1) + 'Entries';\n\n  /**\n   * Function returning an iterator over all the relevant neighbors.\n   *\n   * @param  {any}      node     - Target node.\n   * @return {Iterator}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[iteratorName] = function (node) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return Iterator.empty();\n\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (typeof nodeData === 'undefined')\n      throw new NotFoundGraphError(\n        `Graph.${iteratorName}: could not find the \"${node}\" node in the graph.`\n      );\n\n    // Here, we want to iterate over a node's relevant neighbors\n    return createNeighborIterator(\n      type === 'mixed' ? this.type : type,\n      direction,\n      nodeData\n    );\n  };\n}\n\n/**\n * Function attaching every neighbor iteration method to the Graph class.\n *\n * @param {function} Graph - Graph class.\n */\nexport default function attachNeighborIterationMethods(Graph) {\n  NEIGHBORS_ITERATION.forEach(description => {\n    attachNeighborArrayCreator(Graph, description);\n    attachForEachNeighbor(Graph, description);\n    attachFindNeighbor(Graph, description);\n    attachNeighborIteratorCreator(Graph, description);\n  });\n}\n", "/**\n * Graphology Adjacency Iteration\n * ===============================\n *\n * Attaching some methods to the Graph class to be able to iterate over a\n * graph's adjacency.\n */\n\n/**\n * Function iterating over a simple graph's adjacency using a callback.\n *\n * @param {boolean}  breakable         - Can we break?\n * @param {boolean}  assymetric        - Whether to emit undirected edges only once.\n * @param {boolean}  disconnectedNodes - Whether to emit disconnected nodes.\n * @param {Graph}    graph             - Target Graph instance.\n * @param {callback} function          - Iteration callback.\n */\nexport function forEachAdjacency(\n  breakable,\n  assymetric,\n  disconnectedNodes,\n  graph,\n  callback\n) {\n  const iterator = graph._nodes.values();\n\n  const type = graph.type;\n\n  let step, sourceData, neighbor, adj, edgeData, targetData, shouldBreak;\n\n  while (((step = iterator.next()), step.done !== true)) {\n    let hasEdges = false;\n\n    sourceData = step.value;\n\n    if (type !== 'undirected') {\n      adj = sourceData.out;\n\n      for (neighbor in adj) {\n        edgeData = adj[neighbor];\n\n        do {\n          targetData = edgeData.target;\n\n          hasEdges = true;\n          shouldBreak = callback(\n            sourceData.key,\n            targetData.key,\n            sourceData.attributes,\n            targetData.attributes,\n            edgeData.key,\n            edgeData.attributes,\n            edgeData.undirected\n          );\n\n          if (breakable && shouldBreak) return edgeData;\n\n          edgeData = edgeData.next;\n        } while (edgeData);\n      }\n    }\n\n    if (type !== 'directed') {\n      adj = sourceData.undirected;\n\n      for (neighbor in adj) {\n        if (assymetric && sourceData.key > neighbor) continue;\n\n        edgeData = adj[neighbor];\n\n        do {\n          targetData = edgeData.target;\n\n          if (targetData.key !== neighbor) targetData = edgeData.source;\n\n          hasEdges = true;\n          shouldBreak = callback(\n            sourceData.key,\n            targetData.key,\n            sourceData.attributes,\n            targetData.attributes,\n            edgeData.key,\n            edgeData.attributes,\n            edgeData.undirected\n          );\n\n          if (breakable && shouldBreak) return edgeData;\n\n          edgeData = edgeData.next;\n        } while (edgeData);\n      }\n    }\n\n    if (disconnectedNodes && !hasEdges) {\n      shouldBreak = callback(\n        sourceData.key,\n        null,\n        sourceData.attributes,\n        null,\n        null,\n        null,\n        null\n      );\n\n      if (breakable && shouldBreak) return null;\n    }\n  }\n\n  return;\n}\n", "/**\n * Graphology Serialization Utilities\n * ===================================\n *\n * Collection of functions used by the graph serialization schemes.\n */\nimport {InvalidArgumentsGraphError} from './errors';\nimport {assign, isPlainObject, isEmpty} from './utils';\n\n/**\n * Formats internal node data into a serialized node.\n *\n * @param  {any}    key  - The node's key.\n * @param  {object} data - Internal node's data.\n * @return {array}       - The serialized node.\n */\nexport function serializeNode(key, data) {\n  const serialized = {key};\n\n  if (!isEmpty(data.attributes))\n    serialized.attributes = assign({}, data.attributes);\n\n  return serialized;\n}\n\n/**\n * Formats internal edge data into a serialized edge.\n *\n * @param  {string} type - The graph's type.\n * @param  {any}    key  - The edge's key.\n * @param  {object} data - Internal edge's data.\n * @return {array}       - The serialized edge.\n */\nexport function serializeEdge(type, key, data) {\n  const serialized = {\n    key,\n    source: data.source.key,\n    target: data.target.key\n  };\n\n  if (!isEmpty(data.attributes))\n    serialized.attributes = assign({}, data.attributes);\n\n  if (type === 'mixed' && data.undirected) serialized.undirected = true;\n\n  return serialized;\n}\n\n/**\n * Checks whether the given value is a serialized node.\n *\n * @param  {mixed} value - Target value.\n * @return {string|null}\n */\nexport function validateSerializedNode(value) {\n  if (!isPlainObject(value))\n    throw new InvalidArgumentsGraphError(\n      'Graph.import: invalid serialized node. A serialized node should be a plain object with at least a \"key\" property.'\n    );\n\n  if (!('key' in value))\n    throw new InvalidArgumentsGraphError(\n      'Graph.import: serialized node is missing its key.'\n    );\n\n  if (\n    'attributes' in value &&\n    (!isPlainObject(value.attributes) || value.attributes === null)\n  )\n    throw new InvalidArgumentsGraphError(\n      'Graph.import: invalid attributes. Attributes should be a plain object, null or omitted.'\n    );\n}\n\n/**\n * Checks whether the given value is a serialized edge.\n *\n * @param  {mixed} value - Target value.\n * @return {string|null}\n */\nexport function validateSerializedEdge(value) {\n  if (!isPlainObject(value))\n    throw new InvalidArgumentsGraphError(\n      'Graph.import: invalid serialized edge. A serialized edge should be a plain object with at least a \"source\" & \"target\" property.'\n    );\n\n  if (!('source' in value))\n    throw new InvalidArgumentsGraphError(\n      'Graph.import: serialized edge is missing its source.'\n    );\n\n  if (!('target' in value))\n    throw new InvalidArgumentsGraphError(\n      'Graph.import: serialized edge is missing its target.'\n    );\n\n  if (\n    'attributes' in value &&\n    (!isPlainObject(value.attributes) || value.attributes === null)\n  )\n    throw new InvalidArgumentsGraphError(\n      'Graph.import: invalid attributes. Attributes should be a plain object, null or omitted.'\n    );\n\n  if ('undirected' in value && typeof value.undirected !== 'boolean')\n    throw new InvalidArgumentsGraphError(\n      'Graph.import: invalid undirectedness information. Undirected should be boolean or omitted.'\n    );\n}\n", "/* eslint no-nested-ternary: 0 */\n/**\n * Graphology Reference Implementation\n * ====================================\n *\n * Reference implementation of the graphology specs.\n */\nimport {EventEmitter} from 'events';\nimport Iterator from 'obliterator/iterator';\nimport take from 'obliterator/take';\n\nimport {\n  InvalidArgumentsGraphError,\n  NotFoundGraphError,\n  UsageGraphError\n} from './errors';\n\nimport {\n  MixedNodeData,\n  DirectedNodeData,\n  UndirectedNodeData,\n  EdgeData\n} from './data';\n\nimport attachNodeAttributesMethods from './attributes/nodes';\nimport attachEdgeAttributesMethods from './attributes/edges';\nimport attachEdgeIterationMethods from './iteration/edges';\nimport attachNeighborIterationMethods from './iteration/neighbors';\nimport {forEachAdjacency} from './iteration/adjacency';\n\nimport {\n  serializeNode,\n  serializeEdge,\n  validateSerializedNode,\n  validateSerializedEdge\n} from './serialization';\n\nimport {\n  assign,\n  getMatchingEdge,\n  isPlainObject,\n  privateProperty,\n  readOnlyProperty,\n  incrementalIdStartingFromRandomByte,\n  validateHints\n} from './utils';\n\n/**\n * Constants.\n */\nconst INSTANCE_ID = incrementalIdStartingFromRandomByte();\n\n/**\n * Enums.\n */\nconst TYPES = new Set(['directed', 'undirected', 'mixed']);\n\nconst EMITTER_PROPS = new Set([\n  'domain',\n  '_events',\n  '_eventsCount',\n  '_maxListeners'\n]);\n\nconst EDGE_ADD_METHODS = [\n  {\n    name: verb => `${verb}Edge`,\n    generateKey: true\n  },\n  {\n    name: verb => `${verb}DirectedEdge`,\n    generateKey: true,\n    type: 'directed'\n  },\n  {\n    name: verb => `${verb}UndirectedEdge`,\n    generateKey: true,\n    type: 'undirected'\n  },\n  {\n    name: verb => `${verb}EdgeWithKey`\n  },\n  {\n    name: verb => `${verb}DirectedEdgeWithKey`,\n    type: 'directed'\n  },\n  {\n    name: verb => `${verb}UndirectedEdgeWithKey`,\n    type: 'undirected'\n  }\n];\n\n/**\n * Default options.\n */\nconst DEFAULTS = {\n  allowSelfLoops: true,\n  multi: false,\n  type: 'mixed'\n};\n\n/**\n * Abstract functions used by the Graph class for various methods.\n */\n\n/**\n * Internal method used to add a node to the given graph\n *\n * @param  {Graph}   graph           - Target graph.\n * @param  {any}     node            - The node's key.\n * @param  {object}  [attributes]    - Optional attributes.\n * @return {NodeData}                - Created node data.\n */\nfunction addNode(graph, node, attributes) {\n  if (attributes && !isPlainObject(attributes))\n    throw new InvalidArgumentsGraphError(\n      `Graph.addNode: invalid attributes. Expecting an object but got \"${attributes}\"`\n    );\n\n  // String coercion\n  node = '' + node;\n  attributes = attributes || {};\n\n  if (graph._nodes.has(node))\n    throw new UsageGraphError(\n      `Graph.addNode: the \"${node}\" node already exist in the graph.`\n    );\n\n  const data = new graph.NodeDataClass(node, attributes);\n\n  // Adding the node to internal register\n  graph._nodes.set(node, data);\n\n  // Emitting\n  graph.emit('nodeAdded', {\n    key: node,\n    attributes\n  });\n\n  return data;\n}\n\n/**\n * Same as the above but without sanity checks because we call this in contexts\n * where necessary checks were already done.\n */\nfunction unsafeAddNode(graph, node, attributes) {\n  const data = new graph.NodeDataClass(node, attributes);\n\n  graph._nodes.set(node, data);\n\n  graph.emit('nodeAdded', {\n    key: node,\n    attributes\n  });\n\n  return data;\n}\n\n/**\n * Internal method used to add an arbitrary edge to the given graph.\n *\n * @param  {Graph}   graph           - Target graph.\n * @param  {string}  name            - Name of the child method for errors.\n * @param  {boolean} mustGenerateKey - Should the graph generate an id?\n * @param  {boolean} undirected      - Whether the edge is undirected.\n * @param  {any}     edge            - The edge's key.\n * @param  {any}     source          - The source node.\n * @param  {any}     target          - The target node.\n * @param  {object}  [attributes]    - Optional attributes.\n * @return {any}                     - The edge.\n *\n * @throws {Error} - Will throw if the graph is of the wrong type.\n * @throws {Error} - Will throw if the given attributes are not an object.\n * @throws {Error} - Will throw if source or target doesn't exist.\n * @throws {Error} - Will throw if the edge already exist.\n */\nfunction addEdge(\n  graph,\n  name,\n  mustGenerateKey,\n  undirected,\n  edge,\n  source,\n  target,\n  attributes\n) {\n  // Checking validity of operation\n  if (!undirected && graph.type === 'undirected')\n    throw new UsageGraphError(\n      `Graph.${name}: you cannot add a directed edge to an undirected graph. Use the #.addEdge or #.addUndirectedEdge instead.`\n    );\n\n  if (undirected && graph.type === 'directed')\n    throw new UsageGraphError(\n      `Graph.${name}: you cannot add an undirected edge to a directed graph. Use the #.addEdge or #.addDirectedEdge instead.`\n    );\n\n  if (attributes && !isPlainObject(attributes))\n    throw new InvalidArgumentsGraphError(\n      `Graph.${name}: invalid attributes. Expecting an object but got \"${attributes}\"`\n    );\n\n  // Coercion of source & target:\n  source = '' + source;\n  target = '' + target;\n  attributes = attributes || {};\n\n  if (!graph.allowSelfLoops && source === target)\n    throw new UsageGraphError(\n      `Graph.${name}: source & target are the same (\"${source}\"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.`\n    );\n\n  const sourceData = graph._nodes.get(source),\n    targetData = graph._nodes.get(target);\n\n  if (!sourceData)\n    throw new NotFoundGraphError(\n      `Graph.${name}: source node \"${source}\" not found.`\n    );\n\n  if (!targetData)\n    throw new NotFoundGraphError(\n      `Graph.${name}: target node \"${target}\" not found.`\n    );\n\n  // Must the graph generate an id for this edge?\n  const eventData = {\n    key: null,\n    undirected,\n    source,\n    target,\n    attributes\n  };\n\n  if (mustGenerateKey) {\n    // NOTE: in this case we can guarantee that the key does not already\n    // exist and is already correctly casted as a string\n    edge = graph._edgeKeyGenerator();\n  } else {\n    // Coercion of edge key\n    edge = '' + edge;\n\n    // Here, we have a key collision\n    if (graph._edges.has(edge))\n      throw new UsageGraphError(\n        `Graph.${name}: the \"${edge}\" edge already exists in the graph.`\n      );\n  }\n\n  // Here, we might have a source / target collision\n  if (\n    !graph.multi &&\n    (undirected\n      ? typeof sourceData.undirected[target] !== 'undefined'\n      : typeof sourceData.out[target] !== 'undefined')\n  ) {\n    throw new UsageGraphError(\n      `Graph.${name}: an edge linking \"${source}\" to \"${target}\" already exists. If you really want to add multiple edges linking those nodes, you should create a multi graph by using the 'multi' option.`\n    );\n  }\n\n  // Storing some data\n  const edgeData = new EdgeData(\n    undirected,\n    edge,\n    sourceData,\n    targetData,\n    attributes\n  );\n\n  // Adding the edge to the internal register\n  graph._edges.set(edge, edgeData);\n\n  // Incrementing node degree counters\n  const isSelfLoop = source === target;\n\n  if (undirected) {\n    sourceData.undirectedDegree++;\n    targetData.undirectedDegree++;\n\n    if (isSelfLoop) {\n      sourceData.undirectedLoops++;\n      graph._undirectedSelfLoopCount++;\n    }\n  } else {\n    sourceData.outDegree++;\n    targetData.inDegree++;\n\n    if (isSelfLoop) {\n      sourceData.directedLoops++;\n      graph._directedSelfLoopCount++;\n    }\n  }\n\n  // Updating relevant index\n  if (graph.multi) edgeData.attachMulti();\n  else edgeData.attach();\n\n  if (undirected) graph._undirectedSize++;\n  else graph._directedSize++;\n\n  // Emitting\n  eventData.key = edge;\n\n  graph.emit('edgeAdded', eventData);\n\n  return edge;\n}\n\n/**\n * Internal method used to add an arbitrary edge to the given graph.\n *\n * @param  {Graph}   graph           - Target graph.\n * @param  {string}  name            - Name of the child method for errors.\n * @param  {boolean} mustGenerateKey - Should the graph generate an id?\n * @param  {boolean} undirected      - Whether the edge is undirected.\n * @param  {any}     edge            - The edge's key.\n * @param  {any}     source          - The source node.\n * @param  {any}     target          - The target node.\n * @param  {object}  [attributes]    - Optional attributes.\n * @param  {boolean} [asUpdater]       - Are we updating or merging?\n * @return {any}                     - The edge.\n *\n * @throws {Error} - Will throw if the graph is of the wrong type.\n * @throws {Error} - Will throw if the given attributes are not an object.\n * @throws {Error} - Will throw if source or target doesn't exist.\n * @throws {Error} - Will throw if the edge already exist.\n */\nfunction mergeEdge(\n  graph,\n  name,\n  mustGenerateKey,\n  undirected,\n  edge,\n  source,\n  target,\n  attributes,\n  asUpdater\n) {\n  // Checking validity of operation\n  if (!undirected && graph.type === 'undirected')\n    throw new UsageGraphError(\n      `Graph.${name}: you cannot merge/update a directed edge to an undirected graph. Use the #.mergeEdge/#.updateEdge or #.addUndirectedEdge instead.`\n    );\n\n  if (undirected && graph.type === 'directed')\n    throw new UsageGraphError(\n      `Graph.${name}: you cannot merge/update an undirected edge to a directed graph. Use the #.mergeEdge/#.updateEdge or #.addDirectedEdge instead.`\n    );\n\n  if (attributes) {\n    if (asUpdater) {\n      if (typeof attributes !== 'function')\n        throw new InvalidArgumentsGraphError(\n          `Graph.${name}: invalid updater function. Expecting a function but got \"${attributes}\"`\n        );\n    } else {\n      if (!isPlainObject(attributes))\n        throw new InvalidArgumentsGraphError(\n          `Graph.${name}: invalid attributes. Expecting an object but got \"${attributes}\"`\n        );\n    }\n  }\n\n  // Coercion of source & target:\n  source = '' + source;\n  target = '' + target;\n\n  let updater;\n\n  if (asUpdater) {\n    updater = attributes;\n    attributes = undefined;\n  }\n\n  if (!graph.allowSelfLoops && source === target)\n    throw new UsageGraphError(\n      `Graph.${name}: source & target are the same (\"${source}\"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.`\n    );\n\n  let sourceData = graph._nodes.get(source);\n  let targetData = graph._nodes.get(target);\n  let edgeData;\n\n  // Do we need to handle duplicate?\n  let alreadyExistingEdgeData;\n\n  if (!mustGenerateKey) {\n    edgeData = graph._edges.get(edge);\n\n    if (edgeData) {\n      // Here, we need to ensure, if the user gave a key, that source & target\n      // are consistent\n      if (edgeData.source.key !== source || edgeData.target.key !== target) {\n        // If source or target inconsistent\n        if (\n          !undirected ||\n          edgeData.source.key !== target ||\n          edgeData.target.key !== source\n        ) {\n          // If directed, or source/target aren't flipped\n          throw new UsageGraphError(\n            `Graph.${name}: inconsistency detected when attempting to merge the \"${edge}\" edge with \"${source}\" source & \"${target}\" target vs. (\"${edgeData.source.key}\", \"${edgeData.target.key}\").`\n          );\n        }\n      }\n\n      alreadyExistingEdgeData = edgeData;\n    }\n  }\n\n  // Here, we might have a source / target collision\n  if (!alreadyExistingEdgeData && !graph.multi && sourceData) {\n    alreadyExistingEdgeData = undirected\n      ? sourceData.undirected[target]\n      : sourceData.out[target];\n  }\n\n  // Handling duplicates\n  if (alreadyExistingEdgeData) {\n    const info = [alreadyExistingEdgeData.key, false, false, false];\n\n    // We can skip the attribute merging part if the user did not provide them\n    if (asUpdater ? !updater : !attributes) return info;\n\n    // Updating the attributes\n    if (asUpdater) {\n      const oldAttributes = alreadyExistingEdgeData.attributes;\n      alreadyExistingEdgeData.attributes = updater(oldAttributes);\n\n      graph.emit('edgeAttributesUpdated', {\n        type: 'replace',\n        key: alreadyExistingEdgeData.key,\n        attributes: alreadyExistingEdgeData.attributes\n      });\n    }\n\n    // Merging the attributes\n    else {\n      assign(alreadyExistingEdgeData.attributes, attributes);\n\n      graph.emit('edgeAttributesUpdated', {\n        type: 'merge',\n        key: alreadyExistingEdgeData.key,\n        attributes: alreadyExistingEdgeData.attributes,\n        data: attributes\n      });\n    }\n\n    return info;\n  }\n\n  attributes = attributes || {};\n\n  if (asUpdater && updater) attributes = updater(attributes);\n\n  // Must the graph generate an id for this edge?\n  const eventData = {\n    key: null,\n    undirected,\n    source,\n    target,\n    attributes\n  };\n\n  if (mustGenerateKey) {\n    // NOTE: in this case we can guarantee that the key does not already\n    // exist and is already correctly casted as a string\n    edge = graph._edgeKeyGenerator();\n  } else {\n    // Coercion of edge key\n    edge = '' + edge;\n\n    // Here, we have a key collision\n    if (graph._edges.has(edge))\n      throw new UsageGraphError(\n        `Graph.${name}: the \"${edge}\" edge already exists in the graph.`\n      );\n  }\n\n  let sourceWasAdded = false;\n  let targetWasAdded = false;\n\n  if (!sourceData) {\n    sourceData = unsafeAddNode(graph, source, {});\n    sourceWasAdded = true;\n\n    if (source === target) {\n      targetData = sourceData;\n      targetWasAdded = true;\n    }\n  }\n  if (!targetData) {\n    targetData = unsafeAddNode(graph, target, {});\n    targetWasAdded = true;\n  }\n\n  // Storing some data\n  edgeData = new EdgeData(undirected, edge, sourceData, targetData, attributes);\n\n  // Adding the edge to the internal register\n  graph._edges.set(edge, edgeData);\n\n  // Incrementing node degree counters\n  const isSelfLoop = source === target;\n\n  if (undirected) {\n    sourceData.undirectedDegree++;\n    targetData.undirectedDegree++;\n\n    if (isSelfLoop) {\n      sourceData.undirectedLoops++;\n      graph._undirectedSelfLoopCount++;\n    }\n  } else {\n    sourceData.outDegree++;\n    targetData.inDegree++;\n\n    if (isSelfLoop) {\n      sourceData.directedLoops++;\n      graph._directedSelfLoopCount++;\n    }\n  }\n\n  // Updating relevant index\n  if (graph.multi) edgeData.attachMulti();\n  else edgeData.attach();\n\n  if (undirected) graph._undirectedSize++;\n  else graph._directedSize++;\n\n  // Emitting\n  eventData.key = edge;\n\n  graph.emit('edgeAdded', eventData);\n\n  return [edge, true, sourceWasAdded, targetWasAdded];\n}\n\n/**\n * Internal method used to drop an edge.\n *\n * @param  {Graph}    graph    - Target graph.\n * @param  {EdgeData} edgeData - Data of the edge to drop.\n */\nfunction dropEdgeFromData(graph, edgeData) {\n  // Dropping the edge from the register\n  graph._edges.delete(edgeData.key);\n\n  // Updating related degrees\n  const {source: sourceData, target: targetData, attributes} = edgeData;\n\n  const undirected = edgeData.undirected;\n\n  const isSelfLoop = sourceData === targetData;\n\n  if (undirected) {\n    sourceData.undirectedDegree--;\n    targetData.undirectedDegree--;\n\n    if (isSelfLoop) {\n      sourceData.undirectedLoops--;\n      graph._undirectedSelfLoopCount--;\n    }\n  } else {\n    sourceData.outDegree--;\n    targetData.inDegree--;\n\n    if (isSelfLoop) {\n      sourceData.directedLoops--;\n      graph._directedSelfLoopCount--;\n    }\n  }\n\n  // Clearing index\n  if (graph.multi) edgeData.detachMulti();\n  else edgeData.detach();\n\n  if (undirected) graph._undirectedSize--;\n  else graph._directedSize--;\n\n  // Emitting\n  graph.emit('edgeDropped', {\n    key: edgeData.key,\n    attributes,\n    source: sourceData.key,\n    target: targetData.key,\n    undirected\n  });\n}\n\n/**\n * Graph class\n *\n * @constructor\n * @param  {object}  [options] - Options:\n * @param  {boolean}   [allowSelfLoops] - Allow self loops?\n * @param  {string}    [type]           - Type of the graph.\n * @param  {boolean}   [map]            - Allow references as keys?\n * @param  {boolean}   [multi]          - Allow parallel edges?\n *\n * @throws {Error} - Will throw if the arguments are not valid.\n */\nexport default class Graph extends EventEmitter {\n  constructor(options) {\n    super();\n\n    //-- Solving options\n    options = assign({}, DEFAULTS, options);\n\n    // Enforcing options validity\n    if (typeof options.multi !== 'boolean')\n      throw new InvalidArgumentsGraphError(\n        `Graph.constructor: invalid 'multi' option. Expecting a boolean but got \"${options.multi}\".`\n      );\n\n    if (!TYPES.has(options.type))\n      throw new InvalidArgumentsGraphError(\n        `Graph.constructor: invalid 'type' option. Should be one of \"mixed\", \"directed\" or \"undirected\" but got \"${options.type}\".`\n      );\n\n    if (typeof options.allowSelfLoops !== 'boolean')\n      throw new InvalidArgumentsGraphError(\n        `Graph.constructor: invalid 'allowSelfLoops' option. Expecting a boolean but got \"${options.allowSelfLoops}\".`\n      );\n\n    //-- Private properties\n\n    // Utilities\n    const NodeDataClass =\n      options.type === 'mixed'\n        ? MixedNodeData\n        : options.type === 'directed'\n        ? DirectedNodeData\n        : UndirectedNodeData;\n\n    privateProperty(this, 'NodeDataClass', NodeDataClass);\n\n    // Internal edge key generator\n\n    // NOTE: this internal generator produce keys that are strings\n    // composed of a weird prefix, an incremental instance id starting from\n    // a random byte and finally an internal instance incremental id.\n    // All this to avoid intra-frame and cross-frame adversarial inputs\n    // that can force a single #.addEdge call to degenerate into a O(n)\n    // available key search loop.\n\n    // It also ensures that automatically generated edge keys are unlikely\n    // to produce collisions with arbitrary keys given by users.\n    const instancePrefix = 'geid_' + INSTANCE_ID() + '_';\n    let edgeId = 0;\n\n    const edgeKeyGenerator = () => {\n      let availableEdgeKey;\n\n      do {\n        availableEdgeKey = instancePrefix + edgeId++;\n      } while (this._edges.has(availableEdgeKey));\n\n      return availableEdgeKey;\n    };\n\n    // Indexes\n    privateProperty(this, '_attributes', {});\n    privateProperty(this, '_nodes', new Map());\n    privateProperty(this, '_edges', new Map());\n    privateProperty(this, '_directedSize', 0);\n    privateProperty(this, '_undirectedSize', 0);\n    privateProperty(this, '_directedSelfLoopCount', 0);\n    privateProperty(this, '_undirectedSelfLoopCount', 0);\n    privateProperty(this, '_edgeKeyGenerator', edgeKeyGenerator);\n\n    // Options\n    privateProperty(this, '_options', options);\n\n    // Emitter properties\n    EMITTER_PROPS.forEach(prop => privateProperty(this, prop, this[prop]));\n\n    //-- Properties readers\n    readOnlyProperty(this, 'order', () => this._nodes.size);\n    readOnlyProperty(this, 'size', () => this._edges.size);\n    readOnlyProperty(this, 'directedSize', () => this._directedSize);\n    readOnlyProperty(this, 'undirectedSize', () => this._undirectedSize);\n    readOnlyProperty(\n      this,\n      'selfLoopCount',\n      () => this._directedSelfLoopCount + this._undirectedSelfLoopCount\n    );\n    readOnlyProperty(\n      this,\n      'directedSelfLoopCount',\n      () => this._directedSelfLoopCount\n    );\n    readOnlyProperty(\n      this,\n      'undirectedSelfLoopCount',\n      () => this._undirectedSelfLoopCount\n    );\n    readOnlyProperty(this, 'multi', this._options.multi);\n    readOnlyProperty(this, 'type', this._options.type);\n    readOnlyProperty(this, 'allowSelfLoops', this._options.allowSelfLoops);\n    readOnlyProperty(this, 'implementation', () => 'graphology');\n  }\n\n  _resetInstanceCounters() {\n    this._directedSize = 0;\n    this._undirectedSize = 0;\n    this._directedSelfLoopCount = 0;\n    this._undirectedSelfLoopCount = 0;\n  }\n\n  /**---------------------------------------------------------------------------\n   * Read\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method returning whether the given node is found in the graph.\n   *\n   * @param  {any}     node - The node.\n   * @return {boolean}\n   */\n  hasNode(node) {\n    return this._nodes.has('' + node);\n  }\n\n  /**\n   * Method returning whether the given directed edge is found in the graph.\n   *\n   * Arity 1:\n   * @param  {any}     edge - The edge's key.\n   *\n   * Arity 2:\n   * @param  {any}     source - The edge's source.\n   * @param  {any}     target - The edge's target.\n   *\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the arguments are invalid.\n   */\n  hasDirectedEdge(source, target) {\n    // Early termination\n    if (this.type === 'undirected') return false;\n\n    if (arguments.length === 1) {\n      const edge = '' + source;\n\n      const edgeData = this._edges.get(edge);\n\n      return !!edgeData && !edgeData.undirected;\n    } else if (arguments.length === 2) {\n      source = '' + source;\n      target = '' + target;\n\n      // If the node source or the target is not in the graph we break\n      const nodeData = this._nodes.get(source);\n\n      if (!nodeData) return false;\n\n      // Is there a directed edge pointing toward target?\n      return nodeData.out.hasOwnProperty(target);\n    }\n\n    throw new InvalidArgumentsGraphError(\n      `Graph.hasDirectedEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`\n    );\n  }\n\n  /**\n   * Method returning whether the given undirected edge is found in the graph.\n   *\n   * Arity 1:\n   * @param  {any}     edge - The edge's key.\n   *\n   * Arity 2:\n   * @param  {any}     source - The edge's source.\n   * @param  {any}     target - The edge's target.\n   *\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the arguments are invalid.\n   */\n  hasUndirectedEdge(source, target) {\n    // Early termination\n    if (this.type === 'directed') return false;\n\n    if (arguments.length === 1) {\n      const edge = '' + source;\n\n      const edgeData = this._edges.get(edge);\n\n      return !!edgeData && edgeData.undirected;\n    } else if (arguments.length === 2) {\n      source = '' + source;\n      target = '' + target;\n\n      // If the node source or the target is not in the graph we break\n      const nodeData = this._nodes.get(source);\n\n      if (!nodeData) return false;\n\n      // Is there a directed edge pointing toward target?\n      return nodeData.undirected.hasOwnProperty(target);\n    }\n\n    throw new InvalidArgumentsGraphError(\n      `Graph.hasDirectedEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`\n    );\n  }\n\n  /**\n   * Method returning whether the given edge is found in the graph.\n   *\n   * Arity 1:\n   * @param  {any}     edge - The edge's key.\n   *\n   * Arity 2:\n   * @param  {any}     source - The edge's source.\n   * @param  {any}     target - The edge's target.\n   *\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the arguments are invalid.\n   */\n  hasEdge(source, target) {\n    if (arguments.length === 1) {\n      const edge = '' + source;\n\n      return this._edges.has(edge);\n    } else if (arguments.length === 2) {\n      source = '' + source;\n      target = '' + target;\n\n      // If the node source or the target is not in the graph we break\n      const nodeData = this._nodes.get(source);\n\n      if (!nodeData) return false;\n\n      // Is there a directed edge pointing toward target?\n      return (\n        (typeof nodeData.out !== 'undefined' &&\n          nodeData.out.hasOwnProperty(target)) ||\n        (typeof nodeData.undirected !== 'undefined' &&\n          nodeData.undirected.hasOwnProperty(target))\n      );\n    }\n\n    throw new InvalidArgumentsGraphError(\n      `Graph.hasEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`\n    );\n  }\n\n  /**\n   * Method returning the edge matching source & target in a directed fashion.\n   *\n   * @param  {any} source - The edge's source.\n   * @param  {any} target - The edge's target.\n   *\n   * @return {any|undefined}\n   *\n   * @throws {Error} - Will throw if the graph is multi.\n   * @throws {Error} - Will throw if source or target doesn't exist.\n   */\n  directedEdge(source, target) {\n    if (this.type === 'undirected') return;\n\n    source = '' + source;\n    target = '' + target;\n\n    if (this.multi)\n      throw new UsageGraphError(\n        'Graph.directedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.directedEdges instead.'\n      );\n\n    const sourceData = this._nodes.get(source);\n\n    if (!sourceData)\n      throw new NotFoundGraphError(\n        `Graph.directedEdge: could not find the \"${source}\" source node in the graph.`\n      );\n\n    if (!this._nodes.has(target))\n      throw new NotFoundGraphError(\n        `Graph.directedEdge: could not find the \"${target}\" target node in the graph.`\n      );\n\n    const edgeData = (sourceData.out && sourceData.out[target]) || undefined;\n\n    if (edgeData) return edgeData.key;\n  }\n\n  /**\n   * Method returning the edge matching source & target in a undirected fashion.\n   *\n   * @param  {any} source - The edge's source.\n   * @param  {any} target - The edge's target.\n   *\n   * @return {any|undefined}\n   *\n   * @throws {Error} - Will throw if the graph is multi.\n   * @throws {Error} - Will throw if source or target doesn't exist.\n   */\n  undirectedEdge(source, target) {\n    if (this.type === 'directed') return;\n\n    source = '' + source;\n    target = '' + target;\n\n    if (this.multi)\n      throw new UsageGraphError(\n        'Graph.undirectedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.undirectedEdges instead.'\n      );\n\n    const sourceData = this._nodes.get(source);\n\n    if (!sourceData)\n      throw new NotFoundGraphError(\n        `Graph.undirectedEdge: could not find the \"${source}\" source node in the graph.`\n      );\n\n    if (!this._nodes.has(target))\n      throw new NotFoundGraphError(\n        `Graph.undirectedEdge: could not find the \"${target}\" target node in the graph.`\n      );\n\n    const edgeData =\n      (sourceData.undirected && sourceData.undirected[target]) || undefined;\n\n    if (edgeData) return edgeData.key;\n  }\n\n  /**\n   * Method returning the edge matching source & target in a mixed fashion.\n   *\n   * @param  {any} source - The edge's source.\n   * @param  {any} target - The edge's target.\n   *\n   * @return {any|undefined}\n   *\n   * @throws {Error} - Will throw if the graph is multi.\n   * @throws {Error} - Will throw if source or target doesn't exist.\n   */\n  edge(source, target) {\n    if (this.multi)\n      throw new UsageGraphError(\n        'Graph.edge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.edges instead.'\n      );\n\n    source = '' + source;\n    target = '' + target;\n\n    const sourceData = this._nodes.get(source);\n\n    if (!sourceData)\n      throw new NotFoundGraphError(\n        `Graph.edge: could not find the \"${source}\" source node in the graph.`\n      );\n\n    if (!this._nodes.has(target))\n      throw new NotFoundGraphError(\n        `Graph.edge: could not find the \"${target}\" target node in the graph.`\n      );\n\n    const edgeData =\n      (sourceData.out && sourceData.out[target]) ||\n      (sourceData.undirected && sourceData.undirected[target]) ||\n      undefined;\n\n    if (edgeData) return edgeData.key;\n  }\n\n  /**\n   * Method returning whether two nodes are directed neighbors.\n   *\n   * @param  {any}     node     - The node's key.\n   * @param  {any}     neighbor - The neighbor's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  areDirectedNeighbors(node, neighbor) {\n    node = '' + node;\n    neighbor = '' + neighbor;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.areDirectedNeighbors: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return false;\n\n    return neighbor in nodeData.in || neighbor in nodeData.out;\n  }\n\n  /**\n   * Method returning whether two nodes are out neighbors.\n   *\n   * @param  {any}     node     - The node's key.\n   * @param  {any}     neighbor - The neighbor's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  areOutNeighbors(node, neighbor) {\n    node = '' + node;\n    neighbor = '' + neighbor;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.areOutNeighbors: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return false;\n\n    return neighbor in nodeData.out;\n  }\n\n  /**\n   * Method returning whether two nodes are in neighbors.\n   *\n   * @param  {any}     node     - The node's key.\n   * @param  {any}     neighbor - The neighbor's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  areInNeighbors(node, neighbor) {\n    node = '' + node;\n    neighbor = '' + neighbor;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.areInNeighbors: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return false;\n\n    return neighbor in nodeData.in;\n  }\n\n  /**\n   * Method returning whether two nodes are undirected neighbors.\n   *\n   * @param  {any}     node     - The node's key.\n   * @param  {any}     neighbor - The neighbor's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  areUndirectedNeighbors(node, neighbor) {\n    node = '' + node;\n    neighbor = '' + neighbor;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.areUndirectedNeighbors: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'directed') return false;\n\n    return neighbor in nodeData.undirected;\n  }\n\n  /**\n   * Method returning whether two nodes are neighbors.\n   *\n   * @param  {any}     node     - The node's key.\n   * @param  {any}     neighbor - The neighbor's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  areNeighbors(node, neighbor) {\n    node = '' + node;\n    neighbor = '' + neighbor;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.areNeighbors: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type !== 'undirected') {\n      if (neighbor in nodeData.in || neighbor in nodeData.out) return true;\n    }\n\n    if (this.type !== 'directed') {\n      if (neighbor in nodeData.undirected) return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Method returning whether two nodes are inbound neighbors.\n   *\n   * @param  {any}     node     - The node's key.\n   * @param  {any}     neighbor - The neighbor's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  areInboundNeighbors(node, neighbor) {\n    node = '' + node;\n    neighbor = '' + neighbor;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.areInboundNeighbors: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type !== 'undirected') {\n      if (neighbor in nodeData.in) return true;\n    }\n\n    if (this.type !== 'directed') {\n      if (neighbor in nodeData.undirected) return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Method returning whether two nodes are outbound neighbors.\n   *\n   * @param  {any}     node     - The node's key.\n   * @param  {any}     neighbor - The neighbor's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  areOutboundNeighbors(node, neighbor) {\n    node = '' + node;\n    neighbor = '' + neighbor;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.areOutboundNeighbors: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type !== 'undirected') {\n      if (neighbor in nodeData.out) return true;\n    }\n\n    if (this.type !== 'directed') {\n      if (neighbor in nodeData.undirected) return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Method returning the given node's in degree.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  inDegree(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.inDegree: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return 0;\n\n    return nodeData.inDegree;\n  }\n\n  /**\n   * Method returning the given node's out degree.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  outDegree(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.outDegree: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return 0;\n\n    return nodeData.outDegree;\n  }\n\n  /**\n   * Method returning the given node's directed degree.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  directedDegree(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.directedDegree: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return 0;\n\n    return nodeData.inDegree + nodeData.outDegree;\n  }\n\n  /**\n   * Method returning the given node's undirected degree.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  undirectedDegree(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.undirectedDegree: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'directed') return 0;\n\n    return nodeData.undirectedDegree;\n  }\n\n  /**\n   * Method returning the given node's inbound degree.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's inbound degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  inboundDegree(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.inboundDegree: could not find the \"${node}\" node in the graph.`\n      );\n\n    let degree = 0;\n\n    if (this.type !== 'directed') {\n      degree += nodeData.undirectedDegree;\n    }\n\n    if (this.type !== 'undirected') {\n      degree += nodeData.inDegree;\n    }\n\n    return degree;\n  }\n\n  /**\n   * Method returning the given node's outbound degree.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's outbound degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  outboundDegree(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.outboundDegree: could not find the \"${node}\" node in the graph.`\n      );\n\n    let degree = 0;\n\n    if (this.type !== 'directed') {\n      degree += nodeData.undirectedDegree;\n    }\n\n    if (this.type !== 'undirected') {\n      degree += nodeData.outDegree;\n    }\n\n    return degree;\n  }\n\n  /**\n   * Method returning the given node's directed degree.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  degree(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.degree: could not find the \"${node}\" node in the graph.`\n      );\n\n    let degree = 0;\n\n    if (this.type !== 'directed') {\n      degree += nodeData.undirectedDegree;\n    }\n\n    if (this.type !== 'undirected') {\n      degree += nodeData.inDegree + nodeData.outDegree;\n    }\n\n    return degree;\n  }\n\n  /**\n   * Method returning the given node's in degree without considering self loops.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  inDegreeWithoutSelfLoops(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.inDegreeWithoutSelfLoops: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return 0;\n\n    return nodeData.inDegree - nodeData.directedLoops;\n  }\n\n  /**\n   * Method returning the given node's out degree without considering self loops.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  outDegreeWithoutSelfLoops(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.outDegreeWithoutSelfLoops: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return 0;\n\n    return nodeData.outDegree - nodeData.directedLoops;\n  }\n\n  /**\n   * Method returning the given node's directed degree without considering self loops.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  directedDegreeWithoutSelfLoops(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.directedDegreeWithoutSelfLoops: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return 0;\n\n    return nodeData.inDegree + nodeData.outDegree - nodeData.directedLoops * 2;\n  }\n\n  /**\n   * Method returning the given node's undirected degree without considering self loops.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  undirectedDegreeWithoutSelfLoops(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.undirectedDegreeWithoutSelfLoops: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'directed') return 0;\n\n    return nodeData.undirectedDegree - nodeData.undirectedLoops * 2;\n  }\n\n  /**\n   * Method returning the given node's inbound degree without considering self loops.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's inbound degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  inboundDegreeWithoutSelfLoops(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.inboundDegreeWithoutSelfLoops: could not find the \"${node}\" node in the graph.`\n      );\n\n    let degree = 0;\n    let loops = 0;\n\n    if (this.type !== 'directed') {\n      degree += nodeData.undirectedDegree;\n      loops += nodeData.undirectedLoops * 2;\n    }\n\n    if (this.type !== 'undirected') {\n      degree += nodeData.inDegree;\n      loops += nodeData.directedLoops;\n    }\n\n    return degree - loops;\n  }\n\n  /**\n   * Method returning the given node's outbound degree without considering self loops.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's outbound degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  outboundDegreeWithoutSelfLoops(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.outboundDegreeWithoutSelfLoops: could not find the \"${node}\" node in the graph.`\n      );\n\n    let degree = 0;\n    let loops = 0;\n\n    if (this.type !== 'directed') {\n      degree += nodeData.undirectedDegree;\n      loops += nodeData.undirectedLoops * 2;\n    }\n\n    if (this.type !== 'undirected') {\n      degree += nodeData.outDegree;\n      loops += nodeData.directedLoops;\n    }\n\n    return degree - loops;\n  }\n\n  /**\n   * Method returning the given node's directed degree without considering self loops.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  degreeWithoutSelfLoops(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.degreeWithoutSelfLoops: could not find the \"${node}\" node in the graph.`\n      );\n\n    let degree = 0;\n    let loops = 0;\n\n    if (this.type !== 'directed') {\n      degree += nodeData.undirectedDegree;\n      loops += nodeData.undirectedLoops * 2;\n    }\n\n    if (this.type !== 'undirected') {\n      degree += nodeData.inDegree + nodeData.outDegree;\n      loops += nodeData.directedLoops * 2;\n    }\n\n    return degree - loops;\n  }\n\n  /**\n   * Method returning the given edge's source.\n   *\n   * @param  {any} edge - The edge's key.\n   * @return {any}      - The edge's source.\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  source(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(\n        `Graph.source: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    return data.source.key;\n  }\n\n  /**\n   * Method returning the given edge's target.\n   *\n   * @param  {any} edge - The edge's key.\n   * @return {any}      - The edge's target.\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  target(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(\n        `Graph.target: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    return data.target.key;\n  }\n\n  /**\n   * Method returning the given edge's extremities.\n   *\n   * @param  {any}   edge - The edge's key.\n   * @return {array}      - The edge's extremities.\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  extremities(edge) {\n    edge = '' + edge;\n\n    const edgeData = this._edges.get(edge);\n\n    if (!edgeData)\n      throw new NotFoundGraphError(\n        `Graph.extremities: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    return [edgeData.source.key, edgeData.target.key];\n  }\n\n  /**\n   * Given a node & an edge, returns the other extremity of the edge.\n   *\n   * @param  {any}   node - The node's key.\n   * @param  {any}   edge - The edge's key.\n   * @return {any}        - The related node.\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph or if the\n   *                   edge & node are not related.\n   */\n  opposite(node, edge) {\n    node = '' + node;\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(\n        `Graph.opposite: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    const source = data.source.key;\n    const target = data.target.key;\n\n    if (node === source) return target;\n    if (node === target) return source;\n\n    throw new NotFoundGraphError(\n      `Graph.opposite: the \"${node}\" node is not attached to the \"${edge}\" edge (${source}, ${target}).`\n    );\n  }\n\n  /**\n   * Returns whether the given edge has the given node as extremity.\n   *\n   * @param  {any}     edge - The edge's key.\n   * @param  {any}     node - The node's key.\n   * @return {boolean}      - The related node.\n   *\n   * @throws {Error} - Will throw if either the node or the edge isn't in the graph.\n   */\n  hasExtremity(edge, node) {\n    edge = '' + edge;\n    node = '' + node;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(\n        `Graph.hasExtremity: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    return data.source.key === node || data.target.key === node;\n  }\n\n  /**\n   * Method returning whether the given edge is undirected.\n   *\n   * @param  {any}     edge - The edge's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  isUndirected(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(\n        `Graph.isUndirected: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    return data.undirected;\n  }\n\n  /**\n   * Method returning whether the given edge is directed.\n   *\n   * @param  {any}     edge - The edge's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  isDirected(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(\n        `Graph.isDirected: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    return !data.undirected;\n  }\n\n  /**\n   * Method returning whether the given edge is a self loop.\n   *\n   * @param  {any}     edge - The edge's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  isSelfLoop(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(\n        `Graph.isSelfLoop: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    return data.source === data.target;\n  }\n\n  /**---------------------------------------------------------------------------\n   * Mutation\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method used to add a node to the graph.\n   *\n   * @param  {any}    node         - The node.\n   * @param  {object} [attributes] - Optional attributes.\n   * @return {any}                 - The node.\n   *\n   * @throws {Error} - Will throw if the given node already exist.\n   * @throws {Error} - Will throw if the given attributes are not an object.\n   */\n  addNode(node, attributes) {\n    const nodeData = addNode(this, node, attributes);\n\n    return nodeData.key;\n  }\n\n  /**\n   * Method used to merge a node into the graph.\n   *\n   * @param  {any}    node         - The node.\n   * @param  {object} [attributes] - Optional attributes.\n   * @return {any}                 - The node.\n   */\n  mergeNode(node, attributes) {\n    if (attributes && !isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(\n        `Graph.mergeNode: invalid attributes. Expecting an object but got \"${attributes}\"`\n      );\n\n    // String coercion\n    node = '' + node;\n    attributes = attributes || {};\n\n    // If the node already exists, we merge the attributes\n    let data = this._nodes.get(node);\n\n    if (data) {\n      if (attributes) {\n        assign(data.attributes, attributes);\n\n        this.emit('nodeAttributesUpdated', {\n          type: 'merge',\n          key: node,\n          attributes: data.attributes,\n          data: attributes\n        });\n      }\n      return [node, false];\n    }\n\n    data = new this.NodeDataClass(node, attributes);\n\n    // Adding the node to internal register\n    this._nodes.set(node, data);\n\n    // Emitting\n    this.emit('nodeAdded', {\n      key: node,\n      attributes\n    });\n\n    return [node, true];\n  }\n\n  /**\n   * Method used to add a node if it does not exist in the graph or else to\n   * update its attributes using a function.\n   *\n   * @param  {any}      node      - The node.\n   * @param  {function} [updater] - Optional updater function.\n   * @return {any}                - The node.\n   */\n  updateNode(node, updater) {\n    if (updater && typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        `Graph.updateNode: invalid updater function. Expecting a function but got \"${updater}\"`\n      );\n\n    // String coercion\n    node = '' + node;\n\n    // If the node already exists, we update the attributes\n    let data = this._nodes.get(node);\n\n    if (data) {\n      if (updater) {\n        const oldAttributes = data.attributes;\n        data.attributes = updater(oldAttributes);\n\n        this.emit('nodeAttributesUpdated', {\n          type: 'replace',\n          key: node,\n          attributes: data.attributes\n        });\n      }\n      return [node, false];\n    }\n\n    const attributes = updater ? updater({}) : {};\n\n    data = new this.NodeDataClass(node, attributes);\n\n    // Adding the node to internal register\n    this._nodes.set(node, data);\n\n    // Emitting\n    this.emit('nodeAdded', {\n      key: node,\n      attributes\n    });\n\n    return [node, true];\n  }\n\n  /**\n   * Method used to drop a single node & all its attached edges from the graph.\n   *\n   * @param  {any}    node - The node.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if the node doesn't exist.\n   */\n  dropNode(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.dropNode: could not find the \"${node}\" node in the graph.`\n      );\n\n    let edgeData;\n\n    // Removing attached edges\n    // NOTE: we could be faster here, but this is such a pain to maintain\n    if (this.type !== 'undirected') {\n      for (const neighbor in nodeData.out) {\n        edgeData = nodeData.out[neighbor];\n\n        do {\n          dropEdgeFromData(this, edgeData);\n          edgeData = edgeData.next;\n        } while (edgeData);\n      }\n\n      for (const neighbor in nodeData.in) {\n        edgeData = nodeData.in[neighbor];\n\n        do {\n          dropEdgeFromData(this, edgeData);\n          edgeData = edgeData.next;\n        } while (edgeData);\n      }\n    }\n\n    if (this.type !== 'directed') {\n      for (const neighbor in nodeData.undirected) {\n        edgeData = nodeData.undirected[neighbor];\n\n        do {\n          dropEdgeFromData(this, edgeData);\n          edgeData = edgeData.next;\n        } while (edgeData);\n      }\n    }\n\n    // Dropping the node from the register\n    this._nodes.delete(node);\n\n    // Emitting\n    this.emit('nodeDropped', {\n      key: node,\n      attributes: nodeData.attributes\n    });\n  }\n\n  /**\n   * Method used to drop a single edge from the graph.\n   *\n   * Arity 1:\n   * @param  {any}    edge - The edge.\n   *\n   * Arity 2:\n   * @param  {any}    source - Source node.\n   * @param  {any}    target - Target node.\n   *\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if the edge doesn't exist.\n   */\n  dropEdge(edge) {\n    let edgeData;\n\n    if (arguments.length > 1) {\n      const source = '' + arguments[0];\n      const target = '' + arguments[1];\n\n      edgeData = getMatchingEdge(this, source, target, this.type);\n\n      if (!edgeData)\n        throw new NotFoundGraphError(\n          `Graph.dropEdge: could not find the \"${source}\" -> \"${target}\" edge in the graph.`\n        );\n    } else {\n      edge = '' + edge;\n\n      edgeData = this._edges.get(edge);\n\n      if (!edgeData)\n        throw new NotFoundGraphError(\n          `Graph.dropEdge: could not find the \"${edge}\" edge in the graph.`\n        );\n    }\n\n    dropEdgeFromData(this, edgeData);\n\n    return this;\n  }\n\n  /**\n   * Method used to drop a single directed edge from the graph.\n   *\n   * @param  {any}    source - Source node.\n   * @param  {any}    target - Target node.\n   *\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if the edge doesn't exist.\n   */\n  dropDirectedEdge(source, target) {\n    if (arguments.length < 2)\n      throw new UsageGraphError(\n        'Graph.dropDirectedEdge: it does not make sense to try and drop a directed edge by key. What if the edge with this key is undirected? Use #.dropEdge for this purpose instead.'\n      );\n\n    if (this.multi)\n      throw new UsageGraphError(\n        'Graph.dropDirectedEdge: cannot use a {source,target} combo when dropping an edge in a MultiGraph since we cannot infer the one you want to delete as there could be multiple ones.'\n      );\n\n    source = '' + source;\n    target = '' + target;\n\n    const edgeData = getMatchingEdge(this, source, target, 'directed');\n\n    if (!edgeData)\n      throw new NotFoundGraphError(\n        `Graph.dropDirectedEdge: could not find a \"${source}\" -> \"${target}\" edge in the graph.`\n      );\n\n    dropEdgeFromData(this, edgeData);\n\n    return this;\n  }\n\n  /**\n   * Method used to drop a single undirected edge from the graph.\n   *\n   * @param  {any}    source - Source node.\n   * @param  {any}    target - Target node.\n   *\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if the edge doesn't exist.\n   */\n  dropUndirectedEdge(source, target) {\n    if (arguments.length < 2)\n      throw new UsageGraphError(\n        'Graph.dropUndirectedEdge: it does not make sense to drop a directed edge by key. What if the edge with this key is undirected? Use #.dropEdge for this purpose instead.'\n      );\n\n    if (this.multi)\n      throw new UsageGraphError(\n        'Graph.dropUndirectedEdge: cannot use a {source,target} combo when dropping an edge in a MultiGraph since we cannot infer the one you want to delete as there could be multiple ones.'\n      );\n\n    const edgeData = getMatchingEdge(this, source, target, 'undirected');\n\n    if (!edgeData)\n      throw new NotFoundGraphError(\n        `Graph.dropUndirectedEdge: could not find a \"${source}\" -> \"${target}\" edge in the graph.`\n      );\n\n    dropEdgeFromData(this, edgeData);\n\n    return this;\n  }\n\n  /**\n   * Method used to remove every edge & every node from the graph.\n   *\n   * @return {Graph}\n   */\n  clear() {\n    // Clearing edges\n    this._edges.clear();\n\n    // Clearing nodes\n    this._nodes.clear();\n\n    // Reset counters\n    this._resetInstanceCounters();\n\n    // Emitting\n    this.emit('cleared');\n  }\n\n  /**\n   * Method used to remove every edge from the graph.\n   *\n   * @return {Graph}\n   */\n  clearEdges() {\n    // Clearing structure index\n    const iterator = this._nodes.values();\n\n    let step;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      step.value.clear();\n    }\n\n    // Clearing edges\n    this._edges.clear();\n\n    // Reset counters\n    this._resetInstanceCounters();\n\n    // Emitting\n    this.emit('edgesCleared');\n  }\n\n  /**---------------------------------------------------------------------------\n   * Attributes-related methods\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method returning the desired graph's attribute.\n   *\n   * @param  {string} name - Name of the attribute.\n   * @return {any}\n   */\n  getAttribute(name) {\n    return this._attributes[name];\n  }\n\n  /**\n   * Method returning the graph's attributes.\n   *\n   * @return {object}\n   */\n  getAttributes() {\n    return this._attributes;\n  }\n\n  /**\n   * Method returning whether the graph has the desired attribute.\n   *\n   * @param  {string}  name - Name of the attribute.\n   * @return {boolean}\n   */\n  hasAttribute(name) {\n    return this._attributes.hasOwnProperty(name);\n  }\n\n  /**\n   * Method setting a value for the desired graph's attribute.\n   *\n   * @param  {string}  name  - Name of the attribute.\n   * @param  {any}     value - Value for the attribute.\n   * @return {Graph}\n   */\n  setAttribute(name, value) {\n    this._attributes[name] = value;\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'set',\n      attributes: this._attributes,\n      name\n    });\n\n    return this;\n  }\n\n  /**\n   * Method using a function to update the desired graph's attribute's value.\n   *\n   * @param  {string}   name    - Name of the attribute.\n   * @param  {function} updater - Function use to update the attribute's value.\n   * @return {Graph}\n   */\n  updateAttribute(name, updater) {\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.updateAttribute: updater should be a function.'\n      );\n\n    const value = this._attributes[name];\n\n    this._attributes[name] = updater(value);\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'set',\n      attributes: this._attributes,\n      name\n    });\n\n    return this;\n  }\n\n  /**\n   * Method removing the desired graph's attribute.\n   *\n   * @param  {string} name  - Name of the attribute.\n   * @return {Graph}\n   */\n  removeAttribute(name) {\n    delete this._attributes[name];\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'remove',\n      attributes: this._attributes,\n      name\n    });\n\n    return this;\n  }\n\n  /**\n   * Method replacing the graph's attributes.\n   *\n   * @param  {object} attributes - New attributes.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if given attributes are not a plain object.\n   */\n  replaceAttributes(attributes) {\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(\n        'Graph.replaceAttributes: provided attributes are not a plain object.'\n      );\n\n    this._attributes = attributes;\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'replace',\n      attributes: this._attributes\n    });\n\n    return this;\n  }\n\n  /**\n   * Method merging the graph's attributes.\n   *\n   * @param  {object} attributes - Attributes to merge.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if given attributes are not a plain object.\n   */\n  mergeAttributes(attributes) {\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(\n        'Graph.mergeAttributes: provided attributes are not a plain object.'\n      );\n\n    assign(this._attributes, attributes);\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'merge',\n      attributes: this._attributes,\n      data: attributes\n    });\n\n    return this;\n  }\n\n  /**\n   * Method updating the graph's attributes.\n   *\n   * @param  {function} updater - Function used to update the attributes.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if given updater is not a function.\n   */\n  updateAttributes(updater) {\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.updateAttributes: provided updater is not a function.'\n      );\n\n    this._attributes = updater(this._attributes);\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'update',\n      attributes: this._attributes\n    });\n\n    return this;\n  }\n\n  /**\n   * Method used to update each node's attributes using the given function.\n   *\n   * @param {function}  updater - Updater function to use.\n   * @param {object}    [hints] - Optional hints.\n   */\n  updateEachNodeAttributes(updater, hints) {\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.updateEachNodeAttributes: expecting an updater function.'\n      );\n\n    if (hints && !validateHints(hints))\n      throw new InvalidArgumentsGraphError(\n        'Graph.updateEachNodeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}'\n      );\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      nodeData = step.value;\n      nodeData.attributes = updater(nodeData.key, nodeData.attributes);\n    }\n\n    this.emit('eachNodeAttributesUpdated', {\n      hints: hints ? hints : null\n    });\n  }\n\n  /**\n   * Method used to update each edge's attributes using the given function.\n   *\n   * @param {function}  updater - Updater function to use.\n   * @param {object}    [hints] - Optional hints.\n   */\n  updateEachEdgeAttributes(updater, hints) {\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.updateEachEdgeAttributes: expecting an updater function.'\n      );\n\n    if (hints && !validateHints(hints))\n      throw new InvalidArgumentsGraphError(\n        'Graph.updateEachEdgeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}'\n      );\n\n    const iterator = this._edges.values();\n\n    let step, edgeData, sourceData, targetData;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      edgeData = step.value;\n      sourceData = edgeData.source;\n      targetData = edgeData.target;\n\n      edgeData.attributes = updater(\n        edgeData.key,\n        edgeData.attributes,\n        sourceData.key,\n        targetData.key,\n        sourceData.attributes,\n        targetData.attributes,\n        edgeData.undirected\n      );\n    }\n\n    this.emit('eachEdgeAttributesUpdated', {\n      hints: hints ? hints : null\n    });\n  }\n\n  /**---------------------------------------------------------------------------\n   * Iteration-related methods\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method iterating over the graph's adjacency using the given callback.\n   *\n   * @param  {function}  callback - Callback to use.\n   */\n  forEachAdjacencyEntry(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.forEachAdjacencyEntry: expecting a callback.'\n      );\n\n    forEachAdjacency(false, false, false, this, callback);\n  }\n  forEachAdjacencyEntryWithOrphans(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.forEachAdjacencyEntryWithOrphans: expecting a callback.'\n      );\n\n    forEachAdjacency(false, false, true, this, callback);\n  }\n\n  /**\n   * Method iterating over the graph's assymetric adjacency using the given callback.\n   *\n   * @param  {function}  callback - Callback to use.\n   */\n  forEachAssymetricAdjacencyEntry(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.forEachAssymetricAdjacencyEntry: expecting a callback.'\n      );\n\n    forEachAdjacency(false, true, false, this, callback);\n  }\n  forEachAssymetricAdjacencyEntryWithOrphans(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.forEachAssymetricAdjacencyEntryWithOrphans: expecting a callback.'\n      );\n\n    forEachAdjacency(false, true, true, this, callback);\n  }\n\n  /**\n   * Method returning the list of the graph's nodes.\n   *\n   * @return {array} - The nodes.\n   */\n  nodes() {\n    if (typeof Array.from === 'function') return Array.from(this._nodes.keys());\n\n    return take(this._nodes.keys(), this._nodes.size);\n  }\n\n  /**\n   * Method iterating over the graph's nodes using the given callback.\n   *\n   * @param  {function}  callback - Callback (key, attributes, index).\n   */\n  forEachNode(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.forEachNode: expecting a callback.'\n      );\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      nodeData = step.value;\n      callback(nodeData.key, nodeData.attributes);\n    }\n  }\n\n  /**\n   * Method iterating attempting to find a node matching the given predicate\n   * function.\n   *\n   * @param  {function}  callback - Callback (key, attributes).\n   */\n  findNode(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.findNode: expecting a callback.'\n      );\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      nodeData = step.value;\n\n      if (callback(nodeData.key, nodeData.attributes)) return nodeData.key;\n    }\n\n    return;\n  }\n\n  /**\n   * Method mapping nodes.\n   *\n   * @param  {function}  callback - Callback (key, attributes).\n   */\n  mapNodes(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.mapNode: expecting a callback.'\n      );\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    const result = new Array(this.order);\n    let i = 0;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      nodeData = step.value;\n      result[i++] = callback(nodeData.key, nodeData.attributes);\n    }\n\n    return result;\n  }\n\n  /**\n   * Method returning whether some node verify the given predicate.\n   *\n   * @param  {function}  callback - Callback (key, attributes).\n   */\n  someNode(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.someNode: expecting a callback.'\n      );\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      nodeData = step.value;\n\n      if (callback(nodeData.key, nodeData.attributes)) return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Method returning whether all node verify the given predicate.\n   *\n   * @param  {function}  callback - Callback (key, attributes).\n   */\n  everyNode(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.everyNode: expecting a callback.'\n      );\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      nodeData = step.value;\n\n      if (!callback(nodeData.key, nodeData.attributes)) return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Method filtering nodes.\n   *\n   * @param  {function}  callback - Callback (key, attributes).\n   */\n  filterNodes(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.filterNodes: expecting a callback.'\n      );\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    const result = [];\n\n    while (((step = iterator.next()), step.done !== true)) {\n      nodeData = step.value;\n\n      if (callback(nodeData.key, nodeData.attributes))\n        result.push(nodeData.key);\n    }\n\n    return result;\n  }\n\n  /**\n   * Method reducing nodes.\n   *\n   * @param  {function}  callback - Callback (accumulator, key, attributes).\n   */\n  reduceNodes(callback, initialValue) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.reduceNodes: expecting a callback.'\n      );\n\n    if (arguments.length < 2)\n      throw new InvalidArgumentsGraphError(\n        'Graph.reduceNodes: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.'\n      );\n\n    let accumulator = initialValue;\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      nodeData = step.value;\n      accumulator = callback(accumulator, nodeData.key, nodeData.attributes);\n    }\n\n    return accumulator;\n  }\n\n  /**\n   * Method returning an iterator over the graph's node entries.\n   *\n   * @return {Iterator}\n   */\n  nodeEntries() {\n    const iterator = this._nodes.values();\n\n    return new Iterator(() => {\n      const step = iterator.next();\n\n      if (step.done) return step;\n\n      const data = step.value;\n\n      return {\n        value: {node: data.key, attributes: data.attributes},\n        done: false\n      };\n    });\n  }\n\n  /**---------------------------------------------------------------------------\n   * Serialization\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method used to export the whole graph.\n   *\n   * @return {object} - The serialized graph.\n   */\n  export() {\n    const nodes = new Array(this._nodes.size);\n\n    let i = 0;\n\n    this._nodes.forEach((data, key) => {\n      nodes[i++] = serializeNode(key, data);\n    });\n\n    const edges = new Array(this._edges.size);\n\n    i = 0;\n\n    this._edges.forEach((data, key) => {\n      edges[i++] = serializeEdge(this.type, key, data);\n    });\n\n    return {\n      options: {\n        type: this.type,\n        multi: this.multi,\n        allowSelfLoops: this.allowSelfLoops\n      },\n      attributes: this.getAttributes(),\n      nodes,\n      edges\n    };\n  }\n\n  /**\n   * Method used to import a serialized graph.\n   *\n   * @param  {object|Graph} data  - The serialized graph.\n   * @param  {boolean}      merge - Whether to merge data.\n   * @return {Graph}              - Returns itself for chaining.\n   */\n  import(data, merge = false) {\n    // Importing a Graph instance directly\n    if (data instanceof Graph) {\n      // Nodes\n      data.forEachNode((n, a) => {\n        if (merge) this.mergeNode(n, a);\n        else this.addNode(n, a);\n      });\n\n      // Edges\n      data.forEachEdge((e, a, s, t, _sa, _ta, u) => {\n        if (merge) {\n          if (u) this.mergeUndirectedEdgeWithKey(e, s, t, a);\n          else this.mergeDirectedEdgeWithKey(e, s, t, a);\n        } else {\n          if (u) this.addUndirectedEdgeWithKey(e, s, t, a);\n          else this.addDirectedEdgeWithKey(e, s, t, a);\n        }\n      });\n\n      return this;\n    }\n\n    // Importing a serialized graph\n    if (!isPlainObject(data))\n      throw new InvalidArgumentsGraphError(\n        'Graph.import: invalid argument. Expecting a serialized graph or, alternatively, a Graph instance.'\n      );\n\n    if (data.attributes) {\n      if (!isPlainObject(data.attributes))\n        throw new InvalidArgumentsGraphError(\n          'Graph.import: invalid attributes. Expecting a plain object.'\n        );\n\n      if (merge) this.mergeAttributes(data.attributes);\n      else this.replaceAttributes(data.attributes);\n    }\n\n    let i, l, list, node, edge;\n\n    if (data.nodes) {\n      list = data.nodes;\n\n      if (!Array.isArray(list))\n        throw new InvalidArgumentsGraphError(\n          'Graph.import: invalid nodes. Expecting an array.'\n        );\n\n      for (i = 0, l = list.length; i < l; i++) {\n        node = list[i];\n\n        // Validating\n        validateSerializedNode(node);\n\n        // Adding the node\n        const {key, attributes} = node;\n\n        if (merge) this.mergeNode(key, attributes);\n        else this.addNode(key, attributes);\n      }\n    }\n\n    if (data.edges) {\n      let undirectedByDefault = false;\n\n      if (this.type === 'undirected') {\n        undirectedByDefault = true;\n      }\n\n      list = data.edges;\n\n      if (!Array.isArray(list))\n        throw new InvalidArgumentsGraphError(\n          'Graph.import: invalid edges. Expecting an array.'\n        );\n\n      for (i = 0, l = list.length; i < l; i++) {\n        edge = list[i];\n\n        // Validating\n        validateSerializedEdge(edge);\n\n        // Adding the edge\n        const {\n          source,\n          target,\n          attributes,\n          undirected = undirectedByDefault\n        } = edge;\n\n        let method;\n\n        if ('key' in edge) {\n          method = merge\n            ? undirected\n              ? this.mergeUndirectedEdgeWithKey\n              : this.mergeDirectedEdgeWithKey\n            : undirected\n            ? this.addUndirectedEdgeWithKey\n            : this.addDirectedEdgeWithKey;\n\n          method.call(this, edge.key, source, target, attributes);\n        } else {\n          method = merge\n            ? undirected\n              ? this.mergeUndirectedEdge\n              : this.mergeDirectedEdge\n            : undirected\n            ? this.addUndirectedEdge\n            : this.addDirectedEdge;\n\n          method.call(this, source, target, attributes);\n        }\n      }\n    }\n\n    return this;\n  }\n\n  /**---------------------------------------------------------------------------\n   * Utils\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method returning a null copy of the graph, i.e. a graph without nodes\n   * & edges but with the exact same options.\n   *\n   * @param  {object} options - Options to merge with the current ones.\n   * @return {Graph}          - The null copy.\n   */\n  nullCopy(options) {\n    const graph = new Graph(assign({}, this._options, options));\n    graph.replaceAttributes(assign({}, this.getAttributes()));\n    return graph;\n  }\n\n  /**\n   * Method returning an empty copy of the graph, i.e. a graph without edges but\n   * with the exact same options.\n   *\n   * @param  {object} options - Options to merge with the current ones.\n   * @return {Graph}          - The empty copy.\n   */\n  emptyCopy(options) {\n    const graph = this.nullCopy(options);\n\n    this._nodes.forEach((nodeData, key) => {\n      const attributes = assign({}, nodeData.attributes);\n\n      // NOTE: no need to emit events since user cannot access the instance yet\n      nodeData = new graph.NodeDataClass(key, attributes);\n      graph._nodes.set(key, nodeData);\n    });\n\n    return graph;\n  }\n\n  /**\n   * Method returning an exact copy of the graph.\n   *\n   * @param  {object} options - Upgrade options.\n   * @return {Graph}          - The copy.\n   */\n  copy(options) {\n    options = options || {};\n\n    if (\n      typeof options.type === 'string' &&\n      options.type !== this.type &&\n      options.type !== 'mixed'\n    )\n      throw new UsageGraphError(\n        `Graph.copy: cannot create an incompatible copy from \"${this.type}\" type to \"${options.type}\" because this would mean losing information about the current graph.`\n      );\n\n    if (\n      typeof options.multi === 'boolean' &&\n      options.multi !== this.multi &&\n      options.multi !== true\n    )\n      throw new UsageGraphError(\n        'Graph.copy: cannot create an incompatible copy by downgrading a multi graph to a simple one because this would mean losing information about the current graph.'\n      );\n\n    if (\n      typeof options.allowSelfLoops === 'boolean' &&\n      options.allowSelfLoops !== this.allowSelfLoops &&\n      options.allowSelfLoops !== true\n    )\n      throw new UsageGraphError(\n        'Graph.copy: cannot create an incompatible copy from a graph allowing self loops to one that does not because this would mean losing information about the current graph.'\n      );\n\n    const graph = this.emptyCopy(options);\n\n    const iterator = this._edges.values();\n\n    let step, edgeData;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      edgeData = step.value;\n\n      // NOTE: no need to emit events since user cannot access the instance yet\n      addEdge(\n        graph,\n        'copy',\n        false,\n        edgeData.undirected,\n        edgeData.key,\n        edgeData.source.key,\n        edgeData.target.key,\n        assign({}, edgeData.attributes)\n      );\n    }\n\n    return graph;\n  }\n\n  /**---------------------------------------------------------------------------\n   * Known methods\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method used by JavaScript to perform JSON serialization.\n   *\n   * @return {object} - The serialized graph.\n   */\n  toJSON() {\n    return this.export();\n  }\n\n  /**\n   * Method returning [object Graph].\n   */\n  toString() {\n    return '[object Graph]';\n  }\n\n  /**\n   * Method used internally by node's console to display a custom object.\n   *\n   * @return {object} - Formatted object representation of the graph.\n   */\n  inspect() {\n    const nodes = {};\n    this._nodes.forEach((data, key) => {\n      nodes[key] = data.attributes;\n    });\n\n    const edges = {},\n      multiIndex = {};\n\n    this._edges.forEach((data, key) => {\n      const direction = data.undirected ? '--' : '->';\n\n      let label = '';\n\n      let source = data.source.key;\n      let target = data.target.key;\n      let tmp;\n\n      if (data.undirected && source > target) {\n        tmp = source;\n        source = target;\n        target = tmp;\n      }\n\n      const desc = `(${source})${direction}(${target})`;\n\n      if (!key.startsWith('geid_')) {\n        label += `[${key}]: `;\n      } else if (this.multi) {\n        if (typeof multiIndex[desc] === 'undefined') {\n          multiIndex[desc] = 0;\n        } else {\n          multiIndex[desc]++;\n        }\n\n        label += `${multiIndex[desc]}. `;\n      }\n\n      label += desc;\n\n      edges[label] = data.attributes;\n    });\n\n    const dummy = {};\n\n    for (const k in this) {\n      if (\n        this.hasOwnProperty(k) &&\n        !EMITTER_PROPS.has(k) &&\n        typeof this[k] !== 'function' &&\n        typeof k !== 'symbol'\n      )\n        dummy[k] = this[k];\n    }\n\n    dummy.attributes = this._attributes;\n    dummy.nodes = nodes;\n    dummy.edges = edges;\n\n    privateProperty(dummy, 'constructor', this.constructor);\n\n    return dummy;\n  }\n}\n\n/**\n * Attaching methods to the prototype.\n *\n * Here, we are attaching a wide variety of methods to the Graph class'\n * prototype when those are very numerous and when their creation is\n * abstracted.\n */\n\n/**\n * Attaching custom inspect method for node >= 10.\n */\nif (typeof Symbol !== 'undefined')\n  Graph.prototype[Symbol.for('nodejs.util.inspect.custom')] =\n    Graph.prototype.inspect;\n\n/**\n * Related to edge addition.\n */\nEDGE_ADD_METHODS.forEach(method => {\n  ['add', 'merge', 'update'].forEach(verb => {\n    const name = method.name(verb);\n    const fn = verb === 'add' ? addEdge : mergeEdge;\n\n    if (method.generateKey) {\n      Graph.prototype[name] = function (source, target, attributes) {\n        return fn(\n          this,\n          name,\n          true,\n          (method.type || this.type) === 'undirected',\n          null,\n          source,\n          target,\n          attributes,\n          verb === 'update'\n        );\n      };\n    } else {\n      Graph.prototype[name] = function (edge, source, target, attributes) {\n        return fn(\n          this,\n          name,\n          false,\n          (method.type || this.type) === 'undirected',\n          edge,\n          source,\n          target,\n          attributes,\n          verb === 'update'\n        );\n      };\n    }\n  });\n});\n\n/**\n * Attributes-related.\n */\nattachNodeAttributesMethods(Graph);\nattachEdgeAttributesMethods(Graph);\n\n/**\n * Edge iteration-related.\n */\nattachEdgeIterationMethods(Graph);\n\n/**\n * Neighbor iteration-related.\n */\nattachNeighborIterationMethods(Graph);\n", "/**\n * Graphology Helper Classes\n * ==========================\n *\n * Building some higher-order classes instantiating the graph with\n * predefinite options.\n */\nimport {assign} from './utils';\nimport Graph from './graph';\n\nimport {\n  InvalidArgumentsGraphError,\n  NotFoundGraphError,\n  UsageGraphError\n} from './errors';\n\n/**\n * Alternative constructors.\n */\nclass DirectedGraph extends Graph {\n  constructor(options) {\n    const finalOptions = assign({type: 'directed'}, options);\n\n    if ('multi' in finalOptions && finalOptions.multi !== false)\n      throw new InvalidArgumentsGraphError(\n        'DirectedGraph.from: inconsistent indication that the graph should be multi in given options!'\n      );\n\n    if (finalOptions.type !== 'directed')\n      throw new InvalidArgumentsGraphError(\n        'DirectedGraph.from: inconsistent \"' +\n          finalOptions.type +\n          '\" type in given options!'\n      );\n\n    super(finalOptions);\n  }\n}\nclass UndirectedGraph extends Graph {\n  constructor(options) {\n    const finalOptions = assign({type: 'undirected'}, options);\n\n    if ('multi' in finalOptions && finalOptions.multi !== false)\n      throw new InvalidArgumentsGraphError(\n        'UndirectedGraph.from: inconsistent indication that the graph should be multi in given options!'\n      );\n\n    if (finalOptions.type !== 'undirected')\n      throw new InvalidArgumentsGraphError(\n        'UndirectedGraph.from: inconsistent \"' +\n          finalOptions.type +\n          '\" type in given options!'\n      );\n\n    super(finalOptions);\n  }\n}\nclass MultiGraph extends Graph {\n  constructor(options) {\n    const finalOptions = assign({multi: true}, options);\n\n    if ('multi' in finalOptions && finalOptions.multi !== true)\n      throw new InvalidArgumentsGraphError(\n        'MultiGraph.from: inconsistent indication that the graph should be simple in given options!'\n      );\n\n    super(finalOptions);\n  }\n}\nclass MultiDirectedGraph extends Graph {\n  constructor(options) {\n    const finalOptions = assign({type: 'directed', multi: true}, options);\n\n    if ('multi' in finalOptions && finalOptions.multi !== true)\n      throw new InvalidArgumentsGraphError(\n        'MultiDirectedGraph.from: inconsistent indication that the graph should be simple in given options!'\n      );\n\n    if (finalOptions.type !== 'directed')\n      throw new InvalidArgumentsGraphError(\n        'MultiDirectedGraph.from: inconsistent \"' +\n          finalOptions.type +\n          '\" type in given options!'\n      );\n\n    super(finalOptions);\n  }\n}\nclass MultiUndirectedGraph extends Graph {\n  constructor(options) {\n    const finalOptions = assign({type: 'undirected', multi: true}, options);\n\n    if ('multi' in finalOptions && finalOptions.multi !== true)\n      throw new InvalidArgumentsGraphError(\n        'MultiUndirectedGraph.from: inconsistent indication that the graph should be simple in given options!'\n      );\n\n    if (finalOptions.type !== 'undirected')\n      throw new InvalidArgumentsGraphError(\n        'MultiUndirectedGraph.from: inconsistent \"' +\n          finalOptions.type +\n          '\" type in given options!'\n      );\n\n    super(finalOptions);\n  }\n}\n\n/**\n * Attaching static #.from method to each of the constructors.\n */\nfunction attachStaticFromMethod(Class) {\n  /**\n   * Builds a graph from serialized data or another graph's data.\n   *\n   * @param  {Graph|SerializedGraph} data      - Hydratation data.\n   * @param  {object}                [options] - Options.\n   * @return {Class}\n   */\n  Class.from = function (data, options) {\n    // Merging given options with serialized ones\n    const finalOptions = assign({}, data.options, options);\n\n    const instance = new Class(finalOptions);\n    instance.import(data);\n\n    return instance;\n  };\n}\n\nattachStaticFromMethod(Graph);\nattachStaticFromMethod(DirectedGraph);\nattachStaticFromMethod(UndirectedGraph);\nattachStaticFromMethod(MultiGraph);\nattachStaticFromMethod(MultiDirectedGraph);\nattachStaticFromMethod(MultiUndirectedGraph);\n\nGraph.Graph = Graph;\nGraph.DirectedGraph = DirectedGraph;\nGraph.UndirectedGraph = UndirectedGraph;\nGraph.MultiGraph = MultiGraph;\nGraph.MultiDirectedGraph = MultiDirectedGraph;\nGraph.MultiUndirectedGraph = MultiUndirectedGraph;\n\nGraph.InvalidArgumentsGraphError = InvalidArgumentsGraphError;\nGraph.NotFoundGraphError = NotFoundGraphError;\nGraph.UsageGraphError = UsageGraphError;\n\nexport {\n  Graph,\n  DirectedGraph,\n  UndirectedGraph,\n  MultiGraph,\n  MultiDirectedGraph,\n  MultiUndirectedGraph\n};\n", "/**\n * Graphology ESM Endoint\n * =======================\n *\n * Endpoint for ESM modules consumers.\n */\nimport {\n  Graph,\n  DirectedGraph,\n  UndirectedGraph,\n  MultiGraph,\n  MultiDirectedGraph,\n  MultiUndirectedGraph\n} from './classes';\n\nimport {\n  InvalidArgumentsGraphError,\n  NotFoundGraphError,\n  UsageGraphError\n} from './errors';\n\nexport default Graph;\n\nexport {\n  Graph,\n  DirectedGraph,\n  UndirectedGraph,\n  MultiGraph,\n  MultiDirectedGraph,\n  MultiUndirectedGraph,\n  InvalidArgumentsGraphError,\n  NotFoundGraphError,\n  UsageGraphError\n};\n"],
  "mappings": ";;;;;;;;;AAAA;AAAA;AAaA,aAASA,UAAS,MAAM;AACtB,UAAI,OAAO,SAAS;AAClB,cAAM,IAAI,MAAM,6CAA6C;AAE/D,WAAK,OAAO;AAAA,IACd;AAKA,QAAI,OAAO,WAAW;AACpB,MAAAA,UAAS,UAAU,OAAO,QAAQ,IAAI,WAAY;AAChD,eAAO;AAAA,MACT;AAQF,IAAAA,UAAS,KAAK,WAAY;AACxB,UAAI,OAAO,WACT,IAAI,KAAK,QACT,IAAI;AAEN,aAAO,IAAIA,UAAS,WAAY;AAC9B,YAAI,KAAK;AAAG,iBAAO,EAAC,MAAM,KAAI;AAE9B,eAAO,EAAC,MAAM,OAAO,OAAO,KAAK,GAAG,EAAC;AAAA,MACvC,CAAC;AAAA,IACH;AAOA,IAAAA,UAAS,QAAQ,WAAY;AAC3B,UAAI,WAAW,IAAIA,UAAS,WAAY;AACtC,eAAO,EAAC,MAAM,KAAI;AAAA,MACpB,CAAC;AAED,aAAO;AAAA,IACT;AAQA,IAAAA,UAAS,eAAe,SAAU,UAAU;AAC1C,UAAI,IAAI,GACN,IAAI,SAAS;AAEf,aAAO,IAAIA,UAAS,WAAY;AAC9B,YAAI,KAAK;AAAG,iBAAO,EAAC,MAAM,KAAI;AAE9B,eAAO,EAAC,MAAM,OAAO,OAAO,SAAS,GAAG,EAAC;AAAA,MAC3C,CAAC;AAAA,IACH;AAQA,IAAAA,UAAS,KAAK,SAAU,OAAO;AAC7B,UAAI,iBAAiBA;AAAU,eAAO;AAEtC,aACE,OAAO,UAAU,YACjB,UAAU,QACV,OAAO,MAAM,SAAS;AAAA,IAE1B;AAKA,WAAO,UAAUA;AAAA;AAAA;;;AC/FjB;AAAA;AAAA,YAAQ,uBAAuB,OAAO,gBAAgB;AACtD,YAAQ,iBAAiB,OAAO,WAAW;AAAA;AAAA;;;ACD3C;AAAA;AAOA,QAAIC,YAAW;AACf,QAAI,UAAU;AAEd,QAAI,uBAAuB,QAAQ;AACnC,QAAI,iBAAiB,QAAQ;AAE7B,aAAS,WAAW,QAAQ;AAE1B,UACE,OAAO,WAAW,YAClB,MAAM,QAAQ,MAAM,KACnB,wBAAwB,YAAY,OAAO,MAAM;AAElD,eAAOA,UAAS,aAAa,MAAM;AAGrC,UAAI,OAAO,WAAW,YAAY,WAAW;AAAM,eAAO;AAG1D,UAAI,kBAAkB,OAAO,OAAO,OAAO,QAAQ,MAAM;AACvD,eAAO,OAAO,OAAO,QAAQ,EAAE;AAGjC,UAAI,OAAO,OAAO,SAAS;AAAY,eAAO;AAG9C,aAAO;AAAA,IACT;AAEA,WAAO,UAAU,SAAS,KAAK,QAAQ;AACrC,UAAI,WAAW,WAAW,MAAM;AAEhC,UAAI,CAAC;AACH,cAAM,IAAI;AAAA,UACR;AAAA,QACF;AAEF,aAAO;AAAA,IACT;AAAA;AAAA;;;AC7CA;AAAA;AAQA,QAAI,OAAO;AASX,WAAO,UAAU,SAASC,MAAK,UAAU,GAAG;AAC1C,UAAI,IAAI,UAAU,SAAS,IAAI,IAAI,UACjC,QAAQ,MAAM,WAAW,IAAI,MAAM,CAAC,IAAI,CAAC,GACzC,MACA,IAAI;AAEN,UAAI,WAAW,KAAK,QAAQ;AAE5B,aAAO,MAAM;AACX,YAAI,MAAM;AAAG,iBAAO;AAEpB,eAAO,SAAS,KAAK;AAErB,YAAI,KAAK,MAAM;AACb,cAAI,MAAM;AAAG,kBAAM,SAAS;AAE5B,iBAAO;AAAA,QACT;AAEA,cAAM,GAAG,IAAI,KAAK;AAAA,MACpB;AAAA,IACF;AAAA;AAAA;;;ACtCA;AAAA;AAMA,QAAIC,YAAW;AACf,QAAI,OAAO;AAQX,WAAO,UAAU,SAASC,SAAQ;AAChC,UAAI,YAAY;AAChB,UAAI,UAAU;AACd,UAAI,IAAI;AAGR,aAAO,IAAID,UAAS,SAAS,OAAO;AAClC,YAAI,OAAO;AAEX,WAAG;AACD,cAAI,YAAY,MAAM;AACpB;AAEA,gBAAI,KAAK,UAAU;AAAQ,qBAAO,EAAC,MAAM,KAAI;AAE7C,sBAAU,KAAK,UAAU,CAAC,CAAC;AAAA,UAC7B;AAEA,iBAAO,QAAQ,KAAK;AAEpB,cAAI,KAAK,SAAS,MAAM;AACtB,sBAAU;AACV;AAAA,UACF;AAEA;AAAA,QACF,SAAS;AAET,eAAO;AAAA,MACT,CAAC;AAAA,IACH;AAAA;AAAA;;;;;;;AC/BA,SAAS,iBAAiB;AACxB,QAAM,SAAS,UAAU,CAAC;AAE1B,WAAS,IAAI,GAAG,IAAI,UAAU,QAAQ,IAAI,GAAG,KAAK;AAChD,QAAI,CAAC,UAAU,CAAC;AAAG;AAEnB,eAAW,KAAK,UAAU,CAAC;AAAG,aAAO,CAAC,IAAI,UAAU,CAAC,EAAE,CAAC;EAC5D;AAEE,SAAO;AACT;AAEA,IAAI,SAAS;AAEb,IAAI,OAAO,OAAO,WAAW;AAAY,WAAS,OAAO;AAelD,SAAS,gBAAgB,OAAO,QAAQ,QAAQ,MAAM;AAC3D,QAAM,aAAa,MAAM,OAAO,IAAI,MAAM;AAE1C,MAAI,OAAO;AAEX,MAAI,CAAC;AAAY,WAAO;AAExB,MAAI,SAAS,SAAS;AACpB,WACG,WAAW,OAAO,WAAW,IAAI,MAAM,KACvC,WAAW,cAAc,WAAW,WAAW,MAAM;EAC5D,WAAa,SAAS,YAAY;AAC9B,WAAO,WAAW,OAAO,WAAW,IAAI,MAAM;EAClD,OAAS;AACL,WAAO,WAAW,cAAc,WAAW,WAAW,MAAM;EAChE;AAEE,SAAO;AACT;AAQO,SAAS,cAAc,OAAO;AACnC,SACE,OAAO,UAAU,YAAY,UAAU,QAAQ,MAAM,gBAAgB;AAEzE;AAQO,SAAS,QAAQ,GAAG;AACzB,MAAI;AAEJ,OAAK,KAAK;AAAG,WAAO;AAEpB,SAAO;AACT;AASO,SAAS,gBAAgB,QAAQ,MAAM,OAAO;AACnD,SAAO,eAAe,QAAQ,MAAM;IAClC,YAAY;IACZ,cAAc;IACd,UAAU;IACV;EACJ,CAAG;AACH;AASO,SAAS,iBAAiB,QAAQ,MAAM,OAAO;AACpD,QAAM,aAAa;IACjB,YAAY;IACZ,cAAc;EAClB;AAEE,MAAI,OAAO,UAAU,YAAY;AAC/B,eAAW,MAAM;EACrB,OAAS;AACL,eAAW,QAAQ;AACnB,eAAW,WAAW;EAC1B;AAEE,SAAO,eAAe,QAAQ,MAAM,UAAU;AAChD;AAOO,SAAS,cAAc,OAAO;AACnC,MAAI,CAAC,cAAc,KAAK;AAAG,WAAO;AAElC,MAAI,MAAM,cAAc,CAAC,MAAM,QAAQ,MAAM,UAAU;AAAG,WAAO;AAEjE,SAAO;AACT;AAOO,SAAS,sCAAsC;AACpD,MAAI,IAAI,KAAK,MAAM,KAAK,OAAM,IAAK,GAAG,IAAI;AAE1C,SAAO,MAAM;AACX,WAAO;EACX;AACA;AChJO,IAAM,aAAN,cAAyB,MAAM;EACpC,YAAY,SAAS;AACnB,UAAK;AACL,SAAK,OAAO;AACZ,SAAK,UAAU;EACnB;AACA;AAEO,IAAM,6BAAN,cAAyC,WAAW;EACzD,YAAY,SAAS;AACnB,UAAM,OAAO;AACb,SAAK,OAAO;AAGZ,QAAI,OAAO,MAAM,sBAAsB;AACrC,YAAM;QACJ;QACA,2BAA2B,UAAU;MAC7C;EACA;AACA;AAEO,IAAM,qBAAN,cAAiC,WAAW;EACjD,YAAY,SAAS;AACnB,UAAM,OAAO;AACb,SAAK,OAAO;AAGZ,QAAI,OAAO,MAAM,sBAAsB;AACrC,YAAM,kBAAkB,MAAM,mBAAmB,UAAU,WAAW;EAC5E;AACA;AAEO,IAAM,kBAAN,cAA8B,WAAW;EAC9C,YAAY,SAAS;AACnB,UAAM,OAAO;AACb,SAAK,OAAO;AAGZ,QAAI,OAAO,MAAM,sBAAsB;AACrC,YAAM,kBAAkB,MAAM,gBAAgB,UAAU,WAAW;EACzE;AACA;AChCO,SAAS,cAAc,KAAK,YAAY;AAE7C,OAAK,MAAM;AACX,OAAK,aAAa;AAElB,OAAK,MAAK;AACZ;AAEA,cAAc,UAAU,QAAQ,WAAY;AAE1C,OAAK,WAAW;AAChB,OAAK,YAAY;AACjB,OAAK,mBAAmB;AACxB,OAAK,kBAAkB;AACvB,OAAK,gBAAgB;AAGrB,OAAK,KAAK,CAAA;AACV,OAAK,MAAM,CAAA;AACX,OAAK,aAAa,CAAA;AACpB;AASO,SAAS,iBAAiB,KAAK,YAAY;AAEhD,OAAK,MAAM;AACX,OAAK,aAAa;AAElB,OAAK,MAAK;AACZ;AAEA,iBAAiB,UAAU,QAAQ,WAAY;AAE7C,OAAK,WAAW;AAChB,OAAK,YAAY;AACjB,OAAK,gBAAgB;AAGrB,OAAK,KAAK,CAAA;AACV,OAAK,MAAM,CAAA;AACb;AASO,SAAS,mBAAmB,KAAK,YAAY;AAElD,OAAK,MAAM;AACX,OAAK,aAAa;AAElB,OAAK,MAAK;AACZ;AAEA,mBAAmB,UAAU,QAAQ,WAAY;AAE/C,OAAK,mBAAmB;AACxB,OAAK,kBAAkB;AAGvB,OAAK,aAAa,CAAA;AACpB;AAYO,SAAS,SAAS,YAAY,KAAK,QAAQ,QAAQ,YAAY;AAEpE,OAAK,MAAM;AACX,OAAK,aAAa;AAClB,OAAK,aAAa;AAGlB,OAAK,SAAS;AACd,OAAK,SAAS;AAChB;AAEA,SAAS,UAAU,SAAS,WAAY;AACtC,MAAI,SAAS;AACb,MAAI,QAAQ;AAEZ,MAAI,KAAK;AAAY,aAAS,QAAQ;AAEtC,QAAM,SAAS,KAAK,OAAO;AAC3B,QAAM,SAAS,KAAK,OAAO;AAG3B,OAAK,OAAO,MAAM,EAAE,MAAM,IAAI;AAE9B,MAAI,KAAK,cAAc,WAAW;AAAQ;AAG1C,OAAK,OAAO,KAAK,EAAE,MAAM,IAAI;AAC/B;AAEA,SAAS,UAAU,cAAc,WAAY;AAC3C,MAAI,SAAS;AACb,MAAI,QAAQ;AAEZ,QAAM,SAAS,KAAK,OAAO;AAC3B,QAAM,SAAS,KAAK,OAAO;AAE3B,MAAI,KAAK;AAAY,aAAS,QAAQ;AAGtC,QAAM,MAAM,KAAK,OAAO,MAAM;AAC9B,QAAM,OAAO,IAAI,MAAM;AAEvB,MAAI,OAAO,SAAS,aAAa;AAC/B,QAAI,MAAM,IAAI;AAGd,QAAI,EAAE,KAAK,cAAc,WAAW,SAAS;AAE3C,WAAK,OAAO,KAAK,EAAE,MAAM,IAAI;IACnC;AAEI;EACJ;AAGE,OAAK,WAAW;AAChB,OAAK,OAAO;AAIZ,MAAI,MAAM,IAAI;AACd,OAAK,OAAO,KAAK,EAAE,MAAM,IAAI;AAC/B;AAEA,SAAS,UAAU,SAAS,WAAY;AACtC,QAAM,SAAS,KAAK,OAAO;AAC3B,QAAM,SAAS,KAAK,OAAO;AAE3B,MAAI,SAAS;AACb,MAAI,QAAQ;AAEZ,MAAI,KAAK;AAAY,aAAS,QAAQ;AAEtC,SAAO,KAAK,OAAO,MAAM,EAAE,MAAM;AAGjC,SAAO,KAAK,OAAO,KAAK,EAAE,MAAM;AAClC;AAEA,SAAS,UAAU,cAAc,WAAY;AAC3C,QAAM,SAAS,KAAK,OAAO;AAC3B,QAAM,SAAS,KAAK,OAAO;AAE3B,MAAI,SAAS;AACb,MAAI,QAAQ;AAEZ,MAAI,KAAK;AAAY,aAAS,QAAQ;AAGtC,MAAI,KAAK,aAAa,QAAW;AAI/B,QAAI,KAAK,SAAS,QAAW;AAC3B,aAAO,KAAK,OAAO,MAAM,EAAE,MAAM;AAGjC,aAAO,KAAK,OAAO,KAAK,EAAE,MAAM;IACtC,OAAW;AAEL,WAAK,KAAK,WAAW;AAGrB,WAAK,OAAO,MAAM,EAAE,MAAM,IAAI,KAAK;AAGnC,WAAK,OAAO,KAAK,EAAE,MAAM,IAAI,KAAK;IACxC;EACA,OAAS;AAEL,SAAK,SAAS,OAAO,KAAK;AAG1B,QAAI,KAAK,SAAS,QAAW;AAC3B,WAAK,KAAK,WAAW,KAAK;IAChC;EACA;AACA;ACjNA,IAAM,OAAO;AACb,IAAM,SAAS;AACf,IAAM,SAAS;AACf,IAAM,WAAW;AAEjB,SAAS,qBACP,OACA,QACA,MACA,YACA,YACA,MACA,MACA;AACA,MAAI,UAAU,UAAU,MAAM;AAE9B,eAAa,KAAK;AAElB,MAAI,SAAS,MAAM;AACjB,eAAW,MAAM,OAAO,IAAI,UAAU;AAEtC,QAAI,CAAC;AACH,YAAM,IAAI;QACR,SAAS,+BAA+B;MAChD;AAEI,WAAO;AACP,WAAO;EACX,WAAa,SAAS,UAAU;AAC5B,iBAAa,KAAK;AAElB,eAAW,MAAM,OAAO,IAAI,UAAU;AAEtC,QAAI,CAAC;AACH,YAAM,IAAI;QACR,SAAS,+BAA+B;MAChD;AAEI,UAAM,SAAS,SAAS,OAAO;AAC/B,UAAM,SAAS,SAAS,OAAO;AAE/B,QAAI,eAAe,QAAQ;AACzB,iBAAW,SAAS;IAC1B,WAAe,eAAe,QAAQ;AAChC,iBAAW,SAAS;IAC1B,OAAW;AACL,YAAM,IAAI;QACR,SAAS,gBAAgB,4CAA4C,qBAAqB,WAAW;MAC7G;IACA;AAEI,WAAO;AACP,WAAO;EACX,OAAS;AACL,eAAW,MAAM,OAAO,IAAI,UAAU;AAEtC,QAAI,CAAC;AACH,YAAM,IAAI;QACR,SAAS,+BAA+B;MAChD;AAEI,QAAI,SAAS,QAAQ;AACnB,iBAAW,SAAS;IAC1B,OAAW;AACL,iBAAW,SAAS;IAC1B;AAEI,WAAO;AACP,WAAO;EACX;AAEE,SAAO,CAAC,UAAU,MAAM,IAAI;AAC9B;AAEA,SAAS,0BAA0B,OAAO,QAAQ,MAAM;AACtD,QAAM,UAAU,MAAM,IAAI,SAAU,YAAY,YAAY,MAAM;AAChE,UAAM,CAAC,MAAM,IAAI,IAAI;MACnB;MACA;MACA;MACA;MACA;MACA;IACN;AAEI,WAAO,KAAK,WAAW,IAAI;EAC/B;AACA;AAEA,SAAS,2BAA2B,OAAO,QAAQ,MAAM;AACvD,QAAM,UAAU,MAAM,IAAI,SAAU,YAAY,YAAY;AAC1D,UAAM,CAAC,IAAI,IAAI;MACb;MACA;MACA;MACA;MACA;IACN;AAEI,WAAO,KAAK;EAChB;AACA;AAEA,SAAS,2BAA2B,OAAO,QAAQ,MAAM;AACvD,QAAM,UAAU,MAAM,IAAI,SAAU,YAAY,YAAY,MAAM;AAChE,UAAM,CAAC,MAAM,IAAI,IAAI;MACnB;MACA;MACA;MACA;MACA;MACA;IACN;AAEI,WAAO,KAAK,WAAW,eAAe,IAAI;EAC9C;AACA;AAEA,SAAS,0BAA0B,OAAO,QAAQ,MAAM;AACtD,QAAM,UAAU,MAAM,IAAI,SAAU,YAAY,YAAY,MAAM,MAAM;AACtE,UAAM,CAAC,MAAM,MAAM,KAAK,IAAI;MAC1B;MACA;MACA;MACA;MACA;MACA;MACA;IACN;AAEI,SAAK,WAAW,IAAI,IAAI;AAGxB,SAAK,KAAK,yBAAyB;MACjC,KAAK,KAAK;MACV,MAAM;MACN,YAAY,KAAK;MACjB;IACN,CAAK;AAED,WAAO;EACX;AACA;AAEA,SAAS,2BAA2B,OAAO,QAAQ,MAAM;AACvD,QAAM,UAAU,MAAM,IAAI,SAAU,YAAY,YAAY,MAAM,MAAM;AACtE,UAAM,CAAC,MAAM,MAAM,OAAO,IAAI;MAC5B;MACA;MACA;MACA;MACA;MACA;MACA;IACN;AAEI,QAAI,OAAO,YAAY;AACrB,YAAM,IAAI;QACR,SAAS;MACjB;AAEI,UAAM,aAAa,KAAK;AACxB,UAAM,QAAQ,QAAQ,WAAW,IAAI,CAAC;AAEtC,eAAW,IAAI,IAAI;AAGnB,SAAK,KAAK,yBAAyB;MACjC,KAAK,KAAK;MACV,MAAM;MACN,YAAY,KAAK;MACjB;IACN,CAAK;AAED,WAAO;EACX;AACA;AAEA,SAAS,2BAA2B,OAAO,QAAQ,MAAM;AACvD,QAAM,UAAU,MAAM,IAAI,SAAU,YAAY,YAAY,MAAM;AAChE,UAAM,CAAC,MAAM,IAAI,IAAI;MACnB;MACA;MACA;MACA;MACA;MACA;IACN;AAEI,WAAO,KAAK,WAAW,IAAI;AAG3B,SAAK,KAAK,yBAAyB;MACjC,KAAK,KAAK;MACV,MAAM;MACN,YAAY,KAAK;MACjB;IACN,CAAK;AAED,WAAO;EACX;AACA;AAEA,SAAS,6BAA6B,OAAO,QAAQ,MAAM;AACzD,QAAM,UAAU,MAAM,IAAI,SAAU,YAAY,YAAY,MAAM;AAChE,UAAM,CAAC,MAAM,UAAU,IAAI;MACzB;MACA;MACA;MACA;MACA;MACA;IACN;AAEI,QAAI,CAAC,cAAc,UAAU;AAC3B,YAAM,IAAI;QACR,SAAS;MACjB;AAEI,SAAK,aAAa;AAGlB,SAAK,KAAK,yBAAyB;MACjC,KAAK,KAAK;MACV,MAAM;MACN,YAAY,KAAK;IACvB,CAAK;AAED,WAAO;EACX;AACA;AAEA,SAAS,2BAA2B,OAAO,QAAQ,MAAM;AACvD,QAAM,UAAU,MAAM,IAAI,SAAU,YAAY,YAAY,MAAM;AAChE,UAAM,CAAC,MAAM,UAAU,IAAI;MACzB;MACA;MACA;MACA;MACA;MACA;IACN;AAEI,QAAI,CAAC,cAAc,UAAU;AAC3B,YAAM,IAAI;QACR,SAAS;MACjB;AAEI,WAAO,KAAK,YAAY,UAAU;AAGlC,SAAK,KAAK,yBAAyB;MACjC,KAAK,KAAK;MACV,MAAM;MACN,YAAY,KAAK;MACjB,MAAM;IACZ,CAAK;AAED,WAAO;EACX;AACA;AAEA,SAAS,4BAA4B,OAAO,QAAQ,MAAM;AACxD,QAAM,UAAU,MAAM,IAAI,SAAU,YAAY,YAAY,MAAM;AAChE,UAAM,CAAC,MAAM,OAAO,IAAI;MACtB;MACA;MACA;MACA;MACA;MACA;IACN;AAEI,QAAI,OAAO,YAAY;AACrB,YAAM,IAAI;QACR,SAAS;MACjB;AAEI,SAAK,aAAa,QAAQ,KAAK,UAAU;AAGzC,SAAK,KAAK,yBAAyB;MACjC,KAAK,KAAK;MACV,MAAM;MACN,YAAY,KAAK;IACvB,CAAK;AAED,WAAO;EACX;AACA;AAKA,IAAM,0BAA0B;EAC9B;IACE,MAAM,aAAW,MAAM;IACvB,UAAU;EACd;EACE;IACE,MAAM,aAAW,MAAM;IACvB,UAAU;EACd;EACE;IACE,MAAM,aAAW,MAAM;IACvB,UAAU;EACd;EACE;IACE,MAAM,aAAW,MAAM;IACvB,UAAU;EACd;EACE;IACE,MAAM,aAAW,SAAS;IAC1B,UAAU;EACd;EACE;IACE,MAAM,aAAW,SAAS;IAC1B,UAAU;EACd;EACE;IACE,MAAM,aAAW,UAAU;IAC3B,UAAU;EACd;EACE;IACE,MAAM,aAAW,QAAQ;IACzB,UAAU;EACd;EACE;IACE,MAAM,aAAW,SAAS;IAC1B,UAAU;EACd;AACA;AAOe,SAAS,4BAA4BE,QAAO;AACzD,0BAAwB,QAAQ,SAAU,EAAC,MAAM,SAAQ,GAAG;AAE1D,aAASA,QAAO,KAAK,MAAM,GAAG,IAAI;AAGlC,aAASA,QAAO,KAAK,QAAQ,GAAG,MAAM;AAGtC,aAASA,QAAO,KAAK,QAAQ,GAAG,MAAM;AAGtC,aAASA,QAAO,KAAK,UAAU,GAAG,QAAQ;EAC9C,CAAG;AACH;ACrVA,SAAS,0BAA0B,OAAO,QAAQ,MAAM;AAkBtD,QAAM,UAAU,MAAM,IAAI,SAAU,SAAS,MAAM;AACjD,QAAI;AAEJ,QAAI,KAAK,SAAS,WAAW,SAAS,WAAW,SAAS,KAAK;AAC7D,YAAM,IAAI;QACR,SAAS,kDAAkD,KAAK;MACxE;AAEI,QAAI,UAAU,SAAS,GAAG;AACxB,UAAI,KAAK;AACP,cAAM,IAAI;UACR,SAAS;QACnB;AAEM,YAAM,SAAS,KAAK;AACpB,YAAM,SAAS,KAAK;AAEpB,aAAO,UAAU,CAAC;AAElB,aAAO,gBAAgB,MAAM,QAAQ,QAAQ,IAAI;AAEjD,UAAI,CAAC;AACH,cAAM,IAAI;UACR,SAAS,uDAAuD,cAAc;QACxF;IACA,OAAW;AACL,UAAI,SAAS;AACX,cAAM,IAAI;UACR,SAAS;QACnB;AAEM,gBAAU,KAAK;AACf,aAAO,KAAK,OAAO,IAAI,OAAO;AAE9B,UAAI,CAAC;AACH,cAAM,IAAI;UACR,SAAS,+BAA+B;QAClD;IACA;AAEI,WAAO,KAAK,WAAW,IAAI;EAC/B;AACA;AASA,SAAS,2BAA2B,OAAO,QAAQ,MAAM;AAgBvD,QAAM,UAAU,MAAM,IAAI,SAAU,SAAS;AAC3C,QAAI;AAEJ,QAAI,KAAK,SAAS,WAAW,SAAS,WAAW,SAAS,KAAK;AAC7D,YAAM,IAAI;QACR,SAAS,kDAAkD,KAAK;MACxE;AAEI,QAAI,UAAU,SAAS,GAAG;AACxB,UAAI,KAAK;AACP,cAAM,IAAI;UACR,SAAS;QACnB;AAEM,YAAM,SAAS,KAAK,SAClB,SAAS,KAAK,UAAU,CAAC;AAE3B,aAAO,gBAAgB,MAAM,QAAQ,QAAQ,IAAI;AAEjD,UAAI,CAAC;AACH,cAAM,IAAI;UACR,SAAS,uDAAuD,cAAc;QACxF;IACA,OAAW;AACL,UAAI,SAAS;AACX,cAAM,IAAI;UACR,SAAS;QACnB;AAEM,gBAAU,KAAK;AACf,aAAO,KAAK,OAAO,IAAI,OAAO;AAE9B,UAAI,CAAC;AACH,cAAM,IAAI;UACR,SAAS,+BAA+B;QAClD;IACA;AAEI,WAAO,KAAK;EAChB;AACA;AASA,SAAS,2BAA2B,OAAO,QAAQ,MAAM;AAkBvD,QAAM,UAAU,MAAM,IAAI,SAAU,SAAS,MAAM;AACjD,QAAI;AAEJ,QAAI,KAAK,SAAS,WAAW,SAAS,WAAW,SAAS,KAAK;AAC7D,YAAM,IAAI;QACR,SAAS,kDAAkD,KAAK;MACxE;AAEI,QAAI,UAAU,SAAS,GAAG;AACxB,UAAI,KAAK;AACP,cAAM,IAAI;UACR,SAAS;QACnB;AAEM,YAAM,SAAS,KAAK;AACpB,YAAM,SAAS,KAAK;AAEpB,aAAO,UAAU,CAAC;AAElB,aAAO,gBAAgB,MAAM,QAAQ,QAAQ,IAAI;AAEjD,UAAI,CAAC;AACH,cAAM,IAAI;UACR,SAAS,uDAAuD,cAAc;QACxF;IACA,OAAW;AACL,UAAI,SAAS;AACX,cAAM,IAAI;UACR,SAAS;QACnB;AAEM,gBAAU,KAAK;AACf,aAAO,KAAK,OAAO,IAAI,OAAO;AAE9B,UAAI,CAAC;AACH,cAAM,IAAI;UACR,SAAS,+BAA+B;QAClD;IACA;AAEI,WAAO,KAAK,WAAW,eAAe,IAAI;EAC9C;AACA;AASA,SAAS,0BAA0B,OAAO,QAAQ,MAAM;AAoBtD,QAAM,UAAU,MAAM,IAAI,SAAU,SAAS,MAAM,OAAO;AACxD,QAAI;AAEJ,QAAI,KAAK,SAAS,WAAW,SAAS,WAAW,SAAS,KAAK;AAC7D,YAAM,IAAI;QACR,SAAS,kDAAkD,KAAK;MACxE;AAEI,QAAI,UAAU,SAAS,GAAG;AACxB,UAAI,KAAK;AACP,cAAM,IAAI;UACR,SAAS;QACnB;AAEM,YAAM,SAAS,KAAK;AACpB,YAAM,SAAS,KAAK;AAEpB,aAAO,UAAU,CAAC;AAClB,cAAQ,UAAU,CAAC;AAEnB,aAAO,gBAAgB,MAAM,QAAQ,QAAQ,IAAI;AAEjD,UAAI,CAAC;AACH,cAAM,IAAI;UACR,SAAS,uDAAuD,cAAc;QACxF;IACA,OAAW;AACL,UAAI,SAAS;AACX,cAAM,IAAI;UACR,SAAS;QACnB;AAEM,gBAAU,KAAK;AACf,aAAO,KAAK,OAAO,IAAI,OAAO;AAE9B,UAAI,CAAC;AACH,cAAM,IAAI;UACR,SAAS,+BAA+B;QAClD;IACA;AAEI,SAAK,WAAW,IAAI,IAAI;AAGxB,SAAK,KAAK,yBAAyB;MACjC,KAAK,KAAK;MACV,MAAM;MACN,YAAY,KAAK;MACjB;IACN,CAAK;AAED,WAAO;EACX;AACA;AASA,SAAS,2BAA2B,OAAO,QAAQ,MAAM;AAqBvD,QAAM,UAAU,MAAM,IAAI,SAAU,SAAS,MAAM,SAAS;AAC1D,QAAI;AAEJ,QAAI,KAAK,SAAS,WAAW,SAAS,WAAW,SAAS,KAAK;AAC7D,YAAM,IAAI;QACR,SAAS,kDAAkD,KAAK;MACxE;AAEI,QAAI,UAAU,SAAS,GAAG;AACxB,UAAI,KAAK;AACP,cAAM,IAAI;UACR,SAAS;QACnB;AAEM,YAAM,SAAS,KAAK;AACpB,YAAM,SAAS,KAAK;AAEpB,aAAO,UAAU,CAAC;AAClB,gBAAU,UAAU,CAAC;AAErB,aAAO,gBAAgB,MAAM,QAAQ,QAAQ,IAAI;AAEjD,UAAI,CAAC;AACH,cAAM,IAAI;UACR,SAAS,uDAAuD,cAAc;QACxF;IACA,OAAW;AACL,UAAI,SAAS;AACX,cAAM,IAAI;UACR,SAAS;QACnB;AAEM,gBAAU,KAAK;AACf,aAAO,KAAK,OAAO,IAAI,OAAO;AAE9B,UAAI,CAAC;AACH,cAAM,IAAI;UACR,SAAS,+BAA+B;QAClD;IACA;AAEI,QAAI,OAAO,YAAY;AACrB,YAAM,IAAI;QACR,SAAS;MACjB;AAEI,SAAK,WAAW,IAAI,IAAI,QAAQ,KAAK,WAAW,IAAI,CAAC;AAGrD,SAAK,KAAK,yBAAyB;MACjC,KAAK,KAAK;MACV,MAAM;MACN,YAAY,KAAK;MACjB;IACN,CAAK;AAED,WAAO;EACX;AACA;AASA,SAAS,2BAA2B,OAAO,QAAQ,MAAM;AAkBvD,QAAM,UAAU,MAAM,IAAI,SAAU,SAAS,MAAM;AACjD,QAAI;AAEJ,QAAI,KAAK,SAAS,WAAW,SAAS,WAAW,SAAS,KAAK;AAC7D,YAAM,IAAI;QACR,SAAS,kDAAkD,KAAK;MACxE;AAEI,QAAI,UAAU,SAAS,GAAG;AACxB,UAAI,KAAK;AACP,cAAM,IAAI;UACR,SAAS;QACnB;AAEM,YAAM,SAAS,KAAK;AACpB,YAAM,SAAS,KAAK;AAEpB,aAAO,UAAU,CAAC;AAElB,aAAO,gBAAgB,MAAM,QAAQ,QAAQ,IAAI;AAEjD,UAAI,CAAC;AACH,cAAM,IAAI;UACR,SAAS,uDAAuD,cAAc;QACxF;IACA,OAAW;AACL,UAAI,SAAS;AACX,cAAM,IAAI;UACR,SAAS;QACnB;AAEM,gBAAU,KAAK;AACf,aAAO,KAAK,OAAO,IAAI,OAAO;AAE9B,UAAI,CAAC;AACH,cAAM,IAAI;UACR,SAAS,+BAA+B;QAClD;IACA;AAEI,WAAO,KAAK,WAAW,IAAI;AAG3B,SAAK,KAAK,yBAAyB;MACjC,KAAK,KAAK;MACV,MAAM;MACN,YAAY,KAAK;MACjB;IACN,CAAK;AAED,WAAO;EACX;AACA;AASA,SAAS,6BAA6B,OAAO,QAAQ,MAAM;AAkBzD,QAAM,UAAU,MAAM,IAAI,SAAU,SAAS,YAAY;AACvD,QAAI;AAEJ,QAAI,KAAK,SAAS,WAAW,SAAS,WAAW,SAAS,KAAK;AAC7D,YAAM,IAAI;QACR,SAAS,kDAAkD,KAAK;MACxE;AAEI,QAAI,UAAU,SAAS,GAAG;AACxB,UAAI,KAAK;AACP,cAAM,IAAI;UACR,SAAS;QACnB;AAEM,YAAM,SAAS,KAAK,SAClB,SAAS,KAAK;AAEhB,mBAAa,UAAU,CAAC;AAExB,aAAO,gBAAgB,MAAM,QAAQ,QAAQ,IAAI;AAEjD,UAAI,CAAC;AACH,cAAM,IAAI;UACR,SAAS,uDAAuD,cAAc;QACxF;IACA,OAAW;AACL,UAAI,SAAS;AACX,cAAM,IAAI;UACR,SAAS;QACnB;AAEM,gBAAU,KAAK;AACf,aAAO,KAAK,OAAO,IAAI,OAAO;AAE9B,UAAI,CAAC;AACH,cAAM,IAAI;UACR,SAAS,+BAA+B;QAClD;IACA;AAEI,QAAI,CAAC,cAAc,UAAU;AAC3B,YAAM,IAAI;QACR,SAAS;MACjB;AAEI,SAAK,aAAa;AAGlB,SAAK,KAAK,yBAAyB;MACjC,KAAK,KAAK;MACV,MAAM;MACN,YAAY,KAAK;IACvB,CAAK;AAED,WAAO;EACX;AACA;AASA,SAAS,2BAA2B,OAAO,QAAQ,MAAM;AAkBvD,QAAM,UAAU,MAAM,IAAI,SAAU,SAAS,YAAY;AACvD,QAAI;AAEJ,QAAI,KAAK,SAAS,WAAW,SAAS,WAAW,SAAS,KAAK;AAC7D,YAAM,IAAI;QACR,SAAS,kDAAkD,KAAK;MACxE;AAEI,QAAI,UAAU,SAAS,GAAG;AACxB,UAAI,KAAK;AACP,cAAM,IAAI;UACR,SAAS;QACnB;AAEM,YAAM,SAAS,KAAK,SAClB,SAAS,KAAK;AAEhB,mBAAa,UAAU,CAAC;AAExB,aAAO,gBAAgB,MAAM,QAAQ,QAAQ,IAAI;AAEjD,UAAI,CAAC;AACH,cAAM,IAAI;UACR,SAAS,uDAAuD,cAAc;QACxF;IACA,OAAW;AACL,UAAI,SAAS;AACX,cAAM,IAAI;UACR,SAAS;QACnB;AAEM,gBAAU,KAAK;AACf,aAAO,KAAK,OAAO,IAAI,OAAO;AAE9B,UAAI,CAAC;AACH,cAAM,IAAI;UACR,SAAS,+BAA+B;QAClD;IACA;AAEI,QAAI,CAAC,cAAc,UAAU;AAC3B,YAAM,IAAI;QACR,SAAS;MACjB;AAEI,WAAO,KAAK,YAAY,UAAU;AAGlC,SAAK,KAAK,yBAAyB;MACjC,KAAK,KAAK;MACV,MAAM;MACN,YAAY,KAAK;MACjB,MAAM;IACZ,CAAK;AAED,WAAO;EACX;AACA;AASA,SAAS,4BAA4B,OAAO,QAAQ,MAAM;AAkBxD,QAAM,UAAU,MAAM,IAAI,SAAU,SAAS,SAAS;AACpD,QAAI;AAEJ,QAAI,KAAK,SAAS,WAAW,SAAS,WAAW,SAAS,KAAK;AAC7D,YAAM,IAAI;QACR,SAAS,kDAAkD,KAAK;MACxE;AAEI,QAAI,UAAU,SAAS,GAAG;AACxB,UAAI,KAAK;AACP,cAAM,IAAI;UACR,SAAS;QACnB;AAEM,YAAM,SAAS,KAAK,SAClB,SAAS,KAAK;AAEhB,gBAAU,UAAU,CAAC;AAErB,aAAO,gBAAgB,MAAM,QAAQ,QAAQ,IAAI;AAEjD,UAAI,CAAC;AACH,cAAM,IAAI;UACR,SAAS,uDAAuD,cAAc;QACxF;IACA,OAAW;AACL,UAAI,SAAS;AACX,cAAM,IAAI;UACR,SAAS;QACnB;AAEM,gBAAU,KAAK;AACf,aAAO,KAAK,OAAO,IAAI,OAAO;AAE9B,UAAI,CAAC;AACH,cAAM,IAAI;UACR,SAAS,+BAA+B;QAClD;IACA;AAEI,QAAI,OAAO,YAAY;AACrB,YAAM,IAAI;QACR,SAAS;MACjB;AAEI,SAAK,aAAa,QAAQ,KAAK,UAAU;AAGzC,SAAK,KAAK,yBAAyB;MACjC,KAAK,KAAK;MACV,MAAM;MACN,YAAY,KAAK;IACvB,CAAK;AAED,WAAO;EACX;AACA;AAKA,IAAM,0BAA0B;EAC9B;IACE,MAAM,aAAW,MAAM;IACvB,UAAU;EACd;EACE;IACE,MAAM,aAAW,MAAM;IACvB,UAAU;EACd;EACE;IACE,MAAM,aAAW,MAAM;IACvB,UAAU;EACd;EACE;IACE,MAAM,aAAW,MAAM;IACvB,UAAU;EACd;EACE;IACE,MAAM,aAAW,SAAS;IAC1B,UAAU;EACd;EACE;IACE,MAAM,aAAW,SAAS;IAC1B,UAAU;EACd;EACE;IACE,MAAM,aAAW,UAAU;IAC3B,UAAU;EACd;EACE;IACE,MAAM,aAAW,QAAQ;IACzB,UAAU;EACd;EACE;IACE,MAAM,aAAW,SAAS;IAC1B,UAAU;EACd;AACA;AAOe,SAAS,4BAA4BA,QAAO;AACzD,0BAAwB,QAAQ,SAAU,EAAC,MAAM,SAAQ,GAAG;AAE1D,aAASA,QAAO,KAAK,MAAM,GAAG,OAAO;AAGrC,aAASA,QAAO,KAAK,cAAc,GAAG,UAAU;AAGhD,aAASA,QAAO,KAAK,gBAAgB,GAAG,YAAY;EACxD,CAAG;AACH;ACpvBA,IAAM,kBAAkB;EACtB;IACE,MAAM;IACN,MAAM;EACV;EACE;IACE,MAAM;IACN,MAAM;IACN,WAAW;EACf;EACE;IACE,MAAM;IACN,MAAM;IACN,WAAW;EACf;EACE;IACE,MAAM;IACN,MAAM;IACN,WAAW;EACf;EACE;IACE,MAAM;IACN,MAAM;IACN,WAAW;EACf;EACE;IACE,MAAM;IACN,MAAM;EACV;EACE;IACE,MAAM;IACN,MAAM;EACV;AACA;AAQA,SAAS,cAAc,WAAW,QAAQ,UAAU,OAAO;AACzD,MAAI,cAAc;AAElB,aAAW,KAAK,QAAQ;AACtB,QAAI,MAAM;AAAO;AAEjB,UAAM,WAAW,OAAO,CAAC;AAEzB,kBAAc;MACZ,SAAS;MACT,SAAS;MACT,SAAS,OAAO;MAChB,SAAS,OAAO;MAChB,SAAS,OAAO;MAChB,SAAS,OAAO;MAChB,SAAS;IACf;AAEI,QAAI,aAAa;AAAa,aAAO,SAAS;EAClD;AAEE;AACF;AAEA,SAAS,aAAa,WAAW,QAAQ,UAAU,OAAO;AACxD,MAAI,UAAU,QAAQ;AAEtB,MAAI,cAAc;AAElB,aAAW,KAAK,QAAQ;AACtB,QAAI,MAAM;AAAO;AAEjB,eAAW,OAAO,CAAC;AAEnB,OAAG;AACD,eAAS,SAAS;AAClB,eAAS,SAAS;AAElB,oBAAc;QACZ,SAAS;QACT,SAAS;QACT,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,SAAS;MACjB;AAEM,UAAI,aAAa;AAAa,eAAO,SAAS;AAE9C,iBAAW,SAAS;IAC1B,SAAa,aAAa;EAC1B;AAEE;AACF;AAQA,SAAS,eAAe,QAAQ,OAAO;AACrC,QAAM,OAAO,OAAO,KAAK,MAAM;AAC/B,QAAM,IAAI,KAAK;AAEf,MAAI;AACJ,MAAI,IAAI;AAER,SAAO,IAAI,gBAAAC,QAAS,SAAS,OAAO;AAClC,OAAG;AACD,UAAI,CAAC,UAAU;AACb,YAAI,KAAK;AAAG,iBAAO,EAAC,MAAM,KAAI;AAE9B,cAAM,IAAI,KAAK,GAAG;AAElB,YAAI,MAAM,OAAO;AACf,qBAAW;AACX;QACV;AAEQ,mBAAW,OAAO,CAAC;MAC3B,OAAa;AACL,mBAAW,SAAS;MAC5B;IACA,SAAa,CAAC;AAEV,WAAO;MACL,MAAM;MACN,OAAO;QACL,MAAM,SAAS;QACf,YAAY,SAAS;QACrB,QAAQ,SAAS,OAAO;QACxB,QAAQ,SAAS,OAAO;QACxB,kBAAkB,SAAS,OAAO;QAClC,kBAAkB,SAAS,OAAO;QAClC,YAAY,SAAS;MAC7B;IACA;EACA,CAAG;AACH;AAUA,SAAS,oBAAoB,WAAW,QAAQ,GAAG,UAAU;AAC3D,QAAM,WAAW,OAAO,CAAC;AAEzB,MAAI,CAAC;AAAU;AAEf,QAAM,aAAa,SAAS;AAC5B,QAAM,aAAa,SAAS;AAE5B,MACE;IACE,SAAS;IACT,SAAS;IACT,WAAW;IACX,WAAW;IACX,WAAW;IACX,WAAW;IACX,SAAS;EACf,KACI;AAEA,WAAO,SAAS;AACpB;AAEA,SAAS,mBAAmB,WAAW,QAAQ,GAAG,UAAU;AAC1D,MAAI,WAAW,OAAO,CAAC;AAEvB,MAAI,CAAC;AAAU;AAEf,MAAI,cAAc;AAElB,KAAG;AACD,kBAAc;MACZ,SAAS;MACT,SAAS;MACT,SAAS,OAAO;MAChB,SAAS,OAAO;MAChB,SAAS,OAAO;MAChB,SAAS,OAAO;MAChB,SAAS;IACf;AAEI,QAAI,aAAa;AAAa,aAAO,SAAS;AAE9C,eAAW,SAAS;EACxB,SAAW,aAAa;AAEtB;AACF;AASA,SAAS,qBAAqB,QAAQ,GAAG;AACvC,MAAI,WAAW,OAAO,CAAC;AAEvB,MAAI,SAAS,SAAS,QAAW;AAC/B,WAAO,IAAI,gBAAAA,QAAS,WAAY;AAC9B,UAAI,CAAC;AAAU,eAAO,EAAC,MAAM,KAAI;AAEjC,YAAM,QAAQ;QACZ,MAAM,SAAS;QACf,YAAY,SAAS;QACrB,QAAQ,SAAS,OAAO;QACxB,QAAQ,SAAS,OAAO;QACxB,kBAAkB,SAAS,OAAO;QAClC,kBAAkB,SAAS,OAAO;QAClC,YAAY,SAAS;MAC7B;AAEM,iBAAW,SAAS;AAEpB,aAAO;QACL,MAAM;QACN;MACR;IACA,CAAK;EACL;AAEE,SAAO,gBAAAA,QAAS,GAAG;IACjB,MAAM,SAAS;IACf,YAAY,SAAS;IACrB,QAAQ,SAAS,OAAO;IACxB,QAAQ,SAAS,OAAO;IACxB,kBAAkB,SAAS,OAAO;IAClC,kBAAkB,SAAS,OAAO;IAClC,YAAY,SAAS;EACzB,CAAG;AACH;AASA,SAAS,gBAAgB,OAAO,MAAM;AACpC,MAAI,MAAM,SAAS;AAAG,WAAO,CAAA;AAE7B,MAAI,SAAS,WAAW,SAAS,MAAM,MAAM;AAC3C,QAAI,OAAO,MAAM,SAAS;AACxB,aAAO,MAAM,KAAK,MAAM,OAAO,KAAI,CAAE;AAEvC,eAAO,YAAAC,SAAK,MAAM,OAAO,KAAI,GAAI,MAAM,OAAO,IAAI;EACtD;AAEE,QAAM,OACJ,SAAS,eAAe,MAAM,iBAAiB,MAAM;AAEvD,QAAM,OAAO,IAAI,MAAM,IAAI,GACzB,OAAO,SAAS;AAElB,QAAM,WAAW,MAAM,OAAO,OAAM;AAEpC,MAAI,IAAI;AACR,MAAI,MAAM;AAEV,SAAS,OAAO,SAAS,KAAI,GAAK,KAAK,SAAS,MAAO;AACrD,WAAO,KAAK;AAEZ,QAAI,KAAK,eAAe;AAAM,WAAK,GAAG,IAAI,KAAK;EACnD;AAEE,SAAO;AACT;AAUA,SAAS,YAAY,WAAW,OAAO,MAAM,UAAU;AACrD,MAAI,MAAM,SAAS;AAAG;AAEtB,QAAM,eAAe,SAAS,WAAW,SAAS,MAAM;AACxD,QAAM,OAAO,SAAS;AAEtB,MAAI,MAAM;AACV,MAAI,cAAc;AAClB,QAAM,WAAW,MAAM,OAAO,OAAM;AAEpC,SAAS,OAAO,SAAS,KAAI,GAAK,KAAK,SAAS,MAAO;AACrD,WAAO,KAAK;AAEZ,QAAI,gBAAgB,KAAK,eAAe;AAAM;AAE9C,UAAM,EAAC,KAAK,YAAY,QAAQ,OAAM,IAAI;AAE1C,kBAAc;MACZ;MACA;MACA,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,KAAK;IACX;AAEI,QAAI,aAAa;AAAa,aAAO;EACzC;AAEE;AACF;AASA,SAAS,mBAAmB,OAAO,MAAM;AACvC,MAAI,MAAM,SAAS;AAAG,WAAO,gBAAAD,QAAS,MAAK;AAE3C,QAAM,eAAe,SAAS,WAAW,SAAS,MAAM;AACxD,QAAM,OAAO,SAAS;AAEtB,QAAM,WAAW,MAAM,OAAO,OAAM;AAEpC,SAAO,IAAI,gBAAAA,QAAS,SAAS,OAAO;AAClC,QAAI,MAAM;AAGV,WAAO,MAAM;AACX,aAAO,SAAS,KAAI;AAEpB,UAAI,KAAK;AAAM,eAAO;AAEtB,aAAO,KAAK;AAEZ,UAAI,gBAAgB,KAAK,eAAe;AAAM;AAE9C;IACN;AAEI,UAAM,QAAQ;MACZ,MAAM,KAAK;MACX,YAAY,KAAK;MACjB,QAAQ,KAAK,OAAO;MACpB,QAAQ,KAAK,OAAO;MACpB,kBAAkB,KAAK,OAAO;MAC9B,kBAAkB,KAAK,OAAO;MAC9B,YAAY,KAAK;IACvB;AAEI,WAAO,EAAC,OAAO,MAAM,MAAK;EAC9B,CAAG;AACH;AAWA,SAAS,mBACP,WACA,OACA,MACA,WACA,UACA,UACA;AACA,QAAM,KAAK,QAAQ,eAAe;AAElC,MAAI;AAEJ,MAAI,SAAS,cAAc;AACzB,QAAI,cAAc,OAAO;AACvB,cAAQ,GAAG,WAAW,SAAS,IAAI,QAAQ;AAE3C,UAAI,aAAa;AAAO,eAAO;IACrC;AACI,QAAI,cAAc,MAAM;AACtB,cAAQ;QACN;QACA,SAAS;QACT;QACA,CAAC,YAAY,SAAS,MAAM;MACpC;AAEM,UAAI,aAAa;AAAO,eAAO;IACrC;EACA;AAEE,MAAI,SAAS,YAAY;AACvB,YAAQ,GAAG,WAAW,SAAS,YAAY,QAAQ;AAEnD,QAAI,aAAa;AAAO,aAAO;EACnC;AAEE;AACF;AAWA,SAAS,uBAAuB,OAAO,MAAM,WAAW,UAAU;AAChE,QAAM,QAAQ,CAAA;AAEd,qBAAmB,OAAO,OAAO,MAAM,WAAW,UAAU,SAAU,KAAK;AACzE,UAAM,KAAK,GAAG;EAClB,CAAG;AAED,SAAO;AACT;AAUA,SAAS,0BAA0B,MAAM,WAAW,UAAU;AAC5D,MAAI,WAAW,gBAAAA,QAAS,MAAK;AAE7B,MAAI,SAAS,cAAc;AACzB,QAAI,cAAc,SAAS,OAAO,SAAS,OAAO;AAChD,qBAAW,aAAAE,SAAM,UAAU,eAAe,SAAS,EAAE,CAAC;AACxD,QAAI,cAAc,QAAQ,OAAO,SAAS,QAAQ;AAChD,qBAAW,aAAAA;QACT;QACA,eAAe,SAAS,KAAK,CAAC,YAAY,SAAS,MAAM,MAAS;MAC1E;EACA;AAEE,MAAI,SAAS,cAAc,OAAO,SAAS,eAAe,aAAa;AACrE,mBAAW,aAAAA,SAAM,UAAU,eAAe,SAAS,UAAU,CAAC;EAClE;AAEE,SAAO;AACT;AAaA,SAAS,mBACP,WACA,MACA,OACA,WACA,YACA,QACA,UACA;AACA,QAAM,KAAK,QAAQ,qBAAqB;AAExC,MAAI;AAEJ,MAAI,SAAS,cAAc;AACzB,QAAI,OAAO,WAAW,OAAO,eAAe,cAAc,OAAO;AAC/D,cAAQ,GAAG,WAAW,WAAW,IAAI,QAAQ,QAAQ;AAErD,UAAI,aAAa;AAAO,eAAO;IACrC;AAEI,QACE,OAAO,WAAW,QAAQ,eAC1B,cAAc,SACb,aAAa,WAAW,QAAQ,SACjC;AACA,cAAQ,GAAG,WAAW,WAAW,KAAK,QAAQ,QAAQ;AAEtD,UAAI,aAAa;AAAO,eAAO;IACrC;EACA;AAEE,MAAI,SAAS,YAAY;AACvB,QAAI,OAAO,WAAW,eAAe,aAAa;AAChD,cAAQ,GAAG,WAAW,WAAW,YAAY,QAAQ,QAAQ;AAE7D,UAAI,aAAa;AAAO,eAAO;IACrC;EACA;AAEE;AACF;AAYA,SAAS,uBAAuB,MAAM,OAAO,WAAW,YAAY,QAAQ;AAC1E,QAAM,QAAQ,CAAA;AAEd;IACE;IACA;IACA;IACA;IACA;IACA;IACA,SAAU,KAAK;AACb,YAAM,KAAK,GAAG;IACpB;EACA;AAEE,SAAO;AACT;AAWA,SAAS,0BAA0B,MAAM,WAAW,YAAY,QAAQ;AACtE,MAAI,WAAW,gBAAAF,QAAS,MAAK;AAE7B,MAAI,SAAS,cAAc;AACzB,QACE,OAAO,WAAW,OAAO,eACzB,cAAc,SACd,UAAU,WAAW;AAErB,qBAAW,aAAAE,SAAM,UAAU,qBAAqB,WAAW,IAAI,MAAM,CAAC;AAExE,QACE,OAAO,WAAW,QAAQ,eAC1B,cAAc,QACd,UAAU,WAAW,QACpB,aAAa,WAAW,QAAQ;AAEjC,qBAAW,aAAAA,SAAM,UAAU,qBAAqB,WAAW,KAAK,MAAM,CAAC;EAC7E;AAEE,MAAI,SAAS,YAAY;AACvB,QACE,OAAO,WAAW,eAAe,eACjC,UAAU,WAAW;AAErB,qBAAW,aAAAA;QACT;QACA,qBAAqB,WAAW,YAAY,MAAM;MAC1D;EACA;AAEE,SAAO;AACT;AAQA,SAAS,uBAAuB,OAAO,aAAa;AAClD,QAAM,EAAC,MAAM,MAAM,UAAS,IAAI;AAkBhC,QAAM,UAAU,IAAI,IAAI,SAAU,QAAQ,QAAQ;AAEhD,QAAI,SAAS,WAAW,KAAK,SAAS,WAAW,SAAS,KAAK;AAC7D,aAAO,CAAA;AAET,QAAI,CAAC,UAAU;AAAQ,aAAO,gBAAgB,MAAM,IAAI;AAExD,QAAI,UAAU,WAAW,GAAG;AAC1B,eAAS,KAAK;AAEd,YAAM,WAAW,KAAK,OAAO,IAAI,MAAM;AAEvC,UAAI,OAAO,aAAa;AACtB,cAAM,IAAI;UACR,SAAS,6BAA6B;QAChD;AAGM,aAAO;QACL,KAAK;QACL,SAAS,UAAU,KAAK,OAAO;QAC/B;QACA;MACR;IACA;AAEI,QAAI,UAAU,WAAW,GAAG;AAC1B,eAAS,KAAK;AACd,eAAS,KAAK;AAEd,YAAM,aAAa,KAAK,OAAO,IAAI,MAAM;AAEzC,UAAI,CAAC;AACH,cAAM,IAAI;UACR,SAAS,8BAA8B;QACjD;AAEM,UAAI,CAAC,KAAK,OAAO,IAAI,MAAM;AACzB,cAAM,IAAI;UACR,SAAS,8BAA8B;QACjD;AAGM,aAAO;QACL;QACA,KAAK;QACL;QACA;QACA;MACR;IACA;AAEI,UAAM,IAAI;MACR,SAAS,yDAAyD,UAAU;IAClF;EACA;AACA;AAQA,SAAS,kBAAkB,OAAO,aAAa;AAC7C,QAAM,EAAC,MAAM,MAAM,UAAS,IAAI;AAEhC,QAAM,cAAc,YAAY,KAAK,CAAC,EAAE,YAAW,IAAK,KAAK,MAAM,GAAG,EAAE;AAsBxE,QAAM,UAAU,WAAW,IAAI,SAAU,QAAQ,QAAQ,UAAU;AAEjE,QAAI,SAAS,WAAW,KAAK,SAAS,WAAW,SAAS,KAAK;AAAM;AAErE,QAAI,UAAU,WAAW,GAAG;AAC1B,iBAAW;AACX,aAAO,YAAY,OAAO,MAAM,MAAM,QAAQ;IACpD;AAEI,QAAI,UAAU,WAAW,GAAG;AAC1B,eAAS,KAAK;AACd,iBAAW;AAEX,YAAM,WAAW,KAAK,OAAO,IAAI,MAAM;AAEvC,UAAI,OAAO,aAAa;AACtB,cAAM,IAAI;UACR,SAAS,oCAAoC;QACvD;AAIM,aAAO;QACL;QACA,KAAK;QACL,SAAS,UAAU,KAAK,OAAO;QAC/B;QACA;QACA;MACR;IACA;AAEI,QAAI,UAAU,WAAW,GAAG;AAC1B,eAAS,KAAK;AACd,eAAS,KAAK;AAEd,YAAM,aAAa,KAAK,OAAO,IAAI,MAAM;AAEzC,UAAI,CAAC;AACH,cAAM,IAAI;UACR,SAAS,qCAAqC;QACxD;AAEM,UAAI,CAAC,KAAK,OAAO,IAAI,MAAM;AACzB,cAAM,IAAI;UACR,SAAS,qCAAqC;QACxD;AAGM,aAAO;QACL;QACA;QACA,KAAK;QACL;QACA;QACA;QACA;MACR;IACA;AAEI,UAAM,IAAI;MACR,SAAS,gEAAgE,UAAU;IACzF;EACA;AAsBE,QAAM,UAAU,QAAQ,KAAK,CAAC,EAAE,YAAW,IAAK,KAAK,MAAM,CAAC;AAE5D,QAAM,UAAU,OAAO,IAAI,WAAY;AACrC,UAAM,OAAO,MAAM,UAAU,MAAM,KAAK,SAAS;AACjD,UAAM,WAAW,KAAK,IAAG;AAEzB,QAAI;AAGJ,QAAI,KAAK,WAAW,GAAG;AACrB,UAAI,SAAS;AAEb,UAAI,SAAS;AAAY,kBAAU,KAAK;AACxC,UAAI,SAAS;AAAc,kBAAU,KAAK;AAE1C,eAAS,IAAI,MAAM,MAAM;AAEzB,UAAI,IAAI;AAER,WAAK,KAAK,CAAC,GAAG,IAAI,GAAG,GAAG,IAAI,IAAI,MAAM;AACpC,eAAO,GAAG,IAAI,SAAS,GAAG,IAAI,GAAG,GAAG,IAAI,IAAI,CAAC;MACrD,CAAO;IACP,OAIS;AACH,eAAS,CAAA;AAET,WAAK,KAAK,CAAC,GAAG,IAAI,GAAG,GAAG,IAAI,IAAI,MAAM;AACpC,eAAO,KAAK,SAAS,GAAG,IAAI,GAAG,GAAG,IAAI,IAAI,CAAC,CAAC;MACpD,CAAO;IACP;AAEI,SAAK,WAAW,EAAE,MAAM,MAAM,IAAI;AAElC,WAAO;EACX;AAsBE,QAAM,aAAa,WAAW,KAAK,CAAC,EAAE,YAAW,IAAK,KAAK,MAAM,CAAC;AAElE,QAAM,UAAU,UAAU,IAAI,WAAY;AACxC,UAAM,OAAO,MAAM,UAAU,MAAM,KAAK,SAAS;AACjD,UAAM,WAAW,KAAK,IAAG;AAEzB,UAAM,SAAS,CAAA;AAEf,SAAK,KAAK,CAAC,GAAG,IAAI,GAAG,GAAG,IAAI,IAAI,MAAM;AACpC,UAAI,SAAS,GAAG,IAAI,GAAG,GAAG,IAAI,IAAI,CAAC;AAAG,eAAO,KAAK,CAAC;IACzD,CAAK;AAED,SAAK,WAAW,EAAE,MAAM,MAAM,IAAI;AAElC,WAAO;EACX;AAyBE,QAAM,aAAa,WAAW,KAAK,CAAC,EAAE,YAAW,IAAK,KAAK,MAAM,CAAC;AAElE,QAAM,UAAU,UAAU,IAAI,WAAY;AACxC,QAAI,OAAO,MAAM,UAAU,MAAM,KAAK,SAAS;AAE/C,QAAI,KAAK,SAAS,KAAK,KAAK,SAAS,GAAG;AACtC,YAAM,IAAI;QACR,SAAS,wEAAwE,KAAK;MAC9F;IACA;AAEI,QACE,OAAO,KAAK,KAAK,SAAS,CAAC,MAAM,cACjC,OAAO,KAAK,KAAK,SAAS,CAAC,MAAM,YACjC;AACA,YAAM,IAAI;QACR,SAAS;MACjB;IACA;AAEI,QAAI;AACJ,QAAI;AAEJ,QAAI,KAAK,WAAW,GAAG;AACrB,iBAAW,KAAK,CAAC;AACjB,qBAAe,KAAK,CAAC;AACrB,aAAO,CAAA;IACb,WAAe,KAAK,WAAW,GAAG;AAC5B,iBAAW,KAAK,CAAC;AACjB,qBAAe,KAAK,CAAC;AACrB,aAAO,CAAC,KAAK,CAAC,CAAC;IACrB,WAAe,KAAK,WAAW,GAAG;AAC5B,iBAAW,KAAK,CAAC;AACjB,qBAAe,KAAK,CAAC;AACrB,aAAO,CAAC,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC;IAC9B;AAEI,QAAI,cAAc;AAElB,SAAK,KAAK,CAAC,GAAG,IAAI,GAAG,GAAG,IAAI,IAAI,MAAM;AACpC,oBAAc,SAAS,aAAa,GAAG,IAAI,GAAG,GAAG,IAAI,IAAI,CAAC;IAChE,CAAK;AAED,SAAK,WAAW,EAAE,MAAM,MAAM,IAAI;AAElC,WAAO;EACX;AACA;AASA,SAAS,eAAe,OAAO,aAAa;AAC1C,QAAM,EAAC,MAAM,MAAM,UAAS,IAAI;AAEhC,QAAM,eAAe,SAAS,KAAK,CAAC,EAAE,YAAW,IAAK,KAAK,MAAM,GAAG,EAAE;AAsBtE,QAAM,UAAU,YAAY,IAAI,SAAU,QAAQ,QAAQ,UAAU;AAElE,QAAI,SAAS,WAAW,KAAK,SAAS,WAAW,SAAS,KAAK;AAC7D,aAAO;AAET,QAAI,UAAU,WAAW,GAAG;AAC1B,iBAAW;AACX,aAAO,YAAY,MAAM,MAAM,MAAM,QAAQ;IACnD;AAEI,QAAI,UAAU,WAAW,GAAG;AAC1B,eAAS,KAAK;AACd,iBAAW;AAEX,YAAM,WAAW,KAAK,OAAO,IAAI,MAAM;AAEvC,UAAI,OAAO,aAAa;AACtB,cAAM,IAAI;UACR,SAAS,qCAAqC;QACxD;AAIM,aAAO;QACL;QACA,KAAK;QACL,SAAS,UAAU,KAAK,OAAO;QAC/B;QACA;QACA;MACR;IACA;AAEI,QAAI,UAAU,WAAW,GAAG;AAC1B,eAAS,KAAK;AACd,eAAS,KAAK;AAEd,YAAM,aAAa,KAAK,OAAO,IAAI,MAAM;AAEzC,UAAI,CAAC;AACH,cAAM,IAAI;UACR,SAAS,sCAAsC;QACzD;AAEM,UAAI,CAAC,KAAK,OAAO,IAAI,MAAM;AACzB,cAAM,IAAI;UACR,SAAS,sCAAsC;QACzD;AAGM,aAAO;QACL;QACA;QACA,KAAK;QACL;QACA;QACA;QACA;MACR;IACA;AAEI,UAAM,IAAI;MACR,SAAS,iEAAiE,UAAU;IAC1F;EACA;AAsBE,QAAM,WAAW,SAAS,KAAK,CAAC,EAAE,YAAW,IAAK,KAAK,MAAM,GAAG,EAAE;AAElE,QAAM,UAAU,QAAQ,IAAI,WAAY;AACtC,UAAM,OAAO,MAAM,UAAU,MAAM,KAAK,SAAS;AACjD,UAAM,WAAW,KAAK,IAAG;AAEzB,SAAK,KAAK,CAAC,GAAG,IAAI,GAAG,GAAG,IAAI,IAAI,MAAM;AACpC,aAAO,SAAS,GAAG,IAAI,GAAG,GAAG,IAAI,IAAI,CAAC;IAC5C,CAAK;AAED,UAAM,QAAQ,KAAK,YAAY,EAAE,MAAM,MAAM,IAAI;AAEjD,QAAI;AAAO,aAAO;AAElB,WAAO;EACX;AAsBE,QAAM,YAAY,UAAU,KAAK,CAAC,EAAE,YAAW,IAAK,KAAK,MAAM,GAAG,EAAE;AAEpE,QAAM,UAAU,SAAS,IAAI,WAAY;AACvC,UAAM,OAAO,MAAM,UAAU,MAAM,KAAK,SAAS;AACjD,UAAM,WAAW,KAAK,IAAG;AAEzB,SAAK,KAAK,CAAC,GAAG,IAAI,GAAG,GAAG,IAAI,IAAI,MAAM;AACpC,aAAO,CAAC,SAAS,GAAG,IAAI,GAAG,GAAG,IAAI,IAAI,CAAC;IAC7C,CAAK;AAED,UAAM,QAAQ,KAAK,YAAY,EAAE,MAAM,MAAM,IAAI;AAEjD,QAAI;AAAO,aAAO;AAElB,WAAO;EACX;AACA;AAQA,SAAS,0BAA0B,OAAO,aAAa;AACrD,QAAM,EAAC,MAAM,cAAc,MAAM,UAAS,IAAI;AAE9C,QAAM,OAAO,aAAa,MAAM,GAAG,EAAE,IAAI;AAkBzC,QAAM,UAAU,IAAI,IAAI,SAAU,QAAQ,QAAQ;AAEhD,QAAI,SAAS,WAAW,KAAK,SAAS,WAAW,SAAS,KAAK;AAC7D,aAAO,gBAAAF,QAAS,MAAK;AAEvB,QAAI,CAAC,UAAU;AAAQ,aAAO,mBAAmB,MAAM,IAAI;AAE3D,QAAI,UAAU,WAAW,GAAG;AAC1B,eAAS,KAAK;AAEd,YAAM,aAAa,KAAK,OAAO,IAAI,MAAM;AAEzC,UAAI,CAAC;AACH,cAAM,IAAI;UACR,SAAS,6BAA6B;QAChD;AAGM,aAAO,0BAA0B,MAAM,WAAW,UAAU;IAClE;AAEI,QAAI,UAAU,WAAW,GAAG;AAC1B,eAAS,KAAK;AACd,eAAS,KAAK;AAEd,YAAM,aAAa,KAAK,OAAO,IAAI,MAAM;AAEzC,UAAI,CAAC;AACH,cAAM,IAAI;UACR,SAAS,8BAA8B;QACjD;AAEM,UAAI,CAAC,KAAK,OAAO,IAAI,MAAM;AACzB,cAAM,IAAI;UACR,SAAS,8BAA8B;QACjD;AAGM,aAAO,0BAA0B,MAAM,WAAW,YAAY,MAAM;IAC1E;AAEI,UAAM,IAAI;MACR,SAAS,yDAAyD,UAAU;IAClF;EACA;AACA;AAOe,SAAS,2BAA2BD,QAAO;AACxD,kBAAgB,QAAQ,iBAAe;AACrC,2BAAuBA,QAAO,WAAW;AACzC,sBAAkBA,QAAO,WAAW;AACpC,mBAAeA,QAAO,WAAW;AACjC,8BAA0BA,QAAO,WAAW;EAChD,CAAG;AACH;AC1qCA,IAAM,sBAAsB;EAC1B;IACE,MAAM;IACN,MAAM;EACV;EACE;IACE,MAAM;IACN,MAAM;IACN,WAAW;EACf;EACE;IACE,MAAM;IACN,MAAM;IACN,WAAW;EACf;EACE;IACE,MAAM;IACN,MAAM;IACN,WAAW;EACf;EACE;IACE,MAAM;IACN,MAAM;IACN,WAAW;EACf;EACE;IACE,MAAM;IACN,MAAM;EACV;EACE;IACE,MAAM;IACN,MAAM;EACV;AACA;AAKA,SAAS,sBAAsB;AAC7B,OAAK,IAAI;AACT,OAAK,IAAI;AACX;AAEA,oBAAoB,UAAU,OAAO,SAAU,KAAK;AAClD,MAAI,KAAK,MAAM;AAAM,SAAK,IAAI;WACrB,KAAK,MAAM;AAAM,SAAK,IAAI;AACrC;AAEA,oBAAoB,UAAU,MAAM,SAAU,KAAK;AACjD,MAAI,KAAK,MAAM,QAAQ,OAAO,KAAK;AAAG,WAAO;AAC7C,MAAI,KAAK,MAAM,QAAQ,OAAO,KAAK;AAAG,WAAO;AAC7C,SAAO;AACT;AAWA,SAAS,oBAAoB,WAAW,SAAS,UAAU,QAAQ,UAAU;AAC3E,aAAW,KAAK,QAAQ;AACtB,UAAM,WAAW,OAAO,CAAC;AAEzB,UAAM,aAAa,SAAS;AAC5B,UAAM,aAAa,SAAS;AAE5B,UAAM,eAAe,eAAe,WAAW,aAAa;AAE5D,QAAI,WAAW,QAAQ,IAAI,aAAa,GAAG;AAAG;AAE9C,UAAM,cAAc,SAAS,aAAa,KAAK,aAAa,UAAU;AAEtE,QAAI,aAAa;AAAa,aAAO,aAAa;EACtD;AAEE;AACF;AAEA,SAAS,gBAAgB,WAAW,MAAM,WAAW,UAAU,UAAU;AAEvE,MAAI,SAAS,SAAS;AACpB,QAAI,SAAS;AACX,aAAO;QACL;QACA;QACA;QACA,SAAS;QACT;MACR;AAEI,QAAI,OAAO,cAAc;AACvB,aAAO;QACL;QACA;QACA;QACA,SAAS,SAAS;QAClB;MACR;EACA;AAIE,QAAM,UAAU,IAAI,oBAAmB;AAEvC,MAAI;AAEJ,MAAI,SAAS,cAAc;AACzB,QAAI,cAAc,OAAO;AACvB,cAAQ;QACN;QACA;QACA;QACA,SAAS;QACT;MACR;AAEM,UAAI,aAAa;AAAO,eAAO;AAE/B,cAAQ,KAAK,SAAS,EAAE;IAC9B;AACI,QAAI,cAAc,MAAM;AACtB,cAAQ;QACN;QACA;QACA;QACA,SAAS;QACT;MACR;AAEM,UAAI,aAAa;AAAO,eAAO;AAE/B,cAAQ,KAAK,SAAS,GAAG;IAC/B;EACA;AAEE,MAAI,SAAS,YAAY;AACvB,YAAQ;MACN;MACA;MACA;MACA,SAAS;MACT;IACN;AAEI,QAAI,aAAa;AAAO,aAAO;EACnC;AAEE;AACF;AAUA,SAAS,2BAA2B,MAAM,WAAW,UAAU;AAE7D,MAAI,SAAS,SAAS;AACpB,QAAI,SAAS;AAAc,aAAO,OAAO,KAAK,SAAS,UAAU;AAEjE,QAAI,OAAO,cAAc;AAAU,aAAO,OAAO,KAAK,SAAS,SAAS,CAAC;EAC7E;AAEE,QAAM,YAAY,CAAA;AAElB,kBAAgB,OAAO,MAAM,WAAW,UAAU,SAAU,KAAK;AAC/D,cAAU,KAAK,GAAG;EACtB,CAAG;AAED,SAAO;AACT;AAUA,SAAS,4BAA4B,SAAS,UAAU,QAAQ;AAC9D,QAAM,OAAO,OAAO,KAAK,MAAM;AAC/B,QAAM,IAAI,KAAK;AAEf,MAAI,IAAI;AAER,SAAO,IAAI,gBAAAC,QAAS,SAAS,OAAO;AAClC,QAAI,eAAe;AAEnB,OAAG;AACD,UAAI,KAAK,GAAG;AACV,YAAI;AAAS,kBAAQ,KAAK,MAAM;AAChC,eAAO,EAAC,MAAM,KAAI;MAC1B;AAEM,YAAM,WAAW,OAAO,KAAK,GAAG,CAAC;AAEjC,YAAM,aAAa,SAAS;AAC5B,YAAM,aAAa,SAAS;AAE5B,qBAAe,eAAe,WAAW,aAAa;AAEtD,UAAI,WAAW,QAAQ,IAAI,aAAa,GAAG,GAAG;AAC5C,uBAAe;AACf;MACR;IACA,SAAa,iBAAiB;AAE1B,WAAO;MACL,MAAM;MACN,OAAO,EAAC,UAAU,aAAa,KAAK,YAAY,aAAa,WAAU;IAC7E;EACA,CAAG;AACH;AAEA,SAAS,uBAAuB,MAAM,WAAW,UAAU;AAEzD,MAAI,SAAS,SAAS;AACpB,QAAI,SAAS;AACX,aAAO,4BAA4B,MAAM,UAAU,SAAS,UAAU;AAExE,QAAI,OAAO,cAAc;AACvB,aAAO,4BAA4B,MAAM,UAAU,SAAS,SAAS,CAAC;EAC5E;AAEE,MAAI,WAAW,gBAAAA,QAAS,MAAK;AAI7B,QAAM,UAAU,IAAI,oBAAmB;AAEvC,MAAI,SAAS,cAAc;AACzB,QAAI,cAAc,OAAO;AACvB,qBAAW,aAAAE;QACT;QACA,4BAA4B,SAAS,UAAU,SAAS,EAAE;MAClE;IACA;AACI,QAAI,cAAc,MAAM;AACtB,qBAAW,aAAAA;QACT;QACA,4BAA4B,SAAS,UAAU,SAAS,GAAG;MACnE;IACA;EACA;AAEE,MAAI,SAAS,YAAY;AACvB,mBAAW,aAAAA;MACT;MACA,4BAA4B,SAAS,UAAU,SAAS,UAAU;IACxE;EACA;AAEE,SAAO;AACT;AAQA,SAAS,2BAA2B,OAAO,aAAa;AACtD,QAAM,EAAC,MAAM,MAAM,UAAS,IAAI;AAUhC,QAAM,UAAU,IAAI,IAAI,SAAU,MAAM;AAEtC,QAAI,SAAS,WAAW,KAAK,SAAS,WAAW,SAAS,KAAK;AAC7D,aAAO,CAAA;AAET,WAAO,KAAK;AAEZ,UAAM,WAAW,KAAK,OAAO,IAAI,IAAI;AAErC,QAAI,OAAO,aAAa;AACtB,YAAM,IAAI;QACR,SAAS,6BAA6B;MAC9C;AAGI,WAAO;MACL,SAAS,UAAU,KAAK,OAAO;MAC/B;MACA;IACN;EACA;AACA;AAQA,SAAS,sBAAsB,OAAO,aAAa;AACjD,QAAM,EAAC,MAAM,MAAM,UAAS,IAAI;AAEhC,QAAM,cAAc,YAAY,KAAK,CAAC,EAAE,YAAW,IAAK,KAAK,MAAM,GAAG,EAAE;AAWxE,QAAM,UAAU,WAAW,IAAI,SAAU,MAAM,UAAU;AAEvD,QAAI,SAAS,WAAW,KAAK,SAAS,WAAW,SAAS,KAAK;AAAM;AAErE,WAAO,KAAK;AAEZ,UAAM,WAAW,KAAK,OAAO,IAAI,IAAI;AAErC,QAAI,OAAO,aAAa;AACtB,YAAM,IAAI;QACR,SAAS,oCAAoC;MACrD;AAGI;MACE;MACA,SAAS,UAAU,KAAK,OAAO;MAC/B;MACA;MACA;IACN;EACA;AAUE,QAAM,UAAU,QAAQ,KAAK,CAAC,EAAE,YAAW,IAAK,KAAK,MAAM,CAAC;AAE5D,QAAM,UAAU,OAAO,IAAI,SAAU,MAAM,UAAU;AAEnD,UAAM,SAAS,CAAA;AAEf,SAAK,WAAW,EAAE,MAAM,CAAC,GAAG,MAAM;AAChC,aAAO,KAAK,SAAS,GAAG,CAAC,CAAC;IAChC,CAAK;AAED,WAAO;EACX;AAUE,QAAM,aAAa,WAAW,KAAK,CAAC,EAAE,YAAW,IAAK,KAAK,MAAM,CAAC;AAElE,QAAM,UAAU,UAAU,IAAI,SAAU,MAAM,UAAU;AACtD,UAAM,SAAS,CAAA;AAEf,SAAK,WAAW,EAAE,MAAM,CAAC,GAAG,MAAM;AAChC,UAAI,SAAS,GAAG,CAAC;AAAG,eAAO,KAAK,CAAC;IACvC,CAAK;AAED,WAAO;EACX;AAUE,QAAM,aAAa,WAAW,KAAK,CAAC,EAAE,YAAW,IAAK,KAAK,MAAM,CAAC;AAElE,QAAM,UAAU,UAAU,IAAI,SAAU,MAAM,UAAU,cAAc;AACpE,QAAI,UAAU,SAAS;AACrB,YAAM,IAAI;QACR,SAAS;MACjB;AAEI,QAAI,cAAc;AAElB,SAAK,WAAW,EAAE,MAAM,CAAC,GAAG,MAAM;AAChC,oBAAc,SAAS,aAAa,GAAG,CAAC;IAC9C,CAAK;AAED,WAAO;EACX;AACA;AASA,SAAS,mBAAmB,OAAO,aAAa;AAC9C,QAAM,EAAC,MAAM,MAAM,UAAS,IAAI;AAEhC,QAAM,sBAAsB,KAAK,CAAC,EAAE,YAAW,IAAK,KAAK,MAAM,GAAG,EAAE;AAEpE,QAAM,WAAW,SAAS;AAW1B,QAAM,UAAU,QAAQ,IAAI,SAAU,MAAM,UAAU;AAEpD,QAAI,SAAS,WAAW,KAAK,SAAS,WAAW,SAAS,KAAK;AAAM;AAErE,WAAO,KAAK;AAEZ,UAAM,WAAW,KAAK,OAAO,IAAI,IAAI;AAErC,QAAI,OAAO,aAAa;AACtB,YAAM,IAAI;QACR,SAAS,iCAAiC;MAClD;AAGI,WAAO;MACL;MACA,SAAS,UAAU,KAAK,OAAO;MAC/B;MACA;MACA;IACN;EACA;AAYE,QAAM,WAAW,SAAS;AAE1B,QAAM,UAAU,QAAQ,IAAI,SAAU,MAAM,UAAU;AACpD,UAAM,QAAQ,KAAK,QAAQ,EAAE,MAAM,QAAQ;AAE3C,QAAI;AAAO,aAAO;AAElB,WAAO;EACX;AAYE,QAAM,YAAY,UAAU;AAE5B,QAAM,UAAU,SAAS,IAAI,SAAU,MAAM,UAAU;AACrD,UAAM,QAAQ,KAAK,QAAQ,EAAE,MAAM,CAAC,GAAG,MAAM;AAC3C,aAAO,CAAC,SAAS,GAAG,CAAC;IAC3B,CAAK;AAED,QAAI;AAAO,aAAO;AAElB,WAAO;EACX;AACA;AAQA,SAAS,8BAA8B,OAAO,aAAa;AACzD,QAAM,EAAC,MAAM,MAAM,UAAS,IAAI;AAEhC,QAAM,eAAe,KAAK,MAAM,GAAG,EAAE,IAAI;AAUzC,QAAM,UAAU,YAAY,IAAI,SAAU,MAAM;AAE9C,QAAI,SAAS,WAAW,KAAK,SAAS,WAAW,SAAS,KAAK;AAC7D,aAAO,gBAAAF,QAAS,MAAK;AAEvB,WAAO,KAAK;AAEZ,UAAM,WAAW,KAAK,OAAO,IAAI,IAAI;AAErC,QAAI,OAAO,aAAa;AACtB,YAAM,IAAI;QACR,SAAS,qCAAqC;MACtD;AAGI,WAAO;MACL,SAAS,UAAU,KAAK,OAAO;MAC/B;MACA;IACN;EACA;AACA;AAOe,SAAS,+BAA+BD,QAAO;AAC5D,sBAAoB,QAAQ,iBAAe;AACzC,+BAA2BA,QAAO,WAAW;AAC7C,0BAAsBA,QAAO,WAAW;AACxC,uBAAmBA,QAAO,WAAW;AACrC,kCAA8BA,QAAO,WAAW;EACpD,CAAG;AACH;AC1iBO,SAAS,iBACd,WACA,YACA,mBACA,OACA,UACA;AACA,QAAM,WAAW,MAAM,OAAO,OAAM;AAEpC,QAAM,OAAO,MAAM;AAEnB,MAAI,MAAM,YAAY,UAAU,KAAK,UAAU,YAAY;AAE3D,SAAS,OAAO,SAAS,KAAI,GAAK,KAAK,SAAS,MAAO;AACrD,QAAI,WAAW;AAEf,iBAAa,KAAK;AAElB,QAAI,SAAS,cAAc;AACzB,YAAM,WAAW;AAEjB,WAAK,YAAY,KAAK;AACpB,mBAAW,IAAI,QAAQ;AAEvB,WAAG;AACD,uBAAa,SAAS;AAEtB,qBAAW;AACX,wBAAc;YACZ,WAAW;YACX,WAAW;YACX,WAAW;YACX,WAAW;YACX,SAAS;YACT,SAAS;YACT,SAAS;UACrB;AAEU,cAAI,aAAa;AAAa,mBAAO;AAErC,qBAAW,SAAS;QAC9B,SAAiB;MACjB;IACA;AAEI,QAAI,SAAS,YAAY;AACvB,YAAM,WAAW;AAEjB,WAAK,YAAY,KAAK;AACpB,YAAI,cAAc,WAAW,MAAM;AAAU;AAE7C,mBAAW,IAAI,QAAQ;AAEvB,WAAG;AACD,uBAAa,SAAS;AAEtB,cAAI,WAAW,QAAQ;AAAU,yBAAa,SAAS;AAEvD,qBAAW;AACX,wBAAc;YACZ,WAAW;YACX,WAAW;YACX,WAAW;YACX,WAAW;YACX,SAAS;YACT,SAAS;YACT,SAAS;UACrB;AAEU,cAAI,aAAa;AAAa,mBAAO;AAErC,qBAAW,SAAS;QAC9B,SAAiB;MACjB;IACA;AAEI,QAAI,qBAAqB,CAAC,UAAU;AAClC,oBAAc;QACZ,WAAW;QACX;QACA,WAAW;QACX;QACA;QACA;QACA;MACR;AAEM,UAAI,aAAa;AAAa,eAAO;IAC3C;EACA;AAEE;AACF;AC7FO,SAAS,cAAc,KAAK,MAAM;AACvC,QAAM,aAAa,EAAC,IAAG;AAEvB,MAAI,CAAC,QAAQ,KAAK,UAAU;AAC1B,eAAW,aAAa,OAAO,CAAA,GAAI,KAAK,UAAU;AAEpD,SAAO;AACT;AAUO,SAAS,cAAc,MAAM,KAAK,MAAM;AAC7C,QAAM,aAAa;IACjB;IACA,QAAQ,KAAK,OAAO;IACpB,QAAQ,KAAK,OAAO;EACxB;AAEE,MAAI,CAAC,QAAQ,KAAK,UAAU;AAC1B,eAAW,aAAa,OAAO,CAAA,GAAI,KAAK,UAAU;AAEpD,MAAI,SAAS,WAAW,KAAK;AAAY,eAAW,aAAa;AAEjE,SAAO;AACT;AAQO,SAAS,uBAAuB,OAAO;AAC5C,MAAI,CAAC,cAAc,KAAK;AACtB,UAAM,IAAI;MACR;IACN;AAEE,MAAI,EAAE,SAAS;AACb,UAAM,IAAI;MACR;IACN;AAEE,MACE,gBAAgB,UACf,CAAC,cAAc,MAAM,UAAU,KAAK,MAAM,eAAe;AAE1D,UAAM,IAAI;MACR;IACN;AACA;AAQO,SAAS,uBAAuB,OAAO;AAC5C,MAAI,CAAC,cAAc,KAAK;AACtB,UAAM,IAAI;MACR;IACN;AAEE,MAAI,EAAE,YAAY;AAChB,UAAM,IAAI;MACR;IACN;AAEE,MAAI,EAAE,YAAY;AAChB,UAAM,IAAI;MACR;IACN;AAEE,MACE,gBAAgB,UACf,CAAC,cAAc,MAAM,UAAU,KAAK,MAAM,eAAe;AAE1D,UAAM,IAAI;MACR;IACN;AAEE,MAAI,gBAAgB,SAAS,OAAO,MAAM,eAAe;AACvD,UAAM,IAAI;MACR;IACN;AACA;AC1DA,IAAM,cAAc,oCAAmC;AAKvD,IAAM,QAAQ,oBAAI,IAAI,CAAC,YAAY,cAAc,OAAO,CAAC;AAEzD,IAAM,gBAAgB,oBAAI,IAAI;EAC5B;EACA;EACA;EACA;AACF,CAAC;AAED,IAAM,mBAAmB;EACvB;IACE,MAAM,UAAQ,GAAG;IACjB,aAAa;EACjB;EACE;IACE,MAAM,UAAQ,GAAG;IACjB,aAAa;IACb,MAAM;EACV;EACE;IACE,MAAM,UAAQ,GAAG;IACjB,aAAa;IACb,MAAM;EACV;EACE;IACE,MAAM,UAAQ,GAAG;EACrB;EACE;IACE,MAAM,UAAQ,GAAG;IACjB,MAAM;EACV;EACE;IACE,MAAM,UAAQ,GAAG;IACjB,MAAM;EACV;AACA;AAKA,IAAM,WAAW;EACf,gBAAgB;EAChB,OAAO;EACP,MAAM;AACR;AAcA,SAAS,QAAQ,OAAO,MAAM,YAAY;AACxC,MAAI,cAAc,CAAC,cAAc,UAAU;AACzC,UAAM,IAAI;MACR,mEAAmE;IACzE;AAGE,SAAO,KAAK;AACZ,eAAa,cAAc,CAAA;AAE3B,MAAI,MAAM,OAAO,IAAI,IAAI;AACvB,UAAM,IAAI;MACR,uBAAuB;IAC7B;AAEE,QAAM,OAAO,IAAI,MAAM,cAAc,MAAM,UAAU;AAGrD,QAAM,OAAO,IAAI,MAAM,IAAI;AAG3B,QAAM,KAAK,aAAa;IACtB,KAAK;IACL;EACJ,CAAG;AAED,SAAO;AACT;AAMA,SAAS,cAAc,OAAO,MAAM,YAAY;AAC9C,QAAM,OAAO,IAAI,MAAM,cAAc,MAAM,UAAU;AAErD,QAAM,OAAO,IAAI,MAAM,IAAI;AAE3B,QAAM,KAAK,aAAa;IACtB,KAAK;IACL;EACJ,CAAG;AAED,SAAO;AACT;AAoBA,SAAS,QACP,OACA,MACA,iBACA,YACA,MACA,QACA,QACA,YACA;AAEA,MAAI,CAAC,cAAc,MAAM,SAAS;AAChC,UAAM,IAAI;MACR,SAAS;IACf;AAEE,MAAI,cAAc,MAAM,SAAS;AAC/B,UAAM,IAAI;MACR,SAAS;IACf;AAEE,MAAI,cAAc,CAAC,cAAc,UAAU;AACzC,UAAM,IAAI;MACR,SAAS,0DAA0D;IACzE;AAGE,WAAS,KAAK;AACd,WAAS,KAAK;AACd,eAAa,cAAc,CAAA;AAE3B,MAAI,CAAC,MAAM,kBAAkB,WAAW;AACtC,UAAM,IAAI;MACR,SAAS,wCAAwC;IACvD;AAEE,QAAM,aAAa,MAAM,OAAO,IAAI,MAAM,GACxC,aAAa,MAAM,OAAO,IAAI,MAAM;AAEtC,MAAI,CAAC;AACH,UAAM,IAAI;MACR,SAAS,sBAAsB;IACrC;AAEE,MAAI,CAAC;AACH,UAAM,IAAI;MACR,SAAS,sBAAsB;IACrC;AAGE,QAAM,YAAY;IAChB,KAAK;IACL;IACA;IACA;IACA;EACJ;AAEE,MAAI,iBAAiB;AAGnB,WAAO,MAAM,kBAAiB;EAClC,OAAS;AAEL,WAAO,KAAK;AAGZ,QAAI,MAAM,OAAO,IAAI,IAAI;AACvB,YAAM,IAAI;QACR,SAAS,cAAc;MAC/B;EACA;AAGE,MACE,CAAC,MAAM,UACN,aACG,OAAO,WAAW,WAAW,MAAM,MAAM,cACzC,OAAO,WAAW,IAAI,MAAM,MAAM,cACtC;AACA,UAAM,IAAI;MACR,SAAS,0BAA0B,eAAe;IACxD;EACA;AAGE,QAAM,WAAW,IAAI;IACnB;IACA;IACA;IACA;IACA;EACJ;AAGE,QAAM,OAAO,IAAI,MAAM,QAAQ;AAG/B,QAAM,aAAa,WAAW;AAE9B,MAAI,YAAY;AACd,eAAW;AACX,eAAW;AAEX,QAAI,YAAY;AACd,iBAAW;AACX,YAAM;IACZ;EACA,OAAS;AACL,eAAW;AACX,eAAW;AAEX,QAAI,YAAY;AACd,iBAAW;AACX,YAAM;IACZ;EACA;AAGE,MAAI,MAAM;AAAO,aAAS,YAAW;;AAChC,aAAS,OAAM;AAEpB,MAAI;AAAY,UAAM;;AACjB,UAAM;AAGX,YAAU,MAAM;AAEhB,QAAM,KAAK,aAAa,SAAS;AAEjC,SAAO;AACT;AAqBA,SAAS,UACP,OACA,MACA,iBACA,YACA,MACA,QACA,QACA,YACA,WACA;AAEA,MAAI,CAAC,cAAc,MAAM,SAAS;AAChC,UAAM,IAAI;MACR,SAAS;IACf;AAEE,MAAI,cAAc,MAAM,SAAS;AAC/B,UAAM,IAAI;MACR,SAAS;IACf;AAEE,MAAI,YAAY;AACd,QAAI,WAAW;AACb,UAAI,OAAO,eAAe;AACxB,cAAM,IAAI;UACR,SAAS,iEAAiE;QACpF;IACA,OAAW;AACL,UAAI,CAAC,cAAc,UAAU;AAC3B,cAAM,IAAI;UACR,SAAS,0DAA0D;QAC7E;IACA;EACA;AAGE,WAAS,KAAK;AACd,WAAS,KAAK;AAEd,MAAI;AAEJ,MAAI,WAAW;AACb,cAAU;AACV,iBAAa;EACjB;AAEE,MAAI,CAAC,MAAM,kBAAkB,WAAW;AACtC,UAAM,IAAI;MACR,SAAS,wCAAwC;IACvD;AAEE,MAAI,aAAa,MAAM,OAAO,IAAI,MAAM;AACxC,MAAI,aAAa,MAAM,OAAO,IAAI,MAAM;AACxC,MAAI;AAGJ,MAAI;AAEJ,MAAI,CAAC,iBAAiB;AACpB,eAAW,MAAM,OAAO,IAAI,IAAI;AAEhC,QAAI,UAAU;AAGZ,UAAI,SAAS,OAAO,QAAQ,UAAU,SAAS,OAAO,QAAQ,QAAQ;AAEpE,YACE,CAAC,cACD,SAAS,OAAO,QAAQ,UACxB,SAAS,OAAO,QAAQ,QACxB;AAEA,gBAAM,IAAI;YACR,SAAS,8DAA8D,oBAAoB,qBAAqB,wBAAwB,SAAS,OAAO,UAAU,SAAS,OAAO;UAC9L;QACA;MACA;AAEM,gCAA0B;IAChC;EACA;AAGE,MAAI,CAAC,2BAA2B,CAAC,MAAM,SAAS,YAAY;AAC1D,8BAA0B,aACtB,WAAW,WAAW,MAAM,IAC5B,WAAW,IAAI,MAAM;EAC7B;AAGE,MAAI,yBAAyB;AAC3B,UAAM,OAAO,CAAC,wBAAwB,KAAK,OAAO,OAAO,KAAK;AAG9D,QAAI,YAAY,CAAC,UAAU,CAAC;AAAY,aAAO;AAG/C,QAAI,WAAW;AACb,YAAM,gBAAgB,wBAAwB;AAC9C,8BAAwB,aAAa,QAAQ,aAAa;AAE1D,YAAM,KAAK,yBAAyB;QAClC,MAAM;QACN,KAAK,wBAAwB;QAC7B,YAAY,wBAAwB;MAC5C,CAAO;IACP,OAGS;AACH,aAAO,wBAAwB,YAAY,UAAU;AAErD,YAAM,KAAK,yBAAyB;QAClC,MAAM;QACN,KAAK,wBAAwB;QAC7B,YAAY,wBAAwB;QACpC,MAAM;MACd,CAAO;IACP;AAEI,WAAO;EACX;AAEE,eAAa,cAAc,CAAA;AAE3B,MAAI,aAAa;AAAS,iBAAa,QAAQ,UAAU;AAGzD,QAAM,YAAY;IAChB,KAAK;IACL;IACA;IACA;IACA;EACJ;AAEE,MAAI,iBAAiB;AAGnB,WAAO,MAAM,kBAAiB;EAClC,OAAS;AAEL,WAAO,KAAK;AAGZ,QAAI,MAAM,OAAO,IAAI,IAAI;AACvB,YAAM,IAAI;QACR,SAAS,cAAc;MAC/B;EACA;AAEE,MAAI,iBAAiB;AACrB,MAAI,iBAAiB;AAErB,MAAI,CAAC,YAAY;AACf,iBAAa,cAAc,OAAO,QAAQ,CAAA,CAAE;AAC5C,qBAAiB;AAEjB,QAAI,WAAW,QAAQ;AACrB,mBAAa;AACb,uBAAiB;IACvB;EACA;AACE,MAAI,CAAC,YAAY;AACf,iBAAa,cAAc,OAAO,QAAQ,CAAA,CAAE;AAC5C,qBAAiB;EACrB;AAGE,aAAW,IAAI,SAAS,YAAY,MAAM,YAAY,YAAY,UAAU;AAG5E,QAAM,OAAO,IAAI,MAAM,QAAQ;AAG/B,QAAM,aAAa,WAAW;AAE9B,MAAI,YAAY;AACd,eAAW;AACX,eAAW;AAEX,QAAI,YAAY;AACd,iBAAW;AACX,YAAM;IACZ;EACA,OAAS;AACL,eAAW;AACX,eAAW;AAEX,QAAI,YAAY;AACd,iBAAW;AACX,YAAM;IACZ;EACA;AAGE,MAAI,MAAM;AAAO,aAAS,YAAW;;AAChC,aAAS,OAAM;AAEpB,MAAI;AAAY,UAAM;;AACjB,UAAM;AAGX,YAAU,MAAM;AAEhB,QAAM,KAAK,aAAa,SAAS;AAEjC,SAAO,CAAC,MAAM,MAAM,gBAAgB,cAAc;AACpD;AAQA,SAAS,iBAAiB,OAAO,UAAU;AAEzC,QAAM,OAAO,OAAO,SAAS,GAAG;AAGhC,QAAM,EAAC,QAAQ,YAAY,QAAQ,YAAY,WAAU,IAAI;AAE7D,QAAM,aAAa,SAAS;AAE5B,QAAM,aAAa,eAAe;AAElC,MAAI,YAAY;AACd,eAAW;AACX,eAAW;AAEX,QAAI,YAAY;AACd,iBAAW;AACX,YAAM;IACZ;EACA,OAAS;AACL,eAAW;AACX,eAAW;AAEX,QAAI,YAAY;AACd,iBAAW;AACX,YAAM;IACZ;EACA;AAGE,MAAI,MAAM;AAAO,aAAS,YAAW;;AAChC,aAAS,OAAM;AAEpB,MAAI;AAAY,UAAM;;AACjB,UAAM;AAGX,QAAM,KAAK,eAAe;IACxB,KAAK,SAAS;IACd;IACA,QAAQ,WAAW;IACnB,QAAQ,WAAW;IACnB;EACJ,CAAG;AACH;AAce,IAAM,QAAN,cAAoB,2BAAa;EAC9C,YAAY,SAAS;AACnB,UAAK;AAGL,cAAU,OAAO,CAAA,GAAI,UAAU,OAAO;AAGtC,QAAI,OAAO,QAAQ,UAAU;AAC3B,YAAM,IAAI;QACR,2EAA2E,QAAQ;MAC3F;AAEI,QAAI,CAAC,MAAM,IAAI,QAAQ,IAAI;AACzB,YAAM,IAAI;QACR,2GAA2G,QAAQ;MAC3H;AAEI,QAAI,OAAO,QAAQ,mBAAmB;AACpC,YAAM,IAAI;QACR,oFAAoF,QAAQ;MACpG;AAKI,UAAM,gBACJ,QAAQ,SAAS,UACb,gBACA,QAAQ,SAAS,aACjB,mBACA;AAEN,oBAAgB,MAAM,iBAAiB,aAAa;AAapD,UAAM,iBAAiB,UAAU,YAAW,IAAK;AACjD,QAAI,SAAS;AAEb,UAAM,mBAAmB,MAAM;AAC7B,UAAI;AAEJ,SAAG;AACD,2BAAmB,iBAAiB;MAC5C,SAAe,KAAK,OAAO,IAAI,gBAAgB;AAEzC,aAAO;IACb;AAGI,oBAAgB,MAAM,eAAe,CAAA,CAAE;AACvC,oBAAgB,MAAM,UAAU,oBAAI,IAAG,CAAE;AACzC,oBAAgB,MAAM,UAAU,oBAAI,IAAG,CAAE;AACzC,oBAAgB,MAAM,iBAAiB,CAAC;AACxC,oBAAgB,MAAM,mBAAmB,CAAC;AAC1C,oBAAgB,MAAM,0BAA0B,CAAC;AACjD,oBAAgB,MAAM,4BAA4B,CAAC;AACnD,oBAAgB,MAAM,qBAAqB,gBAAgB;AAG3D,oBAAgB,MAAM,YAAY,OAAO;AAGzC,kBAAc,QAAQ,UAAQ,gBAAgB,MAAM,MAAM,KAAK,IAAI,CAAC,CAAC;AAGrE,qBAAiB,MAAM,SAAS,MAAM,KAAK,OAAO,IAAI;AACtD,qBAAiB,MAAM,QAAQ,MAAM,KAAK,OAAO,IAAI;AACrD,qBAAiB,MAAM,gBAAgB,MAAM,KAAK,aAAa;AAC/D,qBAAiB,MAAM,kBAAkB,MAAM,KAAK,eAAe;AACnE;MACE;MACA;MACA,MAAM,KAAK,yBAAyB,KAAK;IAC/C;AACI;MACE;MACA;MACA,MAAM,KAAK;IACjB;AACI;MACE;MACA;MACA,MAAM,KAAK;IACjB;AACI,qBAAiB,MAAM,SAAS,KAAK,SAAS,KAAK;AACnD,qBAAiB,MAAM,QAAQ,KAAK,SAAS,IAAI;AACjD,qBAAiB,MAAM,kBAAkB,KAAK,SAAS,cAAc;AACrE,qBAAiB,MAAM,kBAAkB,MAAM,YAAY;EAC/D;EAEE,yBAAyB;AACvB,SAAK,gBAAgB;AACrB,SAAK,kBAAkB;AACvB,SAAK,yBAAyB;AAC9B,SAAK,2BAA2B;EACpC;;;;;;;;;;;EAaE,QAAQ,MAAM;AACZ,WAAO,KAAK,OAAO,IAAI,KAAK,IAAI;EACpC;;;;;;;;;;;;;;;EAgBE,gBAAgB,QAAQ,QAAQ;AAE9B,QAAI,KAAK,SAAS;AAAc,aAAO;AAEvC,QAAI,UAAU,WAAW,GAAG;AAC1B,YAAM,OAAO,KAAK;AAElB,YAAM,WAAW,KAAK,OAAO,IAAI,IAAI;AAErC,aAAO,CAAC,CAAC,YAAY,CAAC,SAAS;IACrC,WAAe,UAAU,WAAW,GAAG;AACjC,eAAS,KAAK;AACd,eAAS,KAAK;AAGd,YAAM,WAAW,KAAK,OAAO,IAAI,MAAM;AAEvC,UAAI,CAAC;AAAU,eAAO;AAGtB,aAAO,SAAS,IAAI,eAAe,MAAM;IAC/C;AAEI,UAAM,IAAI;MACR,yCAAyC,UAAU;IACzD;EACA;;;;;;;;;;;;;;;EAgBE,kBAAkB,QAAQ,QAAQ;AAEhC,QAAI,KAAK,SAAS;AAAY,aAAO;AAErC,QAAI,UAAU,WAAW,GAAG;AAC1B,YAAM,OAAO,KAAK;AAElB,YAAM,WAAW,KAAK,OAAO,IAAI,IAAI;AAErC,aAAO,CAAC,CAAC,YAAY,SAAS;IACpC,WAAe,UAAU,WAAW,GAAG;AACjC,eAAS,KAAK;AACd,eAAS,KAAK;AAGd,YAAM,WAAW,KAAK,OAAO,IAAI,MAAM;AAEvC,UAAI,CAAC;AAAU,eAAO;AAGtB,aAAO,SAAS,WAAW,eAAe,MAAM;IACtD;AAEI,UAAM,IAAI;MACR,yCAAyC,UAAU;IACzD;EACA;;;;;;;;;;;;;;;EAgBE,QAAQ,QAAQ,QAAQ;AACtB,QAAI,UAAU,WAAW,GAAG;AAC1B,YAAM,OAAO,KAAK;AAElB,aAAO,KAAK,OAAO,IAAI,IAAI;IACjC,WAAe,UAAU,WAAW,GAAG;AACjC,eAAS,KAAK;AACd,eAAS,KAAK;AAGd,YAAM,WAAW,KAAK,OAAO,IAAI,MAAM;AAEvC,UAAI,CAAC;AAAU,eAAO;AAGtB,aACG,OAAO,SAAS,QAAQ,eACvB,SAAS,IAAI,eAAe,MAAM,KACnC,OAAO,SAAS,eAAe,eAC9B,SAAS,WAAW,eAAe,MAAM;IAEnD;AAEI,UAAM,IAAI;MACR,iCAAiC,UAAU;IACjD;EACA;;;;;;;;;;;;EAaE,aAAa,QAAQ,QAAQ;AAC3B,QAAI,KAAK,SAAS;AAAc;AAEhC,aAAS,KAAK;AACd,aAAS,KAAK;AAEd,QAAI,KAAK;AACP,YAAM,IAAI;QACR;MACR;AAEI,UAAM,aAAa,KAAK,OAAO,IAAI,MAAM;AAEzC,QAAI,CAAC;AACH,YAAM,IAAI;QACR,2CAA2C;MACnD;AAEI,QAAI,CAAC,KAAK,OAAO,IAAI,MAAM;AACzB,YAAM,IAAI;QACR,2CAA2C;MACnD;AAEI,UAAM,WAAY,WAAW,OAAO,WAAW,IAAI,MAAM,KAAM;AAE/D,QAAI;AAAU,aAAO,SAAS;EAClC;;;;;;;;;;;;EAaE,eAAe,QAAQ,QAAQ;AAC7B,QAAI,KAAK,SAAS;AAAY;AAE9B,aAAS,KAAK;AACd,aAAS,KAAK;AAEd,QAAI,KAAK;AACP,YAAM,IAAI;QACR;MACR;AAEI,UAAM,aAAa,KAAK,OAAO,IAAI,MAAM;AAEzC,QAAI,CAAC;AACH,YAAM,IAAI;QACR,6CAA6C;MACrD;AAEI,QAAI,CAAC,KAAK,OAAO,IAAI,MAAM;AACzB,YAAM,IAAI;QACR,6CAA6C;MACrD;AAEI,UAAM,WACH,WAAW,cAAc,WAAW,WAAW,MAAM,KAAM;AAE9D,QAAI;AAAU,aAAO,SAAS;EAClC;;;;;;;;;;;;EAaE,KAAK,QAAQ,QAAQ;AACnB,QAAI,KAAK;AACP,YAAM,IAAI;QACR;MACR;AAEI,aAAS,KAAK;AACd,aAAS,KAAK;AAEd,UAAM,aAAa,KAAK,OAAO,IAAI,MAAM;AAEzC,QAAI,CAAC;AACH,YAAM,IAAI;QACR,mCAAmC;MAC3C;AAEI,QAAI,CAAC,KAAK,OAAO,IAAI,MAAM;AACzB,YAAM,IAAI;QACR,mCAAmC;MAC3C;AAEI,UAAM,WACH,WAAW,OAAO,WAAW,IAAI,MAAM,KACvC,WAAW,cAAc,WAAW,WAAW,MAAM,KACtD;AAEF,QAAI;AAAU,aAAO,SAAS;EAClC;;;;;;;;;;EAWE,qBAAqB,MAAM,UAAU;AACnC,WAAO,KAAK;AACZ,eAAW,KAAK;AAEhB,UAAM,WAAW,KAAK,OAAO,IAAI,IAAI;AAErC,QAAI,CAAC;AACH,YAAM,IAAI;QACR,mDAAmD;MAC3D;AAEI,QAAI,KAAK,SAAS;AAAc,aAAO;AAEvC,WAAO,YAAY,SAAS,MAAM,YAAY,SAAS;EAC3D;;;;;;;;;;EAWE,gBAAgB,MAAM,UAAU;AAC9B,WAAO,KAAK;AACZ,eAAW,KAAK;AAEhB,UAAM,WAAW,KAAK,OAAO,IAAI,IAAI;AAErC,QAAI,CAAC;AACH,YAAM,IAAI;QACR,8CAA8C;MACtD;AAEI,QAAI,KAAK,SAAS;AAAc,aAAO;AAEvC,WAAO,YAAY,SAAS;EAChC;;;;;;;;;;EAWE,eAAe,MAAM,UAAU;AAC7B,WAAO,KAAK;AACZ,eAAW,KAAK;AAEhB,UAAM,WAAW,KAAK,OAAO,IAAI,IAAI;AAErC,QAAI,CAAC;AACH,YAAM,IAAI;QACR,6CAA6C;MACrD;AAEI,QAAI,KAAK,SAAS;AAAc,aAAO;AAEvC,WAAO,YAAY,SAAS;EAChC;;;;;;;;;;EAWE,uBAAuB,MAAM,UAAU;AACrC,WAAO,KAAK;AACZ,eAAW,KAAK;AAEhB,UAAM,WAAW,KAAK,OAAO,IAAI,IAAI;AAErC,QAAI,CAAC;AACH,YAAM,IAAI;QACR,qDAAqD;MAC7D;AAEI,QAAI,KAAK,SAAS;AAAY,aAAO;AAErC,WAAO,YAAY,SAAS;EAChC;;;;;;;;;;EAWE,aAAa,MAAM,UAAU;AAC3B,WAAO,KAAK;AACZ,eAAW,KAAK;AAEhB,UAAM,WAAW,KAAK,OAAO,IAAI,IAAI;AAErC,QAAI,CAAC;AACH,YAAM,IAAI;QACR,2CAA2C;MACnD;AAEI,QAAI,KAAK,SAAS,cAAc;AAC9B,UAAI,YAAY,SAAS,MAAM,YAAY,SAAS;AAAK,eAAO;IACtE;AAEI,QAAI,KAAK,SAAS,YAAY;AAC5B,UAAI,YAAY,SAAS;AAAY,eAAO;IAClD;AAEI,WAAO;EACX;;;;;;;;;;EAWE,oBAAoB,MAAM,UAAU;AAClC,WAAO,KAAK;AACZ,eAAW,KAAK;AAEhB,UAAM,WAAW,KAAK,OAAO,IAAI,IAAI;AAErC,QAAI,CAAC;AACH,YAAM,IAAI;QACR,kDAAkD;MAC1D;AAEI,QAAI,KAAK,SAAS,cAAc;AAC9B,UAAI,YAAY,SAAS;AAAI,eAAO;IAC1C;AAEI,QAAI,KAAK,SAAS,YAAY;AAC5B,UAAI,YAAY,SAAS;AAAY,eAAO;IAClD;AAEI,WAAO;EACX;;;;;;;;;;EAWE,qBAAqB,MAAM,UAAU;AACnC,WAAO,KAAK;AACZ,eAAW,KAAK;AAEhB,UAAM,WAAW,KAAK,OAAO,IAAI,IAAI;AAErC,QAAI,CAAC;AACH,YAAM,IAAI;QACR,mDAAmD;MAC3D;AAEI,QAAI,KAAK,SAAS,cAAc;AAC9B,UAAI,YAAY,SAAS;AAAK,eAAO;IAC3C;AAEI,QAAI,KAAK,SAAS,YAAY;AAC5B,UAAI,YAAY,SAAS;AAAY,eAAO;IAClD;AAEI,WAAO;EACX;;;;;;;;;EAUE,SAAS,MAAM;AACb,WAAO,KAAK;AAEZ,UAAM,WAAW,KAAK,OAAO,IAAI,IAAI;AAErC,QAAI,CAAC;AACH,YAAM,IAAI;QACR,uCAAuC;MAC/C;AAEI,QAAI,KAAK,SAAS;AAAc,aAAO;AAEvC,WAAO,SAAS;EACpB;;;;;;;;;EAUE,UAAU,MAAM;AACd,WAAO,KAAK;AAEZ,UAAM,WAAW,KAAK,OAAO,IAAI,IAAI;AAErC,QAAI,CAAC;AACH,YAAM,IAAI;QACR,wCAAwC;MAChD;AAEI,QAAI,KAAK,SAAS;AAAc,aAAO;AAEvC,WAAO,SAAS;EACpB;;;;;;;;;EAUE,eAAe,MAAM;AACnB,WAAO,KAAK;AAEZ,UAAM,WAAW,KAAK,OAAO,IAAI,IAAI;AAErC,QAAI,CAAC;AACH,YAAM,IAAI;QACR,6CAA6C;MACrD;AAEI,QAAI,KAAK,SAAS;AAAc,aAAO;AAEvC,WAAO,SAAS,WAAW,SAAS;EACxC;;;;;;;;;EAUE,iBAAiB,MAAM;AACrB,WAAO,KAAK;AAEZ,UAAM,WAAW,KAAK,OAAO,IAAI,IAAI;AAErC,QAAI,CAAC;AACH,YAAM,IAAI;QACR,+CAA+C;MACvD;AAEI,QAAI,KAAK,SAAS;AAAY,aAAO;AAErC,WAAO,SAAS;EACpB;;;;;;;;;EAUE,cAAc,MAAM;AAClB,WAAO,KAAK;AAEZ,UAAM,WAAW,KAAK,OAAO,IAAI,IAAI;AAErC,QAAI,CAAC;AACH,YAAM,IAAI;QACR,4CAA4C;MACpD;AAEI,QAAI,SAAS;AAEb,QAAI,KAAK,SAAS,YAAY;AAC5B,gBAAU,SAAS;IACzB;AAEI,QAAI,KAAK,SAAS,cAAc;AAC9B,gBAAU,SAAS;IACzB;AAEI,WAAO;EACX;;;;;;;;;EAUE,eAAe,MAAM;AACnB,WAAO,KAAK;AAEZ,UAAM,WAAW,KAAK,OAAO,IAAI,IAAI;AAErC,QAAI,CAAC;AACH,YAAM,IAAI;QACR,6CAA6C;MACrD;AAEI,QAAI,SAAS;AAEb,QAAI,KAAK,SAAS,YAAY;AAC5B,gBAAU,SAAS;IACzB;AAEI,QAAI,KAAK,SAAS,cAAc;AAC9B,gBAAU,SAAS;IACzB;AAEI,WAAO;EACX;;;;;;;;;EAUE,OAAO,MAAM;AACX,WAAO,KAAK;AAEZ,UAAM,WAAW,KAAK,OAAO,IAAI,IAAI;AAErC,QAAI,CAAC;AACH,YAAM,IAAI;QACR,qCAAqC;MAC7C;AAEI,QAAI,SAAS;AAEb,QAAI,KAAK,SAAS,YAAY;AAC5B,gBAAU,SAAS;IACzB;AAEI,QAAI,KAAK,SAAS,cAAc;AAC9B,gBAAU,SAAS,WAAW,SAAS;IAC7C;AAEI,WAAO;EACX;;;;;;;;;EAUE,yBAAyB,MAAM;AAC7B,WAAO,KAAK;AAEZ,UAAM,WAAW,KAAK,OAAO,IAAI,IAAI;AAErC,QAAI,CAAC;AACH,YAAM,IAAI;QACR,uDAAuD;MAC/D;AAEI,QAAI,KAAK,SAAS;AAAc,aAAO;AAEvC,WAAO,SAAS,WAAW,SAAS;EACxC;;;;;;;;;EAUE,0BAA0B,MAAM;AAC9B,WAAO,KAAK;AAEZ,UAAM,WAAW,KAAK,OAAO,IAAI,IAAI;AAErC,QAAI,CAAC;AACH,YAAM,IAAI;QACR,wDAAwD;MAChE;AAEI,QAAI,KAAK,SAAS;AAAc,aAAO;AAEvC,WAAO,SAAS,YAAY,SAAS;EACzC;;;;;;;;;EAUE,+BAA+B,MAAM;AACnC,WAAO,KAAK;AAEZ,UAAM,WAAW,KAAK,OAAO,IAAI,IAAI;AAErC,QAAI,CAAC;AACH,YAAM,IAAI;QACR,6DAA6D;MACrE;AAEI,QAAI,KAAK,SAAS;AAAc,aAAO;AAEvC,WAAO,SAAS,WAAW,SAAS,YAAY,SAAS,gBAAgB;EAC7E;;;;;;;;;EAUE,iCAAiC,MAAM;AACrC,WAAO,KAAK;AAEZ,UAAM,WAAW,KAAK,OAAO,IAAI,IAAI;AAErC,QAAI,CAAC;AACH,YAAM,IAAI;QACR,+DAA+D;MACvE;AAEI,QAAI,KAAK,SAAS;AAAY,aAAO;AAErC,WAAO,SAAS,mBAAmB,SAAS,kBAAkB;EAClE;;;;;;;;;EAUE,8BAA8B,MAAM;AAClC,WAAO,KAAK;AAEZ,UAAM,WAAW,KAAK,OAAO,IAAI,IAAI;AAErC,QAAI,CAAC;AACH,YAAM,IAAI;QACR,4DAA4D;MACpE;AAEI,QAAI,SAAS;AACb,QAAI,QAAQ;AAEZ,QAAI,KAAK,SAAS,YAAY;AAC5B,gBAAU,SAAS;AACnB,eAAS,SAAS,kBAAkB;IAC1C;AAEI,QAAI,KAAK,SAAS,cAAc;AAC9B,gBAAU,SAAS;AACnB,eAAS,SAAS;IACxB;AAEI,WAAO,SAAS;EACpB;;;;;;;;;EAUE,+BAA+B,MAAM;AACnC,WAAO,KAAK;AAEZ,UAAM,WAAW,KAAK,OAAO,IAAI,IAAI;AAErC,QAAI,CAAC;AACH,YAAM,IAAI;QACR,6DAA6D;MACrE;AAEI,QAAI,SAAS;AACb,QAAI,QAAQ;AAEZ,QAAI,KAAK,SAAS,YAAY;AAC5B,gBAAU,SAAS;AACnB,eAAS,SAAS,kBAAkB;IAC1C;AAEI,QAAI,KAAK,SAAS,cAAc;AAC9B,gBAAU,SAAS;AACnB,eAAS,SAAS;IACxB;AAEI,WAAO,SAAS;EACpB;;;;;;;;;EAUE,uBAAuB,MAAM;AAC3B,WAAO,KAAK;AAEZ,UAAM,WAAW,KAAK,OAAO,IAAI,IAAI;AAErC,QAAI,CAAC;AACH,YAAM,IAAI;QACR,qDAAqD;MAC7D;AAEI,QAAI,SAAS;AACb,QAAI,QAAQ;AAEZ,QAAI,KAAK,SAAS,YAAY;AAC5B,gBAAU,SAAS;AACnB,eAAS,SAAS,kBAAkB;IAC1C;AAEI,QAAI,KAAK,SAAS,cAAc;AAC9B,gBAAU,SAAS,WAAW,SAAS;AACvC,eAAS,SAAS,gBAAgB;IACxC;AAEI,WAAO,SAAS;EACpB;;;;;;;;;EAUE,OAAO,MAAM;AACX,WAAO,KAAK;AAEZ,UAAM,OAAO,KAAK,OAAO,IAAI,IAAI;AAEjC,QAAI,CAAC;AACH,YAAM,IAAI;QACR,qCAAqC;MAC7C;AAEI,WAAO,KAAK,OAAO;EACvB;;;;;;;;;EAUE,OAAO,MAAM;AACX,WAAO,KAAK;AAEZ,UAAM,OAAO,KAAK,OAAO,IAAI,IAAI;AAEjC,QAAI,CAAC;AACH,YAAM,IAAI;QACR,qCAAqC;MAC7C;AAEI,WAAO,KAAK,OAAO;EACvB;;;;;;;;;EAUE,YAAY,MAAM;AAChB,WAAO,KAAK;AAEZ,UAAM,WAAW,KAAK,OAAO,IAAI,IAAI;AAErC,QAAI,CAAC;AACH,YAAM,IAAI;QACR,0CAA0C;MAClD;AAEI,WAAO,CAAC,SAAS,OAAO,KAAK,SAAS,OAAO,GAAG;EACpD;;;;;;;;;;;EAYE,SAAS,MAAM,MAAM;AACnB,WAAO,KAAK;AACZ,WAAO,KAAK;AAEZ,UAAM,OAAO,KAAK,OAAO,IAAI,IAAI;AAEjC,QAAI,CAAC;AACH,YAAM,IAAI;QACR,uCAAuC;MAC/C;AAEI,UAAM,SAAS,KAAK,OAAO;AAC3B,UAAM,SAAS,KAAK,OAAO;AAE3B,QAAI,SAAS;AAAQ,aAAO;AAC5B,QAAI,SAAS;AAAQ,aAAO;AAE5B,UAAM,IAAI;MACR,wBAAwB,sCAAsC,eAAe,WAAW;IAC9F;EACA;;;;;;;;;;EAWE,aAAa,MAAM,MAAM;AACvB,WAAO,KAAK;AACZ,WAAO,KAAK;AAEZ,UAAM,OAAO,KAAK,OAAO,IAAI,IAAI;AAEjC,QAAI,CAAC;AACH,YAAM,IAAI;QACR,2CAA2C;MACnD;AAEI,WAAO,KAAK,OAAO,QAAQ,QAAQ,KAAK,OAAO,QAAQ;EAC3D;;;;;;;;;EAUE,aAAa,MAAM;AACjB,WAAO,KAAK;AAEZ,UAAM,OAAO,KAAK,OAAO,IAAI,IAAI;AAEjC,QAAI,CAAC;AACH,YAAM,IAAI;QACR,2CAA2C;MACnD;AAEI,WAAO,KAAK;EAChB;;;;;;;;;EAUE,WAAW,MAAM;AACf,WAAO,KAAK;AAEZ,UAAM,OAAO,KAAK,OAAO,IAAI,IAAI;AAEjC,QAAI,CAAC;AACH,YAAM,IAAI;QACR,yCAAyC;MACjD;AAEI,WAAO,CAAC,KAAK;EACjB;;;;;;;;;EAUE,WAAW,MAAM;AACf,WAAO,KAAK;AAEZ,UAAM,OAAO,KAAK,OAAO,IAAI,IAAI;AAEjC,QAAI,CAAC;AACH,YAAM,IAAI;QACR,yCAAyC;MACjD;AAEI,WAAO,KAAK,WAAW,KAAK;EAChC;;;;;;;;;;;;;;;EAiBE,QAAQ,MAAM,YAAY;AACxB,UAAM,WAAW,QAAQ,MAAM,MAAM,UAAU;AAE/C,WAAO,SAAS;EACpB;;;;;;;;EASE,UAAU,MAAM,YAAY;AAC1B,QAAI,cAAc,CAAC,cAAc,UAAU;AACzC,YAAM,IAAI;QACR,qEAAqE;MAC7E;AAGI,WAAO,KAAK;AACZ,iBAAa,cAAc,CAAA;AAG3B,QAAI,OAAO,KAAK,OAAO,IAAI,IAAI;AAE/B,QAAI,MAAM;AACR,UAAI,YAAY;AACd,eAAO,KAAK,YAAY,UAAU;AAElC,aAAK,KAAK,yBAAyB;UACjC,MAAM;UACN,KAAK;UACL,YAAY,KAAK;UACjB,MAAM;QAChB,CAAS;MACT;AACM,aAAO,CAAC,MAAM,KAAK;IACzB;AAEI,WAAO,IAAI,KAAK,cAAc,MAAM,UAAU;AAG9C,SAAK,OAAO,IAAI,MAAM,IAAI;AAG1B,SAAK,KAAK,aAAa;MACrB,KAAK;MACL;IACN,CAAK;AAED,WAAO,CAAC,MAAM,IAAI;EACtB;;;;;;;;;EAUE,WAAW,MAAM,SAAS;AACxB,QAAI,WAAW,OAAO,YAAY;AAChC,YAAM,IAAI;QACR,6EAA6E;MACrF;AAGI,WAAO,KAAK;AAGZ,QAAI,OAAO,KAAK,OAAO,IAAI,IAAI;AAE/B,QAAI,MAAM;AACR,UAAI,SAAS;AACX,cAAM,gBAAgB,KAAK;AAC3B,aAAK,aAAa,QAAQ,aAAa;AAEvC,aAAK,KAAK,yBAAyB;UACjC,MAAM;UACN,KAAK;UACL,YAAY,KAAK;QAC3B,CAAS;MACT;AACM,aAAO,CAAC,MAAM,KAAK;IACzB;AAEI,UAAM,aAAa,UAAU,QAAQ,CAAA,CAAE,IAAI,CAAA;AAE3C,WAAO,IAAI,KAAK,cAAc,MAAM,UAAU;AAG9C,SAAK,OAAO,IAAI,MAAM,IAAI;AAG1B,SAAK,KAAK,aAAa;MACrB,KAAK;MACL;IACN,CAAK;AAED,WAAO,CAAC,MAAM,IAAI;EACtB;;;;;;;;;EAUE,SAAS,MAAM;AACb,WAAO,KAAK;AAEZ,UAAM,WAAW,KAAK,OAAO,IAAI,IAAI;AAErC,QAAI,CAAC;AACH,YAAM,IAAI;QACR,uCAAuC;MAC/C;AAEI,QAAI;AAIJ,QAAI,KAAK,SAAS,cAAc;AAC9B,iBAAW,YAAY,SAAS,KAAK;AACnC,mBAAW,SAAS,IAAI,QAAQ;AAEhC,WAAG;AACD,2BAAiB,MAAM,QAAQ;AAC/B,qBAAW,SAAS;QAC9B,SAAiB;MACjB;AAEM,iBAAW,YAAY,SAAS,IAAI;AAClC,mBAAW,SAAS,GAAG,QAAQ;AAE/B,WAAG;AACD,2BAAiB,MAAM,QAAQ;AAC/B,qBAAW,SAAS;QAC9B,SAAiB;MACjB;IACA;AAEI,QAAI,KAAK,SAAS,YAAY;AAC5B,iBAAW,YAAY,SAAS,YAAY;AAC1C,mBAAW,SAAS,WAAW,QAAQ;AAEvC,WAAG;AACD,2BAAiB,MAAM,QAAQ;AAC/B,qBAAW,SAAS;QAC9B,SAAiB;MACjB;IACA;AAGI,SAAK,OAAO,OAAO,IAAI;AAGvB,SAAK,KAAK,eAAe;MACvB,KAAK;MACL,YAAY,SAAS;IAC3B,CAAK;EACL;;;;;;;;;;;;;;;EAgBE,SAAS,MAAM;AACb,QAAI;AAEJ,QAAI,UAAU,SAAS,GAAG;AACxB,YAAM,SAAS,KAAK,UAAU,CAAC;AAC/B,YAAM,SAAS,KAAK,UAAU,CAAC;AAE/B,iBAAW,gBAAgB,MAAM,QAAQ,QAAQ,KAAK,IAAI;AAE1D,UAAI,CAAC;AACH,cAAM,IAAI;UACR,uCAAuC,eAAe;QAChE;IACA,OAAW;AACL,aAAO,KAAK;AAEZ,iBAAW,KAAK,OAAO,IAAI,IAAI;AAE/B,UAAI,CAAC;AACH,cAAM,IAAI;UACR,uCAAuC;QACjD;IACA;AAEI,qBAAiB,MAAM,QAAQ;AAE/B,WAAO;EACX;;;;;;;;;;;EAYE,iBAAiB,QAAQ,QAAQ;AAC/B,QAAI,UAAU,SAAS;AACrB,YAAM,IAAI;QACR;MACR;AAEI,QAAI,KAAK;AACP,YAAM,IAAI;QACR;MACR;AAEI,aAAS,KAAK;AACd,aAAS,KAAK;AAEd,UAAM,WAAW,gBAAgB,MAAM,QAAQ,QAAQ,UAAU;AAEjE,QAAI,CAAC;AACH,YAAM,IAAI;QACR,6CAA6C,eAAe;MACpE;AAEI,qBAAiB,MAAM,QAAQ;AAE/B,WAAO;EACX;;;;;;;;;;;EAYE,mBAAmB,QAAQ,QAAQ;AACjC,QAAI,UAAU,SAAS;AACrB,YAAM,IAAI;QACR;MACR;AAEI,QAAI,KAAK;AACP,YAAM,IAAI;QACR;MACR;AAEI,UAAM,WAAW,gBAAgB,MAAM,QAAQ,QAAQ,YAAY;AAEnE,QAAI,CAAC;AACH,YAAM,IAAI;QACR,+CAA+C,eAAe;MACtE;AAEI,qBAAiB,MAAM,QAAQ;AAE/B,WAAO;EACX;;;;;;EAOE,QAAQ;AAEN,SAAK,OAAO,MAAK;AAGjB,SAAK,OAAO,MAAK;AAGjB,SAAK,uBAAsB;AAG3B,SAAK,KAAK,SAAS;EACvB;;;;;;EAOE,aAAa;AAEX,UAAM,WAAW,KAAK,OAAO,OAAM;AAEnC,QAAI;AAEJ,WAAS,OAAO,SAAS,KAAI,GAAK,KAAK,SAAS,MAAO;AACrD,WAAK,MAAM,MAAK;IACtB;AAGI,SAAK,OAAO,MAAK;AAGjB,SAAK,uBAAsB;AAG3B,SAAK,KAAK,cAAc;EAC5B;;;;;;;;;;;EAaE,aAAa,MAAM;AACjB,WAAO,KAAK,YAAY,IAAI;EAChC;;;;;;EAOE,gBAAgB;AACd,WAAO,KAAK;EAChB;;;;;;;EAQE,aAAa,MAAM;AACjB,WAAO,KAAK,YAAY,eAAe,IAAI;EAC/C;;;;;;;;EASE,aAAa,MAAM,OAAO;AACxB,SAAK,YAAY,IAAI,IAAI;AAGzB,SAAK,KAAK,qBAAqB;MAC7B,MAAM;MACN,YAAY,KAAK;MACjB;IACN,CAAK;AAED,WAAO;EACX;;;;;;;;EASE,gBAAgB,MAAM,SAAS;AAC7B,QAAI,OAAO,YAAY;AACrB,YAAM,IAAI;QACR;MACR;AAEI,UAAM,QAAQ,KAAK,YAAY,IAAI;AAEnC,SAAK,YAAY,IAAI,IAAI,QAAQ,KAAK;AAGtC,SAAK,KAAK,qBAAqB;MAC7B,MAAM;MACN,YAAY,KAAK;MACjB;IACN,CAAK;AAED,WAAO;EACX;;;;;;;EAQE,gBAAgB,MAAM;AACpB,WAAO,KAAK,YAAY,IAAI;AAG5B,SAAK,KAAK,qBAAqB;MAC7B,MAAM;MACN,YAAY,KAAK;MACjB;IACN,CAAK;AAED,WAAO;EACX;;;;;;;;;EAUE,kBAAkB,YAAY;AAC5B,QAAI,CAAC,cAAc,UAAU;AAC3B,YAAM,IAAI;QACR;MACR;AAEI,SAAK,cAAc;AAGnB,SAAK,KAAK,qBAAqB;MAC7B,MAAM;MACN,YAAY,KAAK;IACvB,CAAK;AAED,WAAO;EACX;;;;;;;;;EAUE,gBAAgB,YAAY;AAC1B,QAAI,CAAC,cAAc,UAAU;AAC3B,YAAM,IAAI;QACR;MACR;AAEI,WAAO,KAAK,aAAa,UAAU;AAGnC,SAAK,KAAK,qBAAqB;MAC7B,MAAM;MACN,YAAY,KAAK;MACjB,MAAM;IACZ,CAAK;AAED,WAAO;EACX;;;;;;;;;EAUE,iBAAiB,SAAS;AACxB,QAAI,OAAO,YAAY;AACrB,YAAM,IAAI;QACR;MACR;AAEI,SAAK,cAAc,QAAQ,KAAK,WAAW;AAG3C,SAAK,KAAK,qBAAqB;MAC7B,MAAM;MACN,YAAY,KAAK;IACvB,CAAK;AAED,WAAO;EACX;;;;;;;EAQE,yBAAyB,SAAS,OAAO;AACvC,QAAI,OAAO,YAAY;AACrB,YAAM,IAAI;QACR;MACR;AAEI,QAAI,SAAS,CAAC,cAAc,KAAK;AAC/B,YAAM,IAAI;QACR;MACR;AAEI,UAAM,WAAW,KAAK,OAAO,OAAM;AAEnC,QAAI,MAAM;AAEV,WAAS,OAAO,SAAS,KAAI,GAAK,KAAK,SAAS,MAAO;AACrD,iBAAW,KAAK;AAChB,eAAS,aAAa,QAAQ,SAAS,KAAK,SAAS,UAAU;IACrE;AAEI,SAAK,KAAK,6BAA6B;MACrC,OAAO,QAAQ,QAAQ;IAC7B,CAAK;EACL;;;;;;;EAQE,yBAAyB,SAAS,OAAO;AACvC,QAAI,OAAO,YAAY;AACrB,YAAM,IAAI;QACR;MACR;AAEI,QAAI,SAAS,CAAC,cAAc,KAAK;AAC/B,YAAM,IAAI;QACR;MACR;AAEI,UAAM,WAAW,KAAK,OAAO,OAAM;AAEnC,QAAI,MAAM,UAAU,YAAY;AAEhC,WAAS,OAAO,SAAS,KAAI,GAAK,KAAK,SAAS,MAAO;AACrD,iBAAW,KAAK;AAChB,mBAAa,SAAS;AACtB,mBAAa,SAAS;AAEtB,eAAS,aAAa;QACpB,SAAS;QACT,SAAS;QACT,WAAW;QACX,WAAW;QACX,WAAW;QACX,WAAW;QACX,SAAS;MACjB;IACA;AAEI,SAAK,KAAK,6BAA6B;MACrC,OAAO,QAAQ,QAAQ;IAC7B,CAAK;EACL;;;;;;;;;;EAYE,sBAAsB,UAAU;AAC9B,QAAI,OAAO,aAAa;AACtB,YAAM,IAAI;QACR;MACR;AAEI,qBAAiB,OAAO,OAAO,OAAO,MAAM,QAAQ;EACxD;EACE,iCAAiC,UAAU;AACzC,QAAI,OAAO,aAAa;AACtB,YAAM,IAAI;QACR;MACR;AAEI,qBAAiB,OAAO,OAAO,MAAM,MAAM,QAAQ;EACvD;;;;;;EAOE,gCAAgC,UAAU;AACxC,QAAI,OAAO,aAAa;AACtB,YAAM,IAAI;QACR;MACR;AAEI,qBAAiB,OAAO,MAAM,OAAO,MAAM,QAAQ;EACvD;EACE,2CAA2C,UAAU;AACnD,QAAI,OAAO,aAAa;AACtB,YAAM,IAAI;QACR;MACR;AAEI,qBAAiB,OAAO,MAAM,MAAM,MAAM,QAAQ;EACtD;;;;;;EAOE,QAAQ;AACN,QAAI,OAAO,MAAM,SAAS;AAAY,aAAO,MAAM,KAAK,KAAK,OAAO,KAAI,CAAE;AAE1E,eAAO,YAAAE,SAAK,KAAK,OAAO,KAAI,GAAI,KAAK,OAAO,IAAI;EACpD;;;;;;EAOE,YAAY,UAAU;AACpB,QAAI,OAAO,aAAa;AACtB,YAAM,IAAI;QACR;MACR;AAEI,UAAM,WAAW,KAAK,OAAO,OAAM;AAEnC,QAAI,MAAM;AAEV,WAAS,OAAO,SAAS,KAAI,GAAK,KAAK,SAAS,MAAO;AACrD,iBAAW,KAAK;AAChB,eAAS,SAAS,KAAK,SAAS,UAAU;IAChD;EACA;;;;;;;EAQE,SAAS,UAAU;AACjB,QAAI,OAAO,aAAa;AACtB,YAAM,IAAI;QACR;MACR;AAEI,UAAM,WAAW,KAAK,OAAO,OAAM;AAEnC,QAAI,MAAM;AAEV,WAAS,OAAO,SAAS,KAAI,GAAK,KAAK,SAAS,MAAO;AACrD,iBAAW,KAAK;AAEhB,UAAI,SAAS,SAAS,KAAK,SAAS,UAAU;AAAG,eAAO,SAAS;IACvE;AAEI;EACJ;;;;;;EAOE,SAAS,UAAU;AACjB,QAAI,OAAO,aAAa;AACtB,YAAM,IAAI;QACR;MACR;AAEI,UAAM,WAAW,KAAK,OAAO,OAAM;AAEnC,QAAI,MAAM;AAEV,UAAM,SAAS,IAAI,MAAM,KAAK,KAAK;AACnC,QAAI,IAAI;AAER,WAAS,OAAO,SAAS,KAAI,GAAK,KAAK,SAAS,MAAO;AACrD,iBAAW,KAAK;AAChB,aAAO,GAAG,IAAI,SAAS,SAAS,KAAK,SAAS,UAAU;IAC9D;AAEI,WAAO;EACX;;;;;;EAOE,SAAS,UAAU;AACjB,QAAI,OAAO,aAAa;AACtB,YAAM,IAAI;QACR;MACR;AAEI,UAAM,WAAW,KAAK,OAAO,OAAM;AAEnC,QAAI,MAAM;AAEV,WAAS,OAAO,SAAS,KAAI,GAAK,KAAK,SAAS,MAAO;AACrD,iBAAW,KAAK;AAEhB,UAAI,SAAS,SAAS,KAAK,SAAS,UAAU;AAAG,eAAO;IAC9D;AAEI,WAAO;EACX;;;;;;EAOE,UAAU,UAAU;AAClB,QAAI,OAAO,aAAa;AACtB,YAAM,IAAI;QACR;MACR;AAEI,UAAM,WAAW,KAAK,OAAO,OAAM;AAEnC,QAAI,MAAM;AAEV,WAAS,OAAO,SAAS,KAAI,GAAK,KAAK,SAAS,MAAO;AACrD,iBAAW,KAAK;AAEhB,UAAI,CAAC,SAAS,SAAS,KAAK,SAAS,UAAU;AAAG,eAAO;IAC/D;AAEI,WAAO;EACX;;;;;;EAOE,YAAY,UAAU;AACpB,QAAI,OAAO,aAAa;AACtB,YAAM,IAAI;QACR;MACR;AAEI,UAAM,WAAW,KAAK,OAAO,OAAM;AAEnC,QAAI,MAAM;AAEV,UAAM,SAAS,CAAA;AAEf,WAAS,OAAO,SAAS,KAAI,GAAK,KAAK,SAAS,MAAO;AACrD,iBAAW,KAAK;AAEhB,UAAI,SAAS,SAAS,KAAK,SAAS,UAAU;AAC5C,eAAO,KAAK,SAAS,GAAG;IAChC;AAEI,WAAO;EACX;;;;;;EAOE,YAAY,UAAU,cAAc;AAClC,QAAI,OAAO,aAAa;AACtB,YAAM,IAAI;QACR;MACR;AAEI,QAAI,UAAU,SAAS;AACrB,YAAM,IAAI;QACR;MACR;AAEI,QAAI,cAAc;AAElB,UAAM,WAAW,KAAK,OAAO,OAAM;AAEnC,QAAI,MAAM;AAEV,WAAS,OAAO,SAAS,KAAI,GAAK,KAAK,SAAS,MAAO;AACrD,iBAAW,KAAK;AAChB,oBAAc,SAAS,aAAa,SAAS,KAAK,SAAS,UAAU;IAC3E;AAEI,WAAO;EACX;;;;;;EAOE,cAAc;AACZ,UAAM,WAAW,KAAK,OAAO,OAAM;AAEnC,WAAO,IAAI,gBAAAD,QAAS,MAAM;AACxB,YAAM,OAAO,SAAS,KAAI;AAE1B,UAAI,KAAK;AAAM,eAAO;AAEtB,YAAM,OAAO,KAAK;AAElB,aAAO;QACL,OAAO,EAAC,MAAM,KAAK,KAAK,YAAY,KAAK,WAAU;QACnD,MAAM;MACd;IACA,CAAK;EACL;;;;;;;;;;EAYE,SAAS;AACP,UAAM,QAAQ,IAAI,MAAM,KAAK,OAAO,IAAI;AAExC,QAAI,IAAI;AAER,SAAK,OAAO,QAAQ,CAAC,MAAM,QAAQ;AACjC,YAAM,GAAG,IAAI,cAAc,KAAK,IAAI;IAC1C,CAAK;AAED,UAAM,QAAQ,IAAI,MAAM,KAAK,OAAO,IAAI;AAExC,QAAI;AAEJ,SAAK,OAAO,QAAQ,CAAC,MAAM,QAAQ;AACjC,YAAM,GAAG,IAAI,cAAc,KAAK,MAAM,KAAK,IAAI;IACrD,CAAK;AAED,WAAO;MACL,SAAS;QACP,MAAM,KAAK;QACX,OAAO,KAAK;QACZ,gBAAgB,KAAK;MAC7B;MACM,YAAY,KAAK,cAAa;MAC9B;MACA;IACN;EACA;;;;;;;;EASE,OAAO,MAAM,QAAQ,OAAO;AAE1B,QAAI,gBAAgB,OAAO;AAEzB,WAAK,YAAY,CAAC,GAAG,MAAM;AACzB,YAAI;AAAO,eAAK,UAAU,GAAG,CAAC;;AACzB,eAAK,QAAQ,GAAG,CAAC;MAC9B,CAAO;AAGD,WAAK,YAAY,CAAC,GAAG,GAAG,GAAG,GAAG,KAAK,KAAK,MAAM;AAC5C,YAAI,OAAO;AACT,cAAI;AAAG,iBAAK,2BAA2B,GAAG,GAAG,GAAG,CAAC;;AAC5C,iBAAK,yBAAyB,GAAG,GAAG,GAAG,CAAC;QACvD,OAAe;AACL,cAAI;AAAG,iBAAK,yBAAyB,GAAG,GAAG,GAAG,CAAC;;AAC1C,iBAAK,uBAAuB,GAAG,GAAG,GAAG,CAAC;QACrD;MACA,CAAO;AAED,aAAO;IACb;AAGI,QAAI,CAAC,cAAc,IAAI;AACrB,YAAM,IAAI;QACR;MACR;AAEI,QAAI,KAAK,YAAY;AACnB,UAAI,CAAC,cAAc,KAAK,UAAU;AAChC,cAAM,IAAI;UACR;QACV;AAEM,UAAI;AAAO,aAAK,gBAAgB,KAAK,UAAU;;AAC1C,aAAK,kBAAkB,KAAK,UAAU;IACjD;AAEI,QAAI,GAAG,GAAG,MAAM,MAAM;AAEtB,QAAI,KAAK,OAAO;AACd,aAAO,KAAK;AAEZ,UAAI,CAAC,MAAM,QAAQ,IAAI;AACrB,cAAM,IAAI;UACR;QACV;AAEM,WAAK,IAAI,GAAG,IAAI,KAAK,QAAQ,IAAI,GAAG,KAAK;AACvC,eAAO,KAAK,CAAC;AAGb,+BAAuB,IAAI;AAG3B,cAAM,EAAC,KAAK,WAAU,IAAI;AAE1B,YAAI;AAAO,eAAK,UAAU,KAAK,UAAU;;AACpC,eAAK,QAAQ,KAAK,UAAU;MACzC;IACA;AAEI,QAAI,KAAK,OAAO;AACd,UAAI,sBAAsB;AAE1B,UAAI,KAAK,SAAS,cAAc;AAC9B,8BAAsB;MAC9B;AAEM,aAAO,KAAK;AAEZ,UAAI,CAAC,MAAM,QAAQ,IAAI;AACrB,cAAM,IAAI;UACR;QACV;AAEM,WAAK,IAAI,GAAG,IAAI,KAAK,QAAQ,IAAI,GAAG,KAAK;AACvC,eAAO,KAAK,CAAC;AAGb,+BAAuB,IAAI;AAG3B,cAAM;UACJ;UACA;UACA;UACA,aAAa;QACvB,IAAY;AAEJ,YAAI;AAEJ,YAAI,SAAS,MAAM;AACjB,mBAAS,QACL,aACE,KAAK,6BACL,KAAK,2BACP,aACA,KAAK,2BACL,KAAK;AAET,iBAAO,KAAK,MAAM,KAAK,KAAK,QAAQ,QAAQ,UAAU;QAChE,OAAe;AACL,mBAAS,QACL,aACE,KAAK,sBACL,KAAK,oBACP,aACA,KAAK,oBACL,KAAK;AAET,iBAAO,KAAK,MAAM,QAAQ,QAAQ,UAAU;QACtD;MACA;IACA;AAEI,WAAO;EACX;;;;;;;;;;;;EAcE,SAAS,SAAS;AAChB,UAAM,QAAQ,IAAI,MAAM,OAAO,CAAA,GAAI,KAAK,UAAU,OAAO,CAAC;AAC1D,UAAM,kBAAkB,OAAO,CAAA,GAAI,KAAK,cAAa,CAAE,CAAC;AACxD,WAAO;EACX;;;;;;;;EASE,UAAU,SAAS;AACjB,UAAM,QAAQ,KAAK,SAAS,OAAO;AAEnC,SAAK,OAAO,QAAQ,CAAC,UAAU,QAAQ;AACrC,YAAM,aAAa,OAAO,CAAA,GAAI,SAAS,UAAU;AAGjD,iBAAW,IAAI,MAAM,cAAc,KAAK,UAAU;AAClD,YAAM,OAAO,IAAI,KAAK,QAAQ;IACpC,CAAK;AAED,WAAO;EACX;;;;;;;EAQE,KAAK,SAAS;AACZ,cAAU,WAAW,CAAA;AAErB,QACE,OAAO,QAAQ,SAAS,YACxB,QAAQ,SAAS,KAAK,QACtB,QAAQ,SAAS;AAEjB,YAAM,IAAI;QACR,wDAAwD,KAAK,kBAAkB,QAAQ;MAC/F;AAEI,QACE,OAAO,QAAQ,UAAU,aACzB,QAAQ,UAAU,KAAK,SACvB,QAAQ,UAAU;AAElB,YAAM,IAAI;QACR;MACR;AAEI,QACE,OAAO,QAAQ,mBAAmB,aAClC,QAAQ,mBAAmB,KAAK,kBAChC,QAAQ,mBAAmB;AAE3B,YAAM,IAAI;QACR;MACR;AAEI,UAAM,QAAQ,KAAK,UAAU,OAAO;AAEpC,UAAM,WAAW,KAAK,OAAO,OAAM;AAEnC,QAAI,MAAM;AAEV,WAAS,OAAO,SAAS,KAAI,GAAK,KAAK,SAAS,MAAO;AACrD,iBAAW,KAAK;AAGhB;QACE;QACA;QACA;QACA,SAAS;QACT,SAAS;QACT,SAAS,OAAO;QAChB,SAAS,OAAO;QAChB,OAAO,CAAA,GAAI,SAAS,UAAU;MACtC;IACA;AAEI,WAAO;EACX;;;;;;;;;;EAYE,SAAS;AACP,WAAO,KAAK,OAAM;EACtB;;;;EAKE,WAAW;AACT,WAAO;EACX;;;;;;EAOE,UAAU;AACR,UAAM,QAAQ,CAAA;AACd,SAAK,OAAO,QAAQ,CAAC,MAAM,QAAQ;AACjC,YAAM,GAAG,IAAI,KAAK;IACxB,CAAK;AAED,UAAM,QAAQ,CAAA,GACZ,aAAa,CAAA;AAEf,SAAK,OAAO,QAAQ,CAAC,MAAM,QAAQ;AACjC,YAAM,YAAY,KAAK,aAAa,OAAO;AAE3C,UAAI,QAAQ;AAEZ,UAAI,SAAS,KAAK,OAAO;AACzB,UAAI,SAAS,KAAK,OAAO;AACzB,UAAI;AAEJ,UAAI,KAAK,cAAc,SAAS,QAAQ;AACtC,cAAM;AACN,iBAAS;AACT,iBAAS;MACjB;AAEM,YAAM,OAAO,IAAI,UAAU,aAAa;AAExC,UAAI,CAAC,IAAI,WAAW,OAAO,GAAG;AAC5B,iBAAS,IAAI;MACrB,WAAiB,KAAK,OAAO;AACrB,YAAI,OAAO,WAAW,IAAI,MAAM,aAAa;AAC3C,qBAAW,IAAI,IAAI;QAC7B,OAAe;AACL,qBAAW,IAAI;QACzB;AAEQ,iBAAS,GAAG,WAAW,IAAI;MACnC;AAEM,eAAS;AAET,YAAM,KAAK,IAAI,KAAK;IAC1B,CAAK;AAED,UAAM,QAAQ,CAAA;AAEd,eAAW,KAAK,MAAM;AACpB,UACE,KAAK,eAAe,CAAC,KACrB,CAAC,cAAc,IAAI,CAAC,KACpB,OAAO,KAAK,CAAC,MAAM,cACnB,OAAO,MAAM;AAEb,cAAM,CAAC,IAAI,KAAK,CAAC;IACzB;AAEI,UAAM,aAAa,KAAK;AACxB,UAAM,QAAQ;AACd,UAAM,QAAQ;AAEd,oBAAgB,OAAO,eAAe,KAAK,WAAW;AAEtD,WAAO;EACX;AACA;AAaA,IAAI,OAAO,WAAW;AACpB,QAAM,UAAU,OAAO,IAAI,4BAA4B,CAAC,IACtD,MAAM,UAAU;AAKpB,iBAAiB,QAAQ,YAAU;AACjC,GAAC,OAAO,SAAS,QAAQ,EAAE,QAAQ,UAAQ;AACzC,UAAM,OAAO,OAAO,KAAK,IAAI;AAC7B,UAAM,KAAK,SAAS,QAAQ,UAAU;AAEtC,QAAI,OAAO,aAAa;AACtB,YAAM,UAAU,IAAI,IAAI,SAAU,QAAQ,QAAQ,YAAY;AAC5D,eAAO;UACL;UACA;UACA;WACC,OAAO,QAAQ,KAAK,UAAU;UAC/B;UACA;UACA;UACA;UACA,SAAS;QACnB;MACA;IACA,OAAW;AACL,YAAM,UAAU,IAAI,IAAI,SAAU,MAAM,QAAQ,QAAQ,YAAY;AAClE,eAAO;UACL;UACA;UACA;WACC,OAAO,QAAQ,KAAK,UAAU;UAC/B;UACA;UACA;UACA;UACA,SAAS;QACnB;MACA;IACA;EACA,CAAG;AACH,CAAC;AAKD,4BAA4B,KAAK;AACjC,4BAA4B,KAAK;AAKjC,2BAA2B,KAAK;AAKhC,+BAA+B,KAAK;ACl6FpC,IAAM,gBAAN,cAA4B,MAAM;EAChC,YAAY,SAAS;AACnB,UAAM,eAAe,OAAO,EAAC,MAAM,WAAU,GAAG,OAAO;AAEvD,QAAI,WAAW,gBAAgB,aAAa,UAAU;AACpD,YAAM,IAAI;QACR;MACR;AAEI,QAAI,aAAa,SAAS;AACxB,YAAM,IAAI;QACR,uCACE,aAAa,OACb;MACV;AAEI,UAAM,YAAY;EACtB;AACA;AACA,IAAM,kBAAN,cAA8B,MAAM;EAClC,YAAY,SAAS;AACnB,UAAM,eAAe,OAAO,EAAC,MAAM,aAAY,GAAG,OAAO;AAEzD,QAAI,WAAW,gBAAgB,aAAa,UAAU;AACpD,YAAM,IAAI;QACR;MACR;AAEI,QAAI,aAAa,SAAS;AACxB,YAAM,IAAI;QACR,yCACE,aAAa,OACb;MACV;AAEI,UAAM,YAAY;EACtB;AACA;AACA,IAAM,aAAN,cAAyB,MAAM;EAC7B,YAAY,SAAS;AACnB,UAAM,eAAe,OAAO,EAAC,OAAO,KAAI,GAAG,OAAO;AAElD,QAAI,WAAW,gBAAgB,aAAa,UAAU;AACpD,YAAM,IAAI;QACR;MACR;AAEI,UAAM,YAAY;EACtB;AACA;AACA,IAAM,qBAAN,cAAiC,MAAM;EACrC,YAAY,SAAS;AACnB,UAAM,eAAe,OAAO,EAAC,MAAM,YAAY,OAAO,KAAI,GAAG,OAAO;AAEpE,QAAI,WAAW,gBAAgB,aAAa,UAAU;AACpD,YAAM,IAAI;QACR;MACR;AAEI,QAAI,aAAa,SAAS;AACxB,YAAM,IAAI;QACR,4CACE,aAAa,OACb;MACV;AAEI,UAAM,YAAY;EACtB;AACA;AACA,IAAM,uBAAN,cAAmC,MAAM;EACvC,YAAY,SAAS;AACnB,UAAM,eAAe,OAAO,EAAC,MAAM,cAAc,OAAO,KAAI,GAAG,OAAO;AAEtE,QAAI,WAAW,gBAAgB,aAAa,UAAU;AACpD,YAAM,IAAI;QACR;MACR;AAEI,QAAI,aAAa,SAAS;AACxB,YAAM,IAAI;QACR,8CACE,aAAa,OACb;MACV;AAEI,UAAM,YAAY;EACtB;AACA;AAKA,SAAS,uBAAuB,OAAO;AAQrC,QAAM,OAAO,SAAU,MAAM,SAAS;AAEpC,UAAM,eAAe,OAAO,CAAA,GAAI,KAAK,SAAS,OAAO;AAErD,UAAM,WAAW,IAAI,MAAM,YAAY;AACvC,aAAS,OAAO,IAAI;AAEpB,WAAO;EACX;AACA;AAEA,uBAAuB,KAAK;AAC5B,uBAAuB,aAAa;AACpC,uBAAuB,eAAe;AACtC,uBAAuB,UAAU;AACjC,uBAAuB,kBAAkB;AACzC,uBAAuB,oBAAoB;AAE3C,MAAM,QAAQ;AACd,MAAM,gBAAgB;AACtB,MAAM,kBAAkB;AACxB,MAAM,aAAa;AACnB,MAAM,qBAAqB;AAC3B,MAAM,uBAAuB;AAE7B,MAAM,6BAA6B;AACnC,MAAM,qBAAqB;AAC3B,MAAM,kBAAkB;",
  "names": ["Iterator", "Iterator", "take", "Iterator", "chain", "Graph", "Iterator", "take", "chain"]
}
